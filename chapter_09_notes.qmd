---
title: Advanced R - Chapter 9 Notes
format:
  html:
      toc: true

---

# 9 Functionals

A **functional** is a function that takes a function as an input and returns a vector as output. Here is an example of a functional:

```{r}

randomise <- function(f) f(runif(1e3))
randomise(mean)
#> [1] 0.506
randomise(mean)
#> [1] 0.501
randomise(sum)
#> [1] 489

```

A common use for functionals is as an alternative to for loops. It's better to use functionals because each functional is tailored for a specific task, so when you recognize a functional you immediately know why it's being used.

## 9.2 My first functional: map()

Section 9.2 introduces your first functional: `purrr::map()`. `map()` takes a vector and a function, calls the function once for each element of the vector, and returns the results in a list.

```{r}
library(purrr)

triple <- function(x) x * 3
map(1:3, triple)
#> [[1]]
#> [1] 3
#> 
#> [[2]]
#> [1] 6
#> 
#> [[3]]
#> [1] 9

```

And here is the implementation - allocate a list, and then fill in the list with a for loop. The base equivalent to `map()` is `lapply()`.

```{r}

simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}

```

**Producing atomic vectors**. You can do this with `map_lgl()`, `map_int()`, `map_dbl()`, and `map_chr()` when you don't want to return a list and want an atomic vector.

```{r}

# map_chr() always returns a character vector
map_chr(mtcars, typeof)
#>      mpg      cyl     disp       hp     drat       wt     qsec       vs 
#> "double" "double" "double" "double" "double" "double" "double" "double" 
#>       am     gear     carb 
#> "double" "double" "double"

# map_lgl() always returns a logical vector
map_lgl(mtcars, is.double)
#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#> TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE

# map_int() always returns a integer vector
n_unique <- function(x) length(unique(x))
map_int(mtcars, n_unique)
#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#>   25    3   27   22   22   29   30    2    2    3    6

# map_dbl() always returns a double vector
map_dbl(mtcars, mean)
#>     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear 
#>  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 
#>    carb 
#>   2.812

```

You can feed these functions any type of vector as input.

**Anonymous functions and shortcuts**. You can use `map()` with an inline anonymous function.

```{r}

map_dbl(mtcars, function(x) length(unique(x)))
#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#>   25    3   27   22   22   29   30    2    2    3    6

```

This is verbose, so purrr supports a different syntax for anonymous functions:

```{r}

map_dbl(mtcars, ~ length(unique(.x)))
#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#>   25    3   27   22   22   29   30    2    2    3    6

# refer to .x and .y for two argument functions, and ..1, ..2, etc. for arbitrary numbers of functions.


```

```{r}

x <- map(1:3, ~ runif(2))
str(x)
#> List of 3
#>  $ : num [1:2] 0.281 0.53
#>  $ : num [1:2] 0.433 0.917
#>  $ : num [1:2] 0.0275 0.8249

```

If your function spans lines or uses `{}`, give it a name.

Extracting elements from a vector is powered by `purrr::pluck()`. You can use a character vector, an integer vector, or a list to select elements using both name and position.

```{r}

x <- list(
  list(-1, x = 1, y = c(2), z = "a"),
  list(-2, x = 4, y = c(5, 6), z = "b"),
  list(-3, x = 8, y = c(9, 10, 11))
)

# Select by name
map_dbl(x, "x")
#> [1] 1 4 8

# Or by position
map_dbl(x, 1)
#> [1] -1 -2 -3

# Or by both
map_dbl(x, list("y", 1))
#> [1] 2 5 9

# You'll get an error if a component doesn't exist:
# map_chr(x, "z")
#> Error in map_chr(x, "z"): â„¹ In index: 3.
#> Caused by error:
#> ! Result must be length 1, not 0.

# Unless you supply a .default value
map_chr(x, "z", .default = NA)
#> [1] "a" "b" NA

```

**Passing arguments with ...**. Sometimes you need to pass on additional arguments to a function, such as `na.rm = TRUE` when using `mean()`. This can be done in two ways:

```{r}

# anonymous function
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))
#> [1] 3.0 5.5


```

Since map functions pass `...` along, there's a simpler form available:

```{r}

map_dbl(x, mean, na.rm = TRUE)
#> [1] 3.0 5.5

```

Arguments that come after the function you use in the call to `map()` are passed to the function as additional arguments after the data. So the data are the first argument, and then come you `...` arguments.

Also, extra argument inside an anonymous function are evaluated each time `f()` is executed, not just once as in the case of `map()`.

```{r}

plus <- function(x, y) x + y

x <- c(0, 0, 0, 0)
map_dbl(x, plus, runif(1))
#> [1] 0.0625 0.0625 0.0625 0.0625
map_dbl(x, ~ plus(.x, runif(1)))
#> [1] 0.903 0.132 0.629 0.945

```

**Argument names**. Use them. Note that named matching beats positional matching in function calls. Remember that `purrr` uses `.x` and `.f` in function calls.

**Varying another argument**. What if you want the first argument (the `.x`) to stay constant and you want to vary the function that is applied to it? There's no direct way.

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

map_dbl(trims, ~ mean(x, trim = .x))
#> [1] -0.3500  0.0434  0.0354  0.0502

# or without using an anonymous function:

map_dbl(trims, function(trim) mean(x, trim = trim))
#> [1] -0.3500  0.0434  0.0354  0.0502

```


## 9.3 Purrr style

Section 9.3 demonstrates how you can combine multiple simple functionals to solve a more complex problem and discusses how purrr style differs from other approaches.

Solving a realistic problemw with multiple purrr functions: fitting a model to each subgroup and extracting a coefficient of the model


```{r}

by_cyl <- split(mtcars, mtcars$cyl)

# fit a model extract the slope coefficient
by_cyl %>% 
  map(~ lm(mpg ~ wt, data = .x)) %>% 
  map(coef) %>% 
  map_dbl(2)
#>     4     6     8 
#> -5.65 -2.78 -2.19

```

Other approaches to do the same thing are more verbose, more complex.

Base R with the pipe:

```{r}

by_cyl %>% 
  lapply(function(data) lm(mpg ~ wt, data = data)) %>% 
  lapply(coef) %>% 
  vapply(function(x) x[[2]], double(1))
#>     4     6     8 
#> -5.65 -2.78 -2.19

```

Base R without the pipe:

```{r}

models <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))
vapply(models, function(x) coef(x)[[2]], double(1))
#>     4     6     8 
#> -5.65 -2.78 -2.19

```

a for loop:

```{r}

slopes <- double(length(by_cyl))
for (i in seq_along(by_cyl)) {
  model <- lm(mpg ~ wt, data = by_cyl[[i]])
  slopes[[i]] <- coef(model)[[2]]
}
slopes
#> [1] -5.65 -2.78 -2.19

```


## 9.4 Map variants

Section 9.4 teaches you about 18 (!!) important variants of purrr::map(). Fortunately, their orthogonal design makes them easy to learn, remember, and master.


```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```


```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

## 9.5 Reduce family

Section 9.5 introduces a new style of functional: purrr::reduce(). reduce() systematically reduces a vector to a single result by applying a function that takes two inputs.


```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

## 9.6 Predicate functionals

Section 9.6 teaches you about predicates: functions that return a single TRUE or FALSE, and the family of functionals that use them to solve common problems.


```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

## 9.7 Base functionals

Section 9.7 reviews some functionals in base R that are not members of the map, reduce, or predicate families.



```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```

```{r}



```