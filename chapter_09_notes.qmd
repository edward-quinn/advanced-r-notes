---
title: Advanced R - Chapter 9 Notes
format:
  html:
      toc: true

---

# 9 Functionals

A **functional** is a function that takes a function as an input and returns a vector as output. Here is an example of a functional:

```{r}

randomise <- function(f) f(runif(1e3))
randomise(mean)
#> [1] 0.506
randomise(mean)
#> [1] 0.501
randomise(sum)
#> [1] 489

```

A common use for functionals is as an alternative to for loops. It's better to use functionals because each functional is tailored for a specific task, so when you recognize a functional you immediately know why it's being used.

## 9.2 My first functional: map()

Section 9.2 introduces your first functional: `purrr::map()`. `map()` takes a vector and a function, calls the function once for each element of the vector, and returns the results in a list.

```{r}
library(purrr)

triple <- function(x) x * 3
map(1:3, triple)
#> [[1]]
#> [1] 3
#> 
#> [[2]]
#> [1] 6
#> 
#> [[3]]
#> [1] 9

```

And here is the implementation - allocate a list, and then fill in the list with a for loop. The base equivalent to `map()` is `lapply()`.

```{r}

simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}

```

**Producing atomic vectors**. You can do this with `map_lgl()`, `map_int()`, `map_dbl()`, and `map_chr()` when you don't want to return a list and want an atomic vector.

```{r}

# map_chr() always returns a character vector
map_chr(mtcars, typeof)
#>      mpg      cyl     disp       hp     drat       wt     qsec       vs 
#> "double" "double" "double" "double" "double" "double" "double" "double" 
#>       am     gear     carb 
#> "double" "double" "double"

# map_lgl() always returns a logical vector
map_lgl(mtcars, is.double)
#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#> TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE

# map_int() always returns a integer vector
n_unique <- function(x) length(unique(x))
map_int(mtcars, n_unique)
#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#>   25    3   27   22   22   29   30    2    2    3    6

# map_dbl() always returns a double vector
map_dbl(mtcars, mean)
#>     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear 
#>  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 
#>    carb 
#>   2.812

```

You can feed these functions any type of vector as input.

**Anonymous functions and shortcuts**. You can use `map()` with an inline anonymous function.

```{r}

map_dbl(mtcars, function(x) length(unique(x)))
#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#>   25    3   27   22   22   29   30    2    2    3    6

```

This is verbose, so purrr supports a different syntax for anonymous functions:

```{r}

map_dbl(mtcars, ~ length(unique(.x)))
#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#>   25    3   27   22   22   29   30    2    2    3    6

# refer to .x and .y for two argument functions, and ..1, ..2, etc. for arbitrary numbers of functions.


```

```{r}

x <- map(1:3, ~ runif(2))
str(x)
#> List of 3
#>  $ : num [1:2] 0.281 0.53
#>  $ : num [1:2] 0.433 0.917
#>  $ : num [1:2] 0.0275 0.8249

```

If your function spans lines or uses `{}`, give it a name.

Extracting elements from a vector is powered by `purrr::pluck()`. You can use a character vector, an integer vector, or a list to select elements using both name and position.

```{r}

x <- list(
  list(-1, x = 1, y = c(2), z = "a"),
  list(-2, x = 4, y = c(5, 6), z = "b"),
  list(-3, x = 8, y = c(9, 10, 11))
)

# Select by name
map_dbl(x, "x")
#> [1] 1 4 8

# Or by position
map_dbl(x, 1)
#> [1] -1 -2 -3

# Or by both
map_dbl(x, list("y", 1))
#> [1] 2 5 9

# You'll get an error if a component doesn't exist:
# map_chr(x, "z")
#> Error in map_chr(x, "z"): â„¹ In index: 3.
#> Caused by error:
#> ! Result must be length 1, not 0.

# Unless you supply a .default value
map_chr(x, "z", .default = NA)
#> [1] "a" "b" NA

```

**Passing arguments with ...**. Sometimes you need to pass on additional arguments to a function, such as `na.rm = TRUE` when using `mean()`. This can be done in two ways:

```{r}

# anonymous function
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))
#> [1] 3.0 5.5


```

Since map functions pass `...` along, there's a simpler form available:

```{r}

map_dbl(x, mean, na.rm = TRUE)
#> [1] 3.0 5.5

```

Arguments that come after the function you use in the call to `map()` are passed to the function as additional arguments after the data. So the data are the first argument, and then come you `...` arguments.

Also, extra argument inside an anonymous function are evaluated each time `f()` is executed, not just once as in the case of `map()`.

```{r}

plus <- function(x, y) x + y

x <- c(0, 0, 0, 0)
map_dbl(x, plus, runif(1))
#> [1] 0.0625 0.0625 0.0625 0.0625
map_dbl(x, ~ plus(.x, runif(1)))
#> [1] 0.903 0.132 0.629 0.945

```

**Argument names**. Use them. Note that named matching beats positional matching in function calls. Remember that `purrr` uses `.x` and `.f` in function calls.

**Varying another argument**. What if you want the first argument (the `.x`) to stay constant and you want to vary the function that is applied to it? There's no direct way.

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

map_dbl(trims, ~ mean(x, trim = .x))
#> [1] -0.3500  0.0434  0.0354  0.0502

# or without using an anonymous function:

map_dbl(trims, function(trim) mean(x, trim = trim))
#> [1] -0.3500  0.0434  0.0354  0.0502

```


## 9.3 Purrr style

Section 9.3 demonstrates how you can combine multiple simple functionals to solve a more complex problem and discusses how purrr style differs from other approaches.

Solving a realistic problemw with multiple purrr functions: fitting a model to each subgroup and extracting a coefficient of the model


```{r}

by_cyl <- split(mtcars, mtcars$cyl)

# fit a model extract the slope coefficient
by_cyl %>% 
  map(~ lm(mpg ~ wt, data = .x)) %>% 
  map(coef) %>% 
  map_dbl(2)
#>     4     6     8 
#> -5.65 -2.78 -2.19

```

Other approaches to do the same thing are more verbose, more complex.

Base R with the pipe:

```{r}

by_cyl %>% 
  lapply(function(data) lm(mpg ~ wt, data = data)) %>% 
  lapply(coef) %>% 
  vapply(function(x) x[[2]], double(1))
#>     4     6     8 
#> -5.65 -2.78 -2.19

```

Base R without the pipe:

```{r}

models <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))
vapply(models, function(x) coef(x)[[2]], double(1))
#>     4     6     8 
#> -5.65 -2.78 -2.19

```

a for loop:

```{r}

slopes <- double(length(by_cyl))
for (i in seq_along(by_cyl)) {
  model <- lm(mpg ~ wt, data = by_cyl[[i]])
  slopes[[i]] <- coef(model)[[2]]
}
slopes
#> [1] -5.65 -2.78 -2.19

```


## 9.4 Map variants

Section 9.4 teaches you about 18 (!!) important variants of purrr::map(). Fortunately, their orthogonal design makes them easy to learn, remember, and master. There are five ideas to remember:

1. Output same type as input with `modify()`.
2. Iterate over two inputs with `map2()`.
3. Iterate with an index using `imap()`.
4. Return nothing with `walk()`.
5. Iterate over any number of inputs with `pmap()`.


**Same type of output as input: modify()**

Working on a data frame, and you want to return a data frame.

```{r}

df <- data.frame(
  x = 1:3,
  y = 6:4
)

map(df, ~ .x * 2)
#> $x
#> [1] 2 4 6
#> 
#> $y
#> [1] 12 10  8

```

`map()` returns a list, but we want to input a data frame and return a data frame. We need `modify()`.

```{r}

modify(df, ~ .x * 2)
#>   x  y
#> 1 2 12
#> 2 4 10
#> 3 6  8

```

**Two inputs: map2() and friends**

Here is an example of weighted mean calculation.

```{r}

xs <- map(1:8, ~ runif(10))
xs[[1]][[1]] <- NA
ws <- map(1:8, ~ rpois(10, 5) + 1)

```

`map_dbl()` can handle unweighted means

```{r}

map_dbl(xs, mean)
#> [1]    NA 0.463 0.551 0.453 0.564 0.501 0.371 0.443

```

With `map2()`, we can run vectorized operations over both `.x` and `.y`. They are both varied in each call to `.f`:

```{r}

map2_dbl(xs, ws, weighted.mean)
#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464

```

Additional argument besides `.x` and `.y` go after `.f`:

```{r}

map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)
#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464

```

A simple implementation of map shows we are iterating over two vectors at once.

```{r}

simple_map2 <- function(x, y, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], y[[i]], ...)
  }
  out
}

```

Note that `map2()` recycles its inputs to make sure that they're the same length.

**No outputs: walk() and friends**

Some functions are called for their side effects, and no output in the console is desired. Examples include `ggsave()` or `write.csv()`.

```{r}

welcome <- function(x) {
  cat("Welcome ", x, "!\n", sep = "")
}
names <- c("Hadley", "Jenny")

# As well as generate the welcomes, it also shows 
# the return value of cat()
map(names, welcome)
#> Welcome Hadley!
#> Welcome Jenny!
#> [[1]]
#> NULL
#> 
#> [[2]]
#> NULL

```

We don't really need to return the empty list here. We need `walk()`, which results in ephemeral outputs and the inputs are returned invisibly.

```{r}

walk(names, welcome)
#> Welcome Hadley!
#> Welcome Jenny!

```

A useful walk variant is `walk2()` because a very common side-effect is saving something to disk, and when saving something to disk you always have a pair of values; the object and the path that you want to save it to.

```{r}

temp <- tempfile()
dir.create(temp)

cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)

dir(temp)
#> [1] "cyl-4.csv" "cyl-6.csv" "cyl-8.csv"

```


**Iterating over values and indices**

There are three basic ways to loop over a vector with a for loop:

1. Loop over the elements: `for (x in xs)`
2. Loop over the numeric indices: `for (x in seq_along(xs))`
3. Loop over the names: `for (nm in names(xs))`

Form 1 is analogous to the `map()` family. Forms 2 and 3 are analogous to `imap()`, which is like `map2()` in the sense that your `.f` gets called with two arguments, but here both are derived from the vector.

`imap(x, f)` is equivalent to `map2(x, names(x), f)` if x has names, and `map2(x, seq_along(x), f)` if it does not.

`imap()`is often useful for constructing labels:

```{r}

imap_chr(iris, ~ paste0("The first value of ", .y, " is ", .x[[1]]))
#>                             Sepal.Length 
#> "The first value of Sepal.Length is 5.1" 
#>                              Sepal.Width 
#>  "The first value of Sepal.Width is 3.5" 
#>                             Petal.Length 
#> "The first value of Petal.Length is 1.4" 
#>                              Petal.Width 
#>  "The first value of Petal.Width is 0.2" 
#>                                  Species 
#>   "The first value of Species is setosa"

```

If the vector is unnamed, the second argument will be the index:

```{r}

x <- map(1:6, ~ sample(1000, 10))
imap_chr(x, ~ paste0("The highest value of ", .y, " is ", max(.x)))
#> [1] "The highest value of 1 is 975" "The highest value of 2 is 915"
#> [3] "The highest value of 3 is 982" "The highest value of 4 is 955"
#> [5] "The highest value of 5 is 971" "The highest value of 6 is 696"

```

`imap()` is a useful helper if you want to work with the values in a vector along with their positions.

**Any number of inputs: pmap() and friends**

`pmap()` takes a list with any number of arguments, usually a list of equal length vectors. But you're still supplying one function.

The weighted mean application above with `map2()` could be done with `pmap()`:

```{r}

pmap_dbl(list(xs, ws), weighted.mean)
#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464

```

As before, the varying arguments come before `.f` (although now they must be wrapped in a list), and the constant arguments come afterwards.

```{r}

pmap_dbl(list(xs, ws), weighted.mean, na.rm = TRUE)
#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464

```

`pmap()` gives finer control over argument matching because you can name components of a list. See example of varying the `trim` argument to `x` using `pmap()`:

```{r}

trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

pmap_dbl(list(trim = trims), mean, x = x)
#> [1] -6.6740  0.0210  0.0235  0.0151

```

`pmap()` is convenient to call with a dataframe. So...it can take a list or a dataframe as an argument? With a data frame, the column names are the arguments to the function call?

```{r}

params <- tibble::tribble(
  ~ n, ~ min, ~ max,
   1L,     0,     1,
   2L,    10,   100,
   3L,   100,  1000
)

pmap(params, runif)
#> [[1]]
#> [1] 0.332
#> 
#> [[2]]
#> [1] 53.5 47.6
#> 
#> [[3]]
#> [1] 231 715 515

```


## 9.5 Reduce family

Section 9.5 introduces a new style of functional: `purrr::reduce()`. `reduce()` systematically reduces a vector to a single result by applying a function that takes two inputs. 

`reduce()` takes a vector of length n and produces a vector of length 1 by calling a function with a pair of values at a time: `reduce(1:4, f)` is equivalent to `f(f(f(1, 2), 3), 4)`.

The idea is to generalize a function that works with two inputs to work with any number of inputs.

```{r}

l <- map(1:4, ~ sample(1:10, 15, replace = T))
str(l)
#> List of 4
#>  $ : int [1:15] 7 1 8 8 3 8 2 4 7 10 ...
#>  $ : int [1:15] 3 1 10 2 5 2 9 8 5 4 ...
#>  $ : int [1:15] 6 10 9 5 6 7 8 6 10 8 ...
#>  $ : int [1:15] 9 8 6 4 4 5 2 9 9 6 ...

```

How to find the values that occur in every element? With base R:

```{r}

out <- l[[1]]
out <- intersect(out, l[[2]])
out <- intersect(out, l[[3]])
out <- intersect(out, l[[4]])
out
#> [1] 8 4

```

automate this with `reduce()`

```{r}

reduce(l, intersect)
#> [1] 8 4

```

We can also pass `union()` to see which elements appear in at least one entry:

```{r}

reduce(l, union)

```

See the underlying logic in `reduce()`

```{r}

simple_reduce <- function(x, f) {
  out <- x[[1]]
  for (i in seq(2, length(x))) {
    out <- f(out, x[[i]])
  }
  out
}

```

**Accumulate**. `accumulate()` returns all the intermediate results of `reduce()`.

```{r}

accumulate(l, intersect)
#> [[1]]
#>  [1]  7  1  8  8  3  8  2  4  7 10 10  3  7 10 10
#> 
#> [[2]]
#> [1]  1  8  3  2  4 10
#> 
#> [[3]]
#> [1]  8  4 10
#> 
#> [[4]]
#> [1] 8 4

```

```{r}

x <- c(4, 3, 10)
reduce(x, `+`)
#> [1] 17

accumulate(x, `+`)
#> [1]  4  7 17

```

Combining `map()` and `reduce()` is a powerful combination.

**Multiple Inputs** are possible with `reduce2()`.


## 9.6 Predicate functionals

Section 9.6 teaches you about predicates: functions that return a single TRUE or FALSE, and the family of functionals that use them to solve common problems.

purrr provides seven useful functions which come in three groups:

`some(.x, .p)` returns TRUE if any element matches;
`every(.x, .p)` returns TRUE if all elements match;
`none(.x, .p)` returns TRUE if no element matches.

These are similar to `any(map_lgl(.x, .p))`, `all(map_lgl(.x, .p))` and `all(map_lgl(.x, negate(.p)))` but they terminate early: `some()` returns TRUE when it sees the first TRUE, and `every()` and `none()` return FALSE when they see the first FALSE or TRUE respectively.

`detect(.x, .p)` returns the value of the first match; `detect_index(.x, .p)` returns the location of the first match.

`keep(.x, .p)` keeps all matching elements; `discard(.x, .p)` drops all matching elements.


```{r}

df <- data.frame(x = 1:3, y = c("a", "b", "c"))
detect(df, is.factor)
#> NULL
detect_index(df, is.factor)
#> [1] 0

str(keep(df, is.factor))
#> 'data.frame':    3 obs. of  0 variables
str(discard(df, is.factor))
#> 'data.frame':    3 obs. of  2 variables:
#>  $ x: int  1 2 3
#>  $ y: chr  "a" "b" "c"

```

`map()` and `modify()` come in variants that also take predicate functions, transforming only the lements of `.x` where `.p` is `TRUE`.



```{r}

df <- data.frame(
  num1 = c(0, 10, 20),
  num2 = c(5, 6, 7),
  chr1 = c("a", "b", "c"),
  stringsAsFactors = FALSE
)

str(map_if(df, is.numeric, mean))
#> List of 3
#>  $ num1: num 10
#>  $ num2: num 6
#>  $ chr1: chr [1:3] "a" "b" "c"
str(modify_if(df, is.numeric, mean))
#> 'data.frame':    3 obs. of  3 variables:
#>  $ num1: num  10 10 10
#>  $ num2: num  6 6 6
#>  $ chr1: chr  "a" "b" "c"
str(map(keep(df, is.numeric), mean))
#> List of 2
#>  $ num1: num 10
#>  $ num2: num 6

```


## 9.7 Base functionals

Section 9.7 reviews some functionals in base R that are not members of the map, reduce, or predicate families.

If you are working with two-dimensional and higher vectors, use `base::apply()`.


Arguments to `apply()`:

X, the matrix or array to summarise.

MARGIN, an integer vector giving the dimensions to summarise over, 1 = rows, 2 = columns, etc. (The argument name comes from thinking about the margins of a joint distribution.)

FUN, a summary function.

... other arguments passed on to FUN.

```{r}

a2d <- matrix(1:20, nrow = 5)
apply(a2d, 1, mean)
#> [1]  8.5  9.5 10.5 11.5 12.5
apply(a2d, 2, mean)
#> [1]  3  8 13 18

```

```{r}

a3d <- array(1:24, c(2, 3, 4))
apply(a3d, 1, mean)
#> [1] 12 13
apply(a3d, c(1, 2), mean)
#>      [,1] [,2] [,3]
#> [1,]   10   12   14
#> [2,]   11   13   15

```

Don't use `apply()` with a dataframe:

```{r}

# df <- data.frame(x = 1:3, y = c("a", "b", "c"))
# apply(df, 2, mean)
# #> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:
# #> returning NA
# #> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:
# #> returning NA
# #>  x  y 
# #> NA NA

```

**Mathematical concerns**.

```{r}

integrate(sin, 0, pi)
#> 2 with absolute error < 2.2e-14
str(uniroot(sin, pi * c(1 / 2, 3 / 2)))
#> List of 5
#>  $ root      : num 3.14
#>  $ f.root    : num 1.22e-16
#>  $ iter      : int 2
#>  $ init.it   : int NA
#>  $ estim.prec: num 6.1e-05
str(optimise(sin, c(0, 2 * pi)))
#> List of 2
#>  $ minimum  : num 4.71
#>  $ objective: num -1
str(optimise(sin, c(0, pi), maximum = TRUE))
#> List of 2
#>  $ maximum  : num 1.57
#>  $ objective: num 1

```
