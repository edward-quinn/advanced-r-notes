---
title: Advanced R - Chapter 3 Notes
format:
  html:
      toc: true
---

# 3 Vectors
-   atomic vectors. elements are all the same type.
-   lists (sometimes called generic vectors). elements can vary by type.

**Attributes** - named list of metadata
-   **dimension** turns vectors into matrices and arrays
-   **class** powers the S3 object system

## 3.2 Atomic vectors

Section 3.2 introduces you to the atomic vectors: logical, integer, double, and character. These are R’s simplest data structures.

Integer and double are inconsistently referred to as numeric. There are also two rare types: complex and raw.

Each of the four primary types has a special syntax to create an individual value (a scalar).

```{r}

# Logicals
TRUE
T
FALSE
F

# Doubles
0.1234
1.234e-1
## special values unique to double
Inf
-Inf
NaN

# Integers
## can be written like a double, but must use L, which represents a long integer in C
1234L
1e4L

# Strings
## require single or double quotes. special characters escaped with \
"hi there"

```

combine vectors with `c()`

```{r}

lgl_var <- c(TRUE, FALSE)
int_var <- c(1L, 6L, 10L)
dbl_var <- c(1, 2.5, 4.5)
chr_var <- c("these are", "some strings")

c(c(1, 2), c(3, 4))
#> [1] 1 2 3 4

```


```{r}

typeof(lgl_var)
#> [1] "logical"
typeof(int_var)
#> [1] "integer"
typeof(dbl_var)
#> [1] "double"
typeof(chr_var)
#> [1] "character"

```

missing values are represented with a sentinal value `NA`, which are infectious unless some identity holds for all possible inputs

```{r}

NA > 5
#> [1] NA
10 * NA
#> [1] NA
!NA
#> [1] NA

NA ^ 0
#> [1] 1
NA | TRUE
#> [1] TRUE
NA & FALSE
#> [1] FALSE

```

```{r}

# which values are missing? use is.na()
x <- c(NA, 5, NA, 10)
x == NA
#> [1] NA NA NA NA

is.na(x)
#> [1]  TRUE FALSE  TRUE FALSE

# There are four missing values, one for each atomic vector type

```

vectors always have one type and will be coerced in a standard order to a single type if you combine multiple vectors of different types: character → double → integer → logical.

```{r}

str(c("a", 1))
#>  chr [1:2] "a" "1"

```

mathematical functions coerce logicals into 0 and 1

```{r}

x <- c(FALSE, FALSE, TRUE)
as.numeric(x)
#> [1] 0 0 1

# Total number of TRUEs
sum(x)
#> [1] 1

# Proportion that are TRUE
mean(x)
#> [1] 0.333

```

Force coercion with the corresponding `as.*` function

```{r}

as.integer(c("1", "1.5", "a"))
#> Warning: NAs introduced by coercion
#> [1]  1  1 NA

```

### 3.2.5 Exercises

```{r}

c(1, FALSE)
c("a", 1)
c(TRUE, 1L)

```

## 3.3 Attributes

Section 3.3 takes a small detour to discuss attributes, R’s flexible metadata specification. The most important attributes are names, dimensions, and class.

How does the `dim` attribute make matrices and arrays?

Attributes can be though of as name-value pairs. Retrieved with `attr()`, en masse with `attributes()`, and set en masse with `structure()`.

```{r}
a <- 1:3
attr(a, "x") <- "abcdef"
attr(a, "x")
#> [1] "abcdef"

attr(a, "y") <- 4:6
str(attributes(a))
#> List of 2
#>  $ x: chr "abcdef"
#>  $ y: int [1:3] 4 5 6

# Or equivalently
a <- structure(
  1:3, 
  x = "abcdef",
  y = 4:6
)
str(attributes(a))
#> List of 2
#>  $ x: chr "abcdef"
#>  $ y: int [1:3] 4 5 6

```

Attributes are generally ephemeral.

```{r}

attributes(a[1])
#> NULL
attributes(sum(a))
#> NULL
```

There are two exceptions:
-   **names**, a character vector giving each element a name
-   **dim**, short for dimensions, an integer vector, used to turn vectors into matrices or arrays.

Name a vector in three ways:

```{r}

# When creating it: 
x <- c(a = 1, b = 2, c = 3)

# By assigning a character vector to names()
x <- 1:3
names(x) <- c("a", "b", "c")

# Inline, with setNames():
x <- setNames(1:3, c("a", "b", "c"))

```


Adding a `dim` attribute allows a vector to behave like a 2-d matrix or a multidimensional array.

```{r}

# Two scalar arguments specify row and column sizes
x <- matrix(1:6, nrow = 2, ncol = 3)
x
#>      [,1] [,2] [,3]
#> [1,]    1    3    5
#> [2,]    2    4    6

# One vector argument to describe all dimensions
y <- array(1:12, c(2, 3, 2))
y
#> , , 1
#> 
#>      [,1] [,2] [,3]
#> [1,]    1    3    5
#> [2,]    2    4    6
#> 
#> , , 2
#> 
#>      [,1] [,2] [,3]
#> [1,]    7    9   11
#> [2,]    8   10   12

# You can also modify an object in place by setting dim()
z <- 1:6
dim(z) <- c(3, 2)
z
#>      [,1] [,2]
#> [1,]    1    4
#> [2,]    2    5
#> [3,]    3    6

```


```{r}

str(1:3)                   # 1d vector
#>  int [1:3] 1 2 3
str(matrix(1:3, ncol = 1)) # column vector
#>  int [1:3, 1] 1 2 3
str(matrix(1:3, nrow = 1)) # row vector
#>  int [1, 1:3] 1 2 3
str(array(1:3, 3))         # "array" vector
#>  int [1:3(1d)] 1 2 3


```

### 3.3.4 Exercises

```{r}
# What are these and how do they differ from 1:5?
x1 <- array(1:5, c(1, 1, 5))
x2 <- array(1:5, c(1, 5, 1))
x3 <- array(1:5, c(5, 1, 1))

```

## 3.4 S3 atomic vectors

Section 3.4 discusses the important vector types that are built by combining atomic vectors with special attributes. These include factors, dates, date-times, and durations.

An important vector attribute is `class`. Having a `class` attribute turns an object into an S3 object, which means will behave differently than a normal vector when passed to a generic function.


Note that factors are built on Integer vectors, and POSIXct and Date vectors are built on Double vectors.

Factors are vectors with only pre-defined values, defined by the attributes `class` and `levels`.

```{r}

x <- factor(c("a", "b", "b", "a"))
x
#> [1] a b b a
#> Levels: a b

typeof(x)
#> [1] "integer"
attributes(x)
#> $levels
#> [1] "a" "b"
#> 
#> $class
#> [1] "factor"

```

Factors will give counts of unobserved levels in functions like `table()`, unlike character vectors.

```{r}

sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

table(sex_char)
#> sex_char
#> m 
#> 3
table(sex_factor)
#> sex_factor
#> m f 
#> 3 0


```

**Ordered** factors for when order of the levels is meaningful

```{r}
grade <- ordered(c("b", "b", "a", "c"), levels = c("c", "b", "a"))
grade
#> [1] b b a c
#> Levels: c < b < a

```

Factors are coerced in different ways by different functions - sometimes to strings, and sometimes the underlying integer values are used.

**Dates** are built on top of double vectors and have `class` "Date" and no other attributes.

```{r}

today <- Sys.Date()

typeof(today)
#> [1] "double"
attributes(today)
#> $class
#> [1] "Date"

```

You can see the value of the double by stripping the class

```{r}
date <- as.Date("1970-02-01")
unclass(date)
#> [1] 31

```

**Date-Times** in base R are built on top of Double vectors. One type is POSIXct.

```{r}

now_ct <- as.POSIXct("2018-08-01 22:00", tz = "UTC")
now_ct
#> [1] "2018-08-01 22:00:00 UTC"

typeof(now_ct)
#> [1] "double"
attributes(now_ct)
#> $class
#> [1] "POSIXct" "POSIXt" 
#> 
#> $tzone
#> [1] "UTC"

```

time zones change printing, not the instant of time represented

```{r}

structure(now_ct, tzone = "Asia/Tokyo")
#> [1] "2018-08-02 07:00:00 JST"
structure(now_ct, tzone = "America/New_York")
#> [1] "2018-08-01 18:00:00 EDT"
structure(now_ct, tzone = "Australia/Lord_Howe")
#> [1] "2018-08-02 08:30:00 +1030"
structure(now_ct, tzone = "Europe/Paris")
#> [1] "2018-08-02 CEST"

```


**Durations** are stored in difftimes, which are built on top of doubles and have a `units` attribute that determines how differences should be interpreted.

```{r}
one_week_1 <- as.difftime(1, units = "weeks")
one_week_1
#> Time difference of 1 weeks

typeof(one_week_1)
#> [1] "double"
attributes(one_week_1)
#> $class
#> [1] "difftime"
#> 
#> $units
#> [1] "weeks"

one_week_2 <- as.difftime(7, units = "days")
one_week_2
#> Time difference of 7 days

typeof(one_week_2)
#> [1] "double"
attributes(one_week_2)
#> $class
#> [1] "difftime"
#> 
#> $units
#> [1] "days"

```

### 3.4.5 Exercises

What sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?

```{r}

table(letters)

typeof(table(letters))

attributes((table(letters)))


```


```{r}

# what happens to a factor when you modify levels?

f1 <- factor(letters)
levels(f1) <- rev(levels(f1))

# How do these differ from f1?

f2 <- rev(factor(letters))

f3 <- factor(letters, levels = rev(letters))

```



## 3.5 Lists

Section 3.5 dives into lists. Lists are very similar to atomic vectors, but have one key difference: an element of a list can be any data type, including another list. This makes them suitable for representing hierarchical data.


Construct a list with `list()`:

```{r}

l1 <- list(
  1:3, 
  "a", 
  c(TRUE, FALSE, TRUE), 
  c(2.3, 5.9)
)

typeof(l1)
#> [1] "list"

str(l1)
#> List of 4
#>  $ : int [1:3] 1 2 3
#>  $ : chr "a"
#>  $ : logi [1:3] TRUE FALSE TRUE
#>  $ : num [1:2] 2.3 5.9

```

Elements of a list are references and therefore do not take up as much space as you might imagine:

```{r}

lobstr::obj_size(mtcars)
#> 7.21 kB

l2 <- list(mtcars, mtcars, mtcars, mtcars)
lobstr::obj_size(l2)
#> 7.29 kB

```

Lists are sometimes called recursive vectors because they can contain other lists.

```{r}

l3 <- list(list(list(1)))
str(l3)
#> List of 1
#>  $ :List of 1
#>   ..$ :List of 1
#>   .. ..$ : num 1

```

`c()` coerces the vectors to a list, and then flattens everything into one list

```{r}

l4 <- list(list(1, 2), c(3, 4))
l5 <- c(list(1, 2), c(3, 4))
str(l4)
#> List of 2
#>  $ :List of 2
#>   ..$ : num 1
#>   ..$ : num 2
#>  $ : num [1:2] 3 4
str(l5)
#> List of 4
#>  $ : num 1
#>  $ : num 2
#>  $ : num 3
#>  $ : num 4

```

**Testing and coercion** - test with `is.list()` and coerce with `as.list()`.

```{r}

list(1:3)
#> [[1]]
#> [1] 1 2 3
as.list(1:3)
#> [[1]]
#> [1] 1
#> 
#> [[2]]
#> [1] 2
#> 
#> [[3]]
#> [1] 3

```


**Matrices and arrays**

The dimension attribute can be used to create list-matrices or list-arrays:

```{r}

l <- list(1:3, "a", TRUE, 1.0)
dim(l) <- c(2, 2)
l
#>      [,1]      [,2]
#> [1,] integer,3 TRUE
#> [2,] "a"       1

l[[1, 1]]
#> [1] 1 2 3

```

## 3.6 Data frames and tibbles

Section 3.6 teaches you about data frames and tibbles, which are used to represent rectangular data. They combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.

Data frames and tibbles are built on top of lists.

A data frame is a named list of vectors with attributes for (column) names, row.names, and its class, "data.frame":

```{r}

df1 <- data.frame(x = 1:3, y = letters[1:3])
typeof(df1)
#> [1] "list"

attributes(df1)
#> $names
#> [1] "x" "y"
#> 
#> $class
#> [1] "data.frame"
#> 
#> $row.names
#> [1] 1 2 3

```

A data frame has rownames() and colnames(). The names() of a data frame are the column names.

A data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns.

Tibbles are lazy and the `class` vector is longer, and includes `tbl_df`.

```{r}

library(tibble)

df2 <- tibble(x = 1:3, y = letters[1:3])
typeof(df2)
#> [1] "list"

attributes(df2)
#> $class
#> [1] "tbl_df"     "tbl"        "data.frame"
#> 
#> $row.names
#> [1] 1 2 3
#> 
#> $names
#> [1] "x" "y"


```

Create a data frame with name-vector pairs:

```{r}

df <- data.frame(
  x = 1:3, 
  y = c("a", "b", "c")
)
str(df)
#> 'data.frame':    3 obs. of  2 variables:
#>  $ x: int  1 2 3
#>  $ y: chr  "a" "b" "c"

```

Create a tibble in the same way.

```{r}

df2 <- tibble(
  x = 1:3, 
  y = c("a", "b", "c")
)
str(df2)
#> tibble [3 × 2] (S3: tbl_df/tbl/data.frame)
#>  $ x: int [1:3] 1 2 3
#>  $ y: chr [1:3] "a" "b" "c"

```

Tibbles don't change non-syntactic names. Data frames do.
```{r}

names(data.frame(`1` = 1))
#> [1] "X1"

names(tibble(`1` = 1))
#> [1] "1"

```

Tibbles will only recycle vectors of length 1

```{r}
data.frame(x = 1:4, y = 1:2)
#>   x y
#> 1 1 1
#> 2 2 2
#> 3 3 1
#> 4 4 2

#data.frame(x = 1:4, y = 1:3)
#> Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of
#> rows: 4, 3

tibble(x = 1:4, y = 1)
#> # A tibble: 4 × 2
#>       x     y
#>   <int> <dbl>
#> 1     1     1
#> 2     2     1
#> 3     3     1
#> 4     4     1


# tibble(x = 1:4, y = 1:2)
#> Error in tibble(x = 1:4, y = 1:2): Tibble columns must have compatible sizes.
#> • Size 4: Existing data.
#> • Size 2: Column `y`.
#> ℹ Only values of size one are recycled.


```

A tibble can refer to variables created during construction. Data frames cannot.

```{r}

tibble(
  x = 1:3,
  y = x * 2
)
#> # A tibble: 3 × 2
#>       x     y
#>   <int> <dbl>
#> 1     1     2
#> 2     2     4
#> 3     3     6

```


**Data frames allow row names.** This is a character vector with unique values.

```{r}

df3 <- data.frame(
  age = c(35, 27, 18),
  hair = c("blond", "brown", "black"),
  row.names = c("Bob", "Susan", "Sam")
)
df3
#>       age  hair
#> Bob    35 blond
#> Susan  27 brown
#> Sam    18 black

```

```{r}

rownames(df3)
#> [1] "Bob"   "Susan" "Sam"

df3["Bob", ]
#>     age  hair
#> Bob  35 blond

```

Tibbles do not support rownames, but can easily convert them to a column in the tibble:

```{r}

as_tibble(df3, rownames = "name")
#> # A tibble: 3 × 3
#>   name    age hair 
#>   <chr> <dbl> <chr>
#> 1 Bob      35 blond
#> 2 Susan    27 brown
#> 3 Sam      18 black

```

**Subsetting** differs by data frames and tibbles. Tibbles always return a tibble when subsetting, and no partial matching is allowed with column names.

```{r}

df1 <- data.frame(xyz = "a")
df2 <- tibble(xyz = "a")

str(df1$x)
#>  chr "a"
str(df2$x)
#> Warning: Unknown or uninitialised column: `x`.
#>  NULL

```

Extract single columns with `df[["col"]]`. 

```{r}
is.data.frame(df1)
#> [1] TRUE
is.data.frame(df2) # this is a tibble and it passes this test.
#> [1] TRUE

```

If you want to distinguish:

```{r}

is_tibble(df1)
#> [1] FALSE
is_tibble(df2)
#> [1] TRUE

```

**List Columns** - since a data frame or a tibble is a list, it can contain other lists.

```{r}
# extra work is required to add a list to a data frame - either after creation or using I()

df <- data.frame(x = 1:3)
df$y <- list(1:2, 1:3, 1:4)

data.frame(
  x = 1:3, 
  y = I(list(1:2, 1:3, 1:4))
)
#>   x          y
#> 1 1       1, 2
#> 2 2    1, 2, 3
#> 3 3 1, 2, 3, 4

```

List columns are easier to use in a tibble.

```{r}

tibble(
  x = 1:3, 
  y = list(1:2, 1:3, 1:4)
)
#> # A tibble: 3 × 2
#>       x y        
#>   <int> <list>   
#> 1     1 <int [2]>
#> 2     2 <int [3]>
#> 3     3 <int [4]>

```

**Matrix and data frame columns** are possible, but not advised. The NROW() og the matrix must match the data frame number of rows.

```{r}

dfm <- data.frame(
  x = 1:3 * 10
)
dfm$y <- matrix(1:9, nrow = 3)
dfm$z <- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)

str(dfm)
#> 'data.frame':    3 obs. of  3 variables:
#>  $ x: num  10 20 30
#>  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9
#>  $ z:'data.frame':   3 obs. of  2 variables:
#>   ..$ a: int  3 2 1
#>   ..$ b: chr  "a" "b" "c"

```



## 3.7 NULL

Always length zero, and cannot have attributes. A unique type.

```{r}
typeof(NULL)
#> [1] "NULL"

length(NULL)
#> [1] 0

x <- NULL
# attr(x, "y") <- 1
#> Error in attr(x, "y") <- 1: attempt to set an attribute on NULL

```

`NULL` represents an absent vector, whereas `NA` represents an absent element. `NULL` can be useful in default function arguments.

