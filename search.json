[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Notebook",
    "section": "",
    "text": "Wickham (2019) Book Notes\nWickham’s book can be found here\n\nChapter 1 Notes\nChapter 2 Notes\nChapter 3 Notes\nChapter 4 Notes\nChapter 5 Notes\nChapter 6 Notes\n\n\n\n\n\n\nReferences\n\nWickham, Hadley. 2019. Advanced R. 2nd Edition. New York: Chapman; Hall/CRC."
  },
  {
    "objectID": "chapter_05_notes.html",
    "href": "chapter_05_notes.html",
    "title": "Advanced R - Chapter 5 Notes",
    "section": "",
    "text": "Choices. Run different code depending on input.\nLoops. Repeatedly run code, typically with changing options.\n\n\n\nSection 5.2 dives into the details of if, then discusses the close relatives ifelse() and switch().\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\n\ngrade &lt;- function(x) {\n  if (x &gt; 90) {\n    \"A\"\n  } else if (x &gt; 80) {\n    \"B\"\n  } else if (x &gt; 50) {\n    \"C\"\n  } else {\n    \"F\"\n  }\n}\n\n\nx1 &lt;- if (TRUE) 1 else 2\nx2 &lt;- if (FALSE) 1 else 2\n\nc(x1, x2)\n\n[1] 1 2\n\n#&gt; [1] 1 2\n\n\ngreet &lt;- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n\n[1] \"Hi Maria\"\n\n#&gt; [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n\n[1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\n#&gt; [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\nThe condition should evaluate to a single TRUE or FALSE\n\n# if (\"x\") 1\n# #&gt; Error in if (\"x\") 1: argument is not interpretable as logical\n# if (logical()) 1\n# #&gt; Error in if (logical()) 1: argument is of length zero\n# if (NA) 1\n# #&gt; Error in if (NA) 1: missing value where TRUE/FALSE needed\n# if (c(TRUE, FALSE)) 1\n# #&gt; Error in if (c(TRUE, FALSE)) 1: the condition has length &gt; 1\n\nVectorized if\nWhat if you have more than one TRUE or FALSE value?\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\n#&gt;  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n#&gt;  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\ndplyr::case_when is another vectorized if\n\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n\n [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\n#&gt;  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\nif() statements can be made more compact with switch()\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    # The last component of a switch() should always throw \n    # an error, otherwise unmatched inputs will invisibly return NULL\n    stop(\"Invalid `x` value\") \n  )\n}\n\nIf multiple inputs have the same output, you can leave the RHS of = empty until the last input with the same output\n\nlegs &lt;- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n\n[1] 4\n\n#&gt; [1] 4\nlegs(\"dog\")\n\n[1] 4\n\n#&gt; [1] 4\n\n\n\n\nSection 5.3 starts off by reminding you of the basic structure of the for loop in R, discusses some common pitfalls, and then talks about the related while and repeat statements.\nBasic structure: for (item in vector) perform_action\n\nfor (i in 1:3) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n\nN.B.: for assigns the item to the current environment, overwriting any existing variable with the same name:\n\ni &lt;- 100\nfor (i in 1:3) {}\ni\n\n[1] 3\n\n#&gt; [1] 3\n\nYou can use next to exit the current iteration and break to exit the entire for loop.\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\nCommon Pitfalls when using for loops\n\nIf you are generating data, pre-allocate the output container. This improves speed.\n\n\nmeans &lt;- c(1, 50, 20)\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n\nBeware of iterating over 1:length(x), which will fail in unhelpful ways if x has length 0.\n\n\n# means &lt;- c()\n# out &lt;- vector(\"list\", length(means))\n# for (i in 1:length(means)) {\n#   out[[i]] &lt;- rnorm(10, means[[i]])\n# }\n# #&gt; Error in rnorm(10, means[[i]]): invalid arguments\n\nUse seq_along() instead.\n\nseq_along(means)\n\n[1] 1 2 3\n\n#&gt; integer(0)\n\nout &lt;- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n\nCall [[ yourself when iterating over S3 vectors, as loops typically strip the attributes\n\n\nxs &lt;- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n\n[1] 18262\n[1] 14610\n\n#&gt; [1] 18262\n#&gt; [1] 14610\n\nHere’s the fix:\n\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n\n[1] \"2020-01-01\"\n[1] \"2010-01-01\"\n\n#&gt; [1] \"2020-01-01\"\n#&gt; [1] \"2010-01-01\""
  },
  {
    "objectID": "chapter_05_notes.html#choices",
    "href": "chapter_05_notes.html#choices",
    "title": "Advanced R - Chapter 5 Notes",
    "section": "",
    "text": "Section 5.2 dives into the details of if, then discusses the close relatives ifelse() and switch().\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\n\ngrade &lt;- function(x) {\n  if (x &gt; 90) {\n    \"A\"\n  } else if (x &gt; 80) {\n    \"B\"\n  } else if (x &gt; 50) {\n    \"C\"\n  } else {\n    \"F\"\n  }\n}\n\n\nx1 &lt;- if (TRUE) 1 else 2\nx2 &lt;- if (FALSE) 1 else 2\n\nc(x1, x2)\n\n[1] 1 2\n\n#&gt; [1] 1 2\n\n\ngreet &lt;- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n\n[1] \"Hi Maria\"\n\n#&gt; [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n\n[1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\n#&gt; [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\nThe condition should evaluate to a single TRUE or FALSE\n\n# if (\"x\") 1\n# #&gt; Error in if (\"x\") 1: argument is not interpretable as logical\n# if (logical()) 1\n# #&gt; Error in if (logical()) 1: argument is of length zero\n# if (NA) 1\n# #&gt; Error in if (NA) 1: missing value where TRUE/FALSE needed\n# if (c(TRUE, FALSE)) 1\n# #&gt; Error in if (c(TRUE, FALSE)) 1: the condition has length &gt; 1\n\nVectorized if\nWhat if you have more than one TRUE or FALSE value?\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\n#&gt;  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n#&gt;  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\ndplyr::case_when is another vectorized if\n\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n\n [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\n#&gt;  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\nif() statements can be made more compact with switch()\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    # The last component of a switch() should always throw \n    # an error, otherwise unmatched inputs will invisibly return NULL\n    stop(\"Invalid `x` value\") \n  )\n}\n\nIf multiple inputs have the same output, you can leave the RHS of = empty until the last input with the same output\n\nlegs &lt;- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n\n[1] 4\n\n#&gt; [1] 4\nlegs(\"dog\")\n\n[1] 4\n\n#&gt; [1] 4"
  },
  {
    "objectID": "chapter_05_notes.html#loops",
    "href": "chapter_05_notes.html#loops",
    "title": "Advanced R - Chapter 5 Notes",
    "section": "",
    "text": "Section 5.3 starts off by reminding you of the basic structure of the for loop in R, discusses some common pitfalls, and then talks about the related while and repeat statements.\nBasic structure: for (item in vector) perform_action\n\nfor (i in 1:3) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n\nN.B.: for assigns the item to the current environment, overwriting any existing variable with the same name:\n\ni &lt;- 100\nfor (i in 1:3) {}\ni\n\n[1] 3\n\n#&gt; [1] 3\n\nYou can use next to exit the current iteration and break to exit the entire for loop.\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\nCommon Pitfalls when using for loops\n\nIf you are generating data, pre-allocate the output container. This improves speed.\n\n\nmeans &lt;- c(1, 50, 20)\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n\nBeware of iterating over 1:length(x), which will fail in unhelpful ways if x has length 0.\n\n\n# means &lt;- c()\n# out &lt;- vector(\"list\", length(means))\n# for (i in 1:length(means)) {\n#   out[[i]] &lt;- rnorm(10, means[[i]])\n# }\n# #&gt; Error in rnorm(10, means[[i]]): invalid arguments\n\nUse seq_along() instead.\n\nseq_along(means)\n\n[1] 1 2 3\n\n#&gt; integer(0)\n\nout &lt;- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n\nCall [[ yourself when iterating over S3 vectors, as loops typically strip the attributes\n\n\nxs &lt;- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n\n[1] 18262\n[1] 14610\n\n#&gt; [1] 18262\n#&gt; [1] 14610\n\nHere’s the fix:\n\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n\n[1] \"2020-01-01\"\n[1] \"2010-01-01\"\n\n#&gt; [1] \"2020-01-01\"\n#&gt; [1] \"2010-01-01\""
  },
  {
    "objectID": "chapter_03_notes.html",
    "href": "chapter_03_notes.html",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "atomic vectors. elements are all the same type.\nlists (sometimes called generic vectors). elements can vary by type.\n\nAttributes - named list of metadata - dimension turns vectors into matrices and arrays - class powers the S3 object system\n\n\nSection 3.2 introduces you to the atomic vectors: logical, integer, double, and character. These are R’s simplest data structures.\nInteger and double are inconsistently referred to as numeric. There are also two rare types: complex and raw.\nEach of the four primary types has a special syntax to create an individual value (a scalar).\n\n# Logicals\nTRUE\n\n[1] TRUE\n\nT\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nF\n\n[1] FALSE\n\n# Doubles\n0.1234\n\n[1] 0.1234\n\n1.234e-1\n\n[1] 0.1234\n\n## special values unique to double\nInf\n\n[1] Inf\n\n-Inf\n\n[1] -Inf\n\nNaN\n\n[1] NaN\n\n# Integers\n## can be written like a double, but must use L, which represents a long integer in C\n1234L\n\n[1] 1234\n\n1e4L\n\n[1] 10000\n\n# Strings\n## require single or double quotes. special characters escaped with \\\n\"hi there\"\n\n[1] \"hi there\"\n\n\ncombine vectors with c()\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\nc(c(1, 2), c(3, 4))\n\n[1] 1 2 3 4\n\n#&gt; [1] 1 2 3 4\n\n\ntypeof(lgl_var)\n\n[1] \"logical\"\n\n#&gt; [1] \"logical\"\ntypeof(int_var)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\ntypeof(chr_var)\n\n[1] \"character\"\n\n#&gt; [1] \"character\"\n\nmissing values are represented with a sentinal value NA, which are infectious unless some identity holds for all possible inputs\n\nNA &gt; 5\n\n[1] NA\n\n#&gt; [1] NA\n10 * NA\n\n[1] NA\n\n#&gt; [1] NA\n!NA\n\n[1] NA\n\n#&gt; [1] NA\n\nNA ^ 0\n\n[1] 1\n\n#&gt; [1] 1\nNA | TRUE\n\n[1] TRUE\n\n#&gt; [1] TRUE\nNA & FALSE\n\n[1] FALSE\n\n#&gt; [1] FALSE\n\n\n# which values are missing? use is.na()\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n\n[1] NA NA NA NA\n\n#&gt; [1] NA NA NA NA\n\nis.na(x)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n# There are four missing values, one for each atomic vector type\n\nvectors always have one type and will be coerced in a standard order to a single type if you combine multiple vectors of different types: character → double → integer → logical.\n\nstr(c(\"a\", 1))\n\n chr [1:2] \"a\" \"1\"\n\n#&gt;  chr [1:2] \"a\" \"1\"\n\nmathematical functions coerce logicals into 0 and 1\n\nx &lt;- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n\n[1] 0 0 1\n\n#&gt; [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n\n[1] 1\n\n#&gt; [1] 1\n\n# Proportion that are TRUE\nmean(x)\n\n[1] 0.3333333\n\n#&gt; [1] 0.333\n\nForce coercion with the corresponding as.* function\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  1 NA\n\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\n\nc(1, FALSE)\n\n[1] 1 0\n\nc(\"a\", 1)\n\n[1] \"a\" \"1\"\n\nc(TRUE, 1L)\n\n[1] 1 1\n\n\n\n\n\n\nSection 3.3 takes a small detour to discuss attributes, R’s flexible metadata specification. The most important attributes are names, dimensions, and class.\nHow does the dim attribute make matrices and arrays?\nAttributes can be though of as name-value pairs. Retrieved with attr(), en masse with attributes(), and set en masse with structure().\n\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n\n[1] \"abcdef\"\n\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na &lt;- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\nAttributes are generally ephemeral.\n\nattributes(a[1])\n\nNULL\n\n#&gt; NULL\nattributes(sum(a))\n\nNULL\n\n#&gt; NULL\n\nThere are two exceptions: - names, a character vector giving each element a name - dim, short for dimensions, an integer vector, used to turn vectors into matrices or arrays.\nName a vector in three ways:\n\n# When creating it: \nx &lt;- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\nAdding a dim attribute allows a vector to behave like a 2-d matrix or a multidimensional array.\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\n\nstr(1:3)                   # 1d vector\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n\n int [1:3, 1] 1 2 3\n\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n\n int [1, 1:3] 1 2 3\n\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n\n int [1:3(1d)] 1 2 3\n\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\n\n# What are these and how do they differ from 1:5?\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))\n\n\n\n\n\nSection 3.4 discusses the important vector types that are built by combining atomic vectors with special attributes. These include factors, dates, date-times, and durations.\nAn important vector attribute is class. Having a class attribute turns an object into an S3 object, which means will behave differently than a normal vector when passed to a generic function.\nNote that factors are built on Integer vectors, and POSIXct and Date vectors are built on Double vectors.\nFactors are vectors with only pre-defined values, defined by the attributes class and levels.\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n[1] a b b a\nLevels: a b\n\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\nattributes(x)\n\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\nFactors will give counts of unobserved levels in functions like table(), unlike character vectors.\n\nsex_char &lt;- c(\"m\", \"m\", \"m\")\nsex_factor &lt;- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\n#&gt; sex_char\n#&gt; m \n#&gt; 3\ntable(sex_factor)\n\nsex_factor\nm f \n3 0 \n\n#&gt; sex_factor\n#&gt; m f \n#&gt; 3 0\n\nOrdered factors for when order of the levels is meaningful\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n\n[1] b b a c\nLevels: c &lt; b &lt; a\n\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nFactors are coerced in different ways by different functions - sometimes to strings, and sometimes the underlying integer values are used.\nDates are built on top of double vectors and have class “Date” and no other attributes.\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(today)\n\n$class\n[1] \"Date\"\n\n#&gt; $class\n#&gt; [1] \"Date\"\n\nYou can see the value of the double by stripping the class\n\ndate &lt;- as.Date(\"1970-02-01\")\nunclass(date)\n\n[1] 31\n\n#&gt; [1] 31\n\nDate-Times in base R are built on top of Double vectors. One type is POSIXct.\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n\n[1] \"2018-08-01 22:00:00 UTC\"\n\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(now_ct)\n\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntime zones change printing, not the instant of time represented\n\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n\n[1] \"2018-08-02 07:00:00 JST\"\n\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n\n[1] \"2018-08-01 18:00:00 EDT\"\n\n#&gt; [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n\n[1] \"2018-08-02 08:30:00 +1030\"\n\n#&gt; [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n\n[1] \"2018-08-02 CEST\"\n\n#&gt; [1] \"2018-08-02 CEST\"\n\nDurations are stored in difftimes, which are built on top of doubles and have a units attribute that determines how differences should be interpreted.\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n\nTime difference of 1 weeks\n\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_1)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"weeks\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n\nTime difference of 7 days\n\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_2)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"days\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\ntable(letters)\n\nletters\na b c d e f g h i j k l m n o p q r s t u v w x y z \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n\ntypeof(table(letters))\n\n[1] \"integer\"\n\nattributes((table(letters)))\n\n$dim\n[1] 26\n\n$dimnames\n$dimnames$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n$class\n[1] \"table\"\n\n\n\n# what happens to a factor when you modify levels?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\n# How do these differ from f1?\n\nf2 &lt;- rev(factor(letters))\n\nf3 &lt;- factor(letters, levels = rev(letters))\n\n\n\n\n\nSection 3.5 dives into lists. Lists are very similar to atomic vectors, but have one key difference: an element of a list can be any data type, including another list. This makes them suitable for representing hierarchical data.\nConstruct a list with list():\n\nl1 &lt;- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nstr(l1)\n\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\nElements of a list are references and therefore do not take up as much space as you might imagine:\n\nlobstr::obj_size(mtcars)\n\n7.21 kB\n\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n\n7.29 kB\n\n#&gt; 7.29 kB\n\nLists are sometimes called recursive vectors because they can contain other lists.\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\nc() coerces the vectors to a list, and then flattens everything into one list\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\nTesting and coercion - test with is.list() and coerce with as.list().\n\nlist(1:3)\n\n[[1]]\n[1] 1 2 3\n\n#&gt; [[1]]\n#&gt; [1] 1 2 3\nas.list(1:3)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\nMatrices and arrays\nThe dimension attribute can be used to create list-matrices or list-arrays:\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n\n     [,1]      [,2]\n[1,] integer,3 TRUE\n[2,] \"a\"       1   \n\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\n\n\n\nSection 3.6 teaches you about data frames and tibbles, which are used to represent rectangular data. They combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.\nData frames and tibbles are built on top of lists.\nA data frame is a named list of vectors with attributes for (column) names, row.names, and its class, “data.frame”:\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df1)\n\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nA data frame has rownames() and colnames(). The names() of a data frame are the column names.\nA data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns.\nTibbles are lazy and the class vector is longer, and includes tbl_df.\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df2)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\nCreate a data frame with name-vector pairs:\n\ndf &lt;- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n\n'data.frame':   3 obs. of  2 variables:\n $ x: int  1 2 3\n $ y: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\nCreate a tibble in the same way.\n\ndf2 &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n\ntibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\nTibbles don’t change non-syntactic names. Data frames do.\n\nnames(data.frame(`1` = 1))\n\n[1] \"X1\"\n\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n\n[1] \"1\"\n\n#&gt; [1] \"1\"\n\nTibbles will only recycle vectors of length 1\n\ndata.frame(x = 1:4, y = 1:2)\n\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\n\n#data.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of\n#&gt; rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n\n# A tibble: 4 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     1\n2     2     1\n3     3     1\n4     4     1\n\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\n\n\n# tibble(x = 1:4, y = 1:2)\n#&gt; Error in tibble(x = 1:4, y = 1:2): Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\nA tibble can refer to variables created during construction. Data frames cannot.\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n\n# A tibble: 3 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     2\n2     2     4\n3     3     6\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\nData frames allow row names. This is a character vector with unique values.\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\n\nrownames(df3)\n\n[1] \"Bob\"   \"Susan\" \"Sam\"  \n\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n\n    age  hair\nBob  35 blond\n\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\nTibbles do not support rownames, but can easily convert them to a column in the tibble:\n\nas_tibble(df3, rownames = \"name\")\n\n# A tibble: 3 × 3\n  name    age hair \n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n\n#&gt; # A tibble: 3 × 3\n#&gt;   name    age hair \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Bob      35 blond\n#&gt; 2 Susan    27 brown\n#&gt; 3 Sam      18 black\n\nSubsetting differs by data frames and tibbles. Tibbles always return a tibble when subsetting, and no partial matching is allowed with column names.\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n\n chr \"a\"\n\n#&gt;  chr \"a\"\nstr(df2$x)\n\nWarning: Unknown or uninitialised column: `x`.\n\n\n NULL\n\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt;  NULL\n\nExtract single columns with df[[\"col\"]].\n\nis.data.frame(df1)\n\n[1] TRUE\n\n#&gt; [1] TRUE\nis.data.frame(df2) # this is a tibble and it passes this test.\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nIf you want to distinguish:\n\nis_tibble(df1)\n\n[1] FALSE\n\n#&gt; [1] FALSE\nis_tibble(df2)\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nList Columns - since a data frame or a tibble is a list, it can contain other lists.\n\n# extra work is required to add a list to a data frame - either after creation or using I()\n\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\nList columns are easier to use in a tibble.\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n\n# A tibble: 3 × 2\n      x y        \n  &lt;int&gt; &lt;list&gt;   \n1     1 &lt;int [2]&gt;\n2     2 &lt;int [3]&gt;\n3     3 &lt;int [4]&gt;\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\nMatrix and data frame columns are possible, but not advised. The NROW() og the matrix must match the data frame number of rows.\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n\n'data.frame':   3 obs. of  3 variables:\n $ x: num  10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':  3 obs. of  2 variables:\n  ..$ a: int  3 2 1\n  ..$ b: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\"\n\n\n\n\nAlways length zero, and cannot have attributes. A unique type.\n\ntypeof(NULL)\n\n[1] \"NULL\"\n\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n\n[1] 0\n\n#&gt; [1] 0\n\nx &lt;- NULL\n# attr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL\n\nNULL represents an absent vector, whereas NA represents an absent element. NULL can be useful in default function arguments."
  },
  {
    "objectID": "chapter_03_notes.html#atomic-vectors",
    "href": "chapter_03_notes.html#atomic-vectors",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.2 introduces you to the atomic vectors: logical, integer, double, and character. These are R’s simplest data structures.\nInteger and double are inconsistently referred to as numeric. There are also two rare types: complex and raw.\nEach of the four primary types has a special syntax to create an individual value (a scalar).\n\n# Logicals\nTRUE\n\n[1] TRUE\n\nT\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nF\n\n[1] FALSE\n\n# Doubles\n0.1234\n\n[1] 0.1234\n\n1.234e-1\n\n[1] 0.1234\n\n## special values unique to double\nInf\n\n[1] Inf\n\n-Inf\n\n[1] -Inf\n\nNaN\n\n[1] NaN\n\n# Integers\n## can be written like a double, but must use L, which represents a long integer in C\n1234L\n\n[1] 1234\n\n1e4L\n\n[1] 10000\n\n# Strings\n## require single or double quotes. special characters escaped with \\\n\"hi there\"\n\n[1] \"hi there\"\n\n\ncombine vectors with c()\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\nc(c(1, 2), c(3, 4))\n\n[1] 1 2 3 4\n\n#&gt; [1] 1 2 3 4\n\n\ntypeof(lgl_var)\n\n[1] \"logical\"\n\n#&gt; [1] \"logical\"\ntypeof(int_var)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\ntypeof(chr_var)\n\n[1] \"character\"\n\n#&gt; [1] \"character\"\n\nmissing values are represented with a sentinal value NA, which are infectious unless some identity holds for all possible inputs\n\nNA &gt; 5\n\n[1] NA\n\n#&gt; [1] NA\n10 * NA\n\n[1] NA\n\n#&gt; [1] NA\n!NA\n\n[1] NA\n\n#&gt; [1] NA\n\nNA ^ 0\n\n[1] 1\n\n#&gt; [1] 1\nNA | TRUE\n\n[1] TRUE\n\n#&gt; [1] TRUE\nNA & FALSE\n\n[1] FALSE\n\n#&gt; [1] FALSE\n\n\n# which values are missing? use is.na()\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n\n[1] NA NA NA NA\n\n#&gt; [1] NA NA NA NA\n\nis.na(x)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n# There are four missing values, one for each atomic vector type\n\nvectors always have one type and will be coerced in a standard order to a single type if you combine multiple vectors of different types: character → double → integer → logical.\n\nstr(c(\"a\", 1))\n\n chr [1:2] \"a\" \"1\"\n\n#&gt;  chr [1:2] \"a\" \"1\"\n\nmathematical functions coerce logicals into 0 and 1\n\nx &lt;- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n\n[1] 0 0 1\n\n#&gt; [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n\n[1] 1\n\n#&gt; [1] 1\n\n# Proportion that are TRUE\nmean(x)\n\n[1] 0.3333333\n\n#&gt; [1] 0.333\n\nForce coercion with the corresponding as.* function\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  1 NA\n\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\n\nc(1, FALSE)\n\n[1] 1 0\n\nc(\"a\", 1)\n\n[1] \"a\" \"1\"\n\nc(TRUE, 1L)\n\n[1] 1 1"
  },
  {
    "objectID": "chapter_03_notes.html#attributes",
    "href": "chapter_03_notes.html#attributes",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.3 takes a small detour to discuss attributes, R’s flexible metadata specification. The most important attributes are names, dimensions, and class.\nHow does the dim attribute make matrices and arrays?\nAttributes can be though of as name-value pairs. Retrieved with attr(), en masse with attributes(), and set en masse with structure().\n\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n\n[1] \"abcdef\"\n\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na &lt;- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\nAttributes are generally ephemeral.\n\nattributes(a[1])\n\nNULL\n\n#&gt; NULL\nattributes(sum(a))\n\nNULL\n\n#&gt; NULL\n\nThere are two exceptions: - names, a character vector giving each element a name - dim, short for dimensions, an integer vector, used to turn vectors into matrices or arrays.\nName a vector in three ways:\n\n# When creating it: \nx &lt;- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\nAdding a dim attribute allows a vector to behave like a 2-d matrix or a multidimensional array.\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\n\nstr(1:3)                   # 1d vector\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n\n int [1:3, 1] 1 2 3\n\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n\n int [1, 1:3] 1 2 3\n\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n\n int [1:3(1d)] 1 2 3\n\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\n\n# What are these and how do they differ from 1:5?\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))"
  },
  {
    "objectID": "chapter_03_notes.html#s3-atomic-vectors",
    "href": "chapter_03_notes.html#s3-atomic-vectors",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.4 discusses the important vector types that are built by combining atomic vectors with special attributes. These include factors, dates, date-times, and durations.\nAn important vector attribute is class. Having a class attribute turns an object into an S3 object, which means will behave differently than a normal vector when passed to a generic function.\nNote that factors are built on Integer vectors, and POSIXct and Date vectors are built on Double vectors.\nFactors are vectors with only pre-defined values, defined by the attributes class and levels.\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n[1] a b b a\nLevels: a b\n\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\nattributes(x)\n\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\nFactors will give counts of unobserved levels in functions like table(), unlike character vectors.\n\nsex_char &lt;- c(\"m\", \"m\", \"m\")\nsex_factor &lt;- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\n#&gt; sex_char\n#&gt; m \n#&gt; 3\ntable(sex_factor)\n\nsex_factor\nm f \n3 0 \n\n#&gt; sex_factor\n#&gt; m f \n#&gt; 3 0\n\nOrdered factors for when order of the levels is meaningful\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n\n[1] b b a c\nLevels: c &lt; b &lt; a\n\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nFactors are coerced in different ways by different functions - sometimes to strings, and sometimes the underlying integer values are used.\nDates are built on top of double vectors and have class “Date” and no other attributes.\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(today)\n\n$class\n[1] \"Date\"\n\n#&gt; $class\n#&gt; [1] \"Date\"\n\nYou can see the value of the double by stripping the class\n\ndate &lt;- as.Date(\"1970-02-01\")\nunclass(date)\n\n[1] 31\n\n#&gt; [1] 31\n\nDate-Times in base R are built on top of Double vectors. One type is POSIXct.\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n\n[1] \"2018-08-01 22:00:00 UTC\"\n\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(now_ct)\n\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntime zones change printing, not the instant of time represented\n\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n\n[1] \"2018-08-02 07:00:00 JST\"\n\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n\n[1] \"2018-08-01 18:00:00 EDT\"\n\n#&gt; [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n\n[1] \"2018-08-02 08:30:00 +1030\"\n\n#&gt; [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n\n[1] \"2018-08-02 CEST\"\n\n#&gt; [1] \"2018-08-02 CEST\"\n\nDurations are stored in difftimes, which are built on top of doubles and have a units attribute that determines how differences should be interpreted.\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n\nTime difference of 1 weeks\n\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_1)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"weeks\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n\nTime difference of 7 days\n\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_2)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"days\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\ntable(letters)\n\nletters\na b c d e f g h i j k l m n o p q r s t u v w x y z \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n\ntypeof(table(letters))\n\n[1] \"integer\"\n\nattributes((table(letters)))\n\n$dim\n[1] 26\n\n$dimnames\n$dimnames$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n$class\n[1] \"table\"\n\n\n\n# what happens to a factor when you modify levels?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\n# How do these differ from f1?\n\nf2 &lt;- rev(factor(letters))\n\nf3 &lt;- factor(letters, levels = rev(letters))"
  },
  {
    "objectID": "chapter_03_notes.html#lists",
    "href": "chapter_03_notes.html#lists",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.5 dives into lists. Lists are very similar to atomic vectors, but have one key difference: an element of a list can be any data type, including another list. This makes them suitable for representing hierarchical data.\nConstruct a list with list():\n\nl1 &lt;- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nstr(l1)\n\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\nElements of a list are references and therefore do not take up as much space as you might imagine:\n\nlobstr::obj_size(mtcars)\n\n7.21 kB\n\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n\n7.29 kB\n\n#&gt; 7.29 kB\n\nLists are sometimes called recursive vectors because they can contain other lists.\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\nc() coerces the vectors to a list, and then flattens everything into one list\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\nTesting and coercion - test with is.list() and coerce with as.list().\n\nlist(1:3)\n\n[[1]]\n[1] 1 2 3\n\n#&gt; [[1]]\n#&gt; [1] 1 2 3\nas.list(1:3)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\nMatrices and arrays\nThe dimension attribute can be used to create list-matrices or list-arrays:\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n\n     [,1]      [,2]\n[1,] integer,3 TRUE\n[2,] \"a\"       1   \n\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3"
  },
  {
    "objectID": "chapter_03_notes.html#data-frames-and-tibbles",
    "href": "chapter_03_notes.html#data-frames-and-tibbles",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.6 teaches you about data frames and tibbles, which are used to represent rectangular data. They combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.\nData frames and tibbles are built on top of lists.\nA data frame is a named list of vectors with attributes for (column) names, row.names, and its class, “data.frame”:\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df1)\n\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nA data frame has rownames() and colnames(). The names() of a data frame are the column names.\nA data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns.\nTibbles are lazy and the class vector is longer, and includes tbl_df.\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df2)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\nCreate a data frame with name-vector pairs:\n\ndf &lt;- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n\n'data.frame':   3 obs. of  2 variables:\n $ x: int  1 2 3\n $ y: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\nCreate a tibble in the same way.\n\ndf2 &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n\ntibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\nTibbles don’t change non-syntactic names. Data frames do.\n\nnames(data.frame(`1` = 1))\n\n[1] \"X1\"\n\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n\n[1] \"1\"\n\n#&gt; [1] \"1\"\n\nTibbles will only recycle vectors of length 1\n\ndata.frame(x = 1:4, y = 1:2)\n\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\n\n#data.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of\n#&gt; rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n\n# A tibble: 4 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     1\n2     2     1\n3     3     1\n4     4     1\n\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\n\n\n# tibble(x = 1:4, y = 1:2)\n#&gt; Error in tibble(x = 1:4, y = 1:2): Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\nA tibble can refer to variables created during construction. Data frames cannot.\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n\n# A tibble: 3 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     2\n2     2     4\n3     3     6\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\nData frames allow row names. This is a character vector with unique values.\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\n\nrownames(df3)\n\n[1] \"Bob\"   \"Susan\" \"Sam\"  \n\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n\n    age  hair\nBob  35 blond\n\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\nTibbles do not support rownames, but can easily convert them to a column in the tibble:\n\nas_tibble(df3, rownames = \"name\")\n\n# A tibble: 3 × 3\n  name    age hair \n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n\n#&gt; # A tibble: 3 × 3\n#&gt;   name    age hair \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Bob      35 blond\n#&gt; 2 Susan    27 brown\n#&gt; 3 Sam      18 black\n\nSubsetting differs by data frames and tibbles. Tibbles always return a tibble when subsetting, and no partial matching is allowed with column names.\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n\n chr \"a\"\n\n#&gt;  chr \"a\"\nstr(df2$x)\n\nWarning: Unknown or uninitialised column: `x`.\n\n\n NULL\n\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt;  NULL\n\nExtract single columns with df[[\"col\"]].\n\nis.data.frame(df1)\n\n[1] TRUE\n\n#&gt; [1] TRUE\nis.data.frame(df2) # this is a tibble and it passes this test.\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nIf you want to distinguish:\n\nis_tibble(df1)\n\n[1] FALSE\n\n#&gt; [1] FALSE\nis_tibble(df2)\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nList Columns - since a data frame or a tibble is a list, it can contain other lists.\n\n# extra work is required to add a list to a data frame - either after creation or using I()\n\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\nList columns are easier to use in a tibble.\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n\n# A tibble: 3 × 2\n      x y        \n  &lt;int&gt; &lt;list&gt;   \n1     1 &lt;int [2]&gt;\n2     2 &lt;int [3]&gt;\n3     3 &lt;int [4]&gt;\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\nMatrix and data frame columns are possible, but not advised. The NROW() og the matrix must match the data frame number of rows.\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n\n'data.frame':   3 obs. of  3 variables:\n $ x: num  10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':  3 obs. of  2 variables:\n  ..$ a: int  3 2 1\n  ..$ b: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\""
  },
  {
    "objectID": "chapter_03_notes.html#null",
    "href": "chapter_03_notes.html#null",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Always length zero, and cannot have attributes. A unique type.\n\ntypeof(NULL)\n\n[1] \"NULL\"\n\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n\n[1] 0\n\n#&gt; [1] 0\n\nx &lt;- NULL\n# attr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL\n\nNULL represents an absent vector, whereas NA represents an absent element. NULL can be useful in default function arguments."
  },
  {
    "objectID": "chapter_01_notes.html",
    "href": "chapter_01_notes.html",
    "title": "Advanced R - Chapter 1 Notes",
    "section": "",
    "text": "R Pros and Cons\n\nPros\n\nfree, latest statistical techniques, purpose-built packages, community support\n\nCons\n\nslow, inconsistency in packages, focus on results instead of software engineering processes\n\n\n\n\nWhat You Will Learn\n\nUnderstand data types, functions, environments and how to use the condition system\nUnderstand what functional programming means\nKnow about object-oriented systems in R\nUnderstand metaprogramming\nUnderstand what slows R down or uses a lot of memory"
  },
  {
    "objectID": "chapter_02_notes.html",
    "href": "chapter_02_notes.html",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The distinction here allows prediction of when R will copy and object, with implications for performance and memory usage.\n\n\nlibrary(lobstr)\n\n\n\nThe assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x1ec1090b728\"\n\nobj_addr(y)\n\n[1] \"0x1ec1090b728\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c.\n\n\n\nWhen does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;000001EC10873D28&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x000001ec10873d28 -&gt; 0x000001ec10853558]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;000001EC1093A5A8&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x1ec10904508] &lt;list&gt; \n├─[2:0x1ec1095d318] &lt;dbl&gt; \n├─[3:0x1ec1095d158] &lt;dbl&gt; \n└─[4:0x1ec10952ea8] &lt;dbl&gt; \n \n█ [5:0x1ec10515458] &lt;list&gt; \n├─[2:0x1ec1095d318] \n├─[3:0x1ec1095d158] \n└─[6:0x1ec083220b0] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” and then edited.\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x1ec10793288] &lt;chr&gt; \n├─[2:0x1ec05db30e0] &lt;string: \"a\"&gt; \n├─[2:0x1ec05db30e0] \n├─[3:0x1ec0d9ae6d0] &lt;string: \"abc\"&gt; \n└─[4:0x1ec0a3107e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;000001EC10107048&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x000001ec10107048 -&gt; 0x000001ec10289608]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec10289608 -&gt; 0x000001ec1061a828]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x1ec1049b708] &lt;list&gt; \n├─[2:0x1ec0883ac80] &lt;int&gt; \n└─[2:0x1ec0883ac80] \n \n█ [3:0x1ec106b36d8] &lt;list&gt; \n├─[1:0x1ec1049b708] \n├─[2:0x1ec0883ac80] \n└─[4:0x1ec089400b0] &lt;int&gt; \n\n\n\n\n\n\nHow much memory does an object occupy? Use lobstr::obj_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\nAlternative representation means sequences of numbers are all the same size. Only the first and last numbers are stored.\n\nobj_size(1:5)\n\n680 B\n\nobj_size(1:1e6)\n\n680 B\n\n\n\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\n#&gt; 8005648 bytes\nobj_size(y)\n\n80.90 kB\n\n#&gt; 80.90 kB\n\n# obj_size account for alternative representation of sequences.\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n#&gt; 18.76 kB\n\n# The size is \"somewhat misleading\" because the size of lists refers to their names, not their objects?\n\n\na &lt;- runif(1e6)\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\nobj_size(b)\n\n8.00 MB\n\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n24.00 MB\n\n# alt rep sequences are aking up 8 MB, and here we copy-on-modify twice, \n# creating three 8 MB sequences for a total of 24 MB by the last line of code.\n\n\n\n\n\nThere are exceptions to copy-on-modify: single-named environments and objects. Objects with a single binding are performance optimized and environments are always modified in place.\n\nv &lt;- c(1, 2, 3)\nv[[3]] &lt;- 4 # modified in place\n\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nA slow for loop. Slow because the dataframe is being copied 15 times - 3 times per iteration.\n\ncat(tracemem(x), \"\\n\")\n\n&lt;000001EC10851B68&gt; \n\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\ntracemem[0x000001ec10851b68 -&gt; 0x000001ec15039428]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039428 -&gt; 0x000001ec150393b8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec150393b8 -&gt; 0x000001ec15039348]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039348 -&gt; 0x000001ec150392d8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec150392d8 -&gt; 0x000001ec15039268]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039268 -&gt; 0x000001ec150391f8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec150391f8 -&gt; 0x000001ec15039188]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039188 -&gt; 0x000001ec15039118]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039118 -&gt; 0x000001ec150390a8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec150390a8 -&gt; 0x000001ec15039038]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nUsing a list reduces the number of copies being made\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n\n&lt;000001EC158882A8&gt; \n\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\ntracemem[0x000001ec158882a8 -&gt; 0x000001ec15c05d58]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nEnvironments are always modified in place. This is referred to as reference semantics. Modifying an environment does not change the existing bindings within an environment.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nChanging a binding means the environment is modified in place. That is, after e1$c is modified, e2$c now points to the same object.\n\ne1$c &lt;- 4\ne2$c\n\n[1] 4\n\n#&gt; [1] 4\n\nEnvironments can contain themselves\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n\n█ [1:0x1ec1346f5b8] &lt;env&gt; \n└─self = [1:0x1ec1346f5b8] \n\n#&gt; █ [1:0x557140f86b08] &lt;env&gt; \n#&gt; └─self = [1:0x557140f86b08]\n\n\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n# Doesn't create a circular list because x is modified in place due to single binding?\n\n\n\n\n\nThe garbage collector frees memory from objects without a referenced name.\n\nx &lt;- 1:3\nx &lt;- 2:4\nrm(x)\n\nThe objects that x was bound to still exist. Use the garbage collector to get rid of them. This actually runs automatically when you need more memory, so you never need to run it yourself.\n\ngc() # it does tell you the memory being used, which can be useful\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1263981 67.6    2640687 141.1  2640687 141.1\nVcells 5824863 44.5   10146329  77.5  8282318  63.2\n\nmem_used()\n\n117.38 MB"
  },
  {
    "objectID": "chapter_02_notes.html#binding-basics",
    "href": "chapter_02_notes.html#binding-basics",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x1ec1090b728\"\n\nobj_addr(y)\n\n[1] \"0x1ec1090b728\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c."
  },
  {
    "objectID": "chapter_02_notes.html#copy-on-modify",
    "href": "chapter_02_notes.html#copy-on-modify",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "When does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;000001EC10873D28&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x000001ec10873d28 -&gt; 0x000001ec10853558]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;000001EC1093A5A8&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x1ec10904508] &lt;list&gt; \n├─[2:0x1ec1095d318] &lt;dbl&gt; \n├─[3:0x1ec1095d158] &lt;dbl&gt; \n└─[4:0x1ec10952ea8] &lt;dbl&gt; \n \n█ [5:0x1ec10515458] &lt;list&gt; \n├─[2:0x1ec1095d318] \n├─[3:0x1ec1095d158] \n└─[6:0x1ec083220b0] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” and then edited.\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x1ec10793288] &lt;chr&gt; \n├─[2:0x1ec05db30e0] &lt;string: \"a\"&gt; \n├─[2:0x1ec05db30e0] \n├─[3:0x1ec0d9ae6d0] &lt;string: \"abc\"&gt; \n└─[4:0x1ec0a3107e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;000001EC10107048&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x000001ec10107048 -&gt; 0x000001ec10289608]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec10289608 -&gt; 0x000001ec1061a828]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x1ec1049b708] &lt;list&gt; \n├─[2:0x1ec0883ac80] &lt;int&gt; \n└─[2:0x1ec0883ac80] \n \n█ [3:0x1ec106b36d8] &lt;list&gt; \n├─[1:0x1ec1049b708] \n├─[2:0x1ec0883ac80] \n└─[4:0x1ec089400b0] &lt;int&gt;"
  },
  {
    "objectID": "chapter_02_notes.html#object-size",
    "href": "chapter_02_notes.html#object-size",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "How much memory does an object occupy? Use lobstr::obj_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\nAlternative representation means sequences of numbers are all the same size. Only the first and last numbers are stored.\n\nobj_size(1:5)\n\n680 B\n\nobj_size(1:1e6)\n\n680 B\n\n\n\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\n#&gt; 8005648 bytes\nobj_size(y)\n\n80.90 kB\n\n#&gt; 80.90 kB\n\n# obj_size account for alternative representation of sequences.\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n#&gt; 18.76 kB\n\n# The size is \"somewhat misleading\" because the size of lists refers to their names, not their objects?\n\n\na &lt;- runif(1e6)\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\nobj_size(b)\n\n8.00 MB\n\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n24.00 MB\n\n# alt rep sequences are aking up 8 MB, and here we copy-on-modify twice, \n# creating three 8 MB sequences for a total of 24 MB by the last line of code."
  },
  {
    "objectID": "chapter_02_notes.html#modify-in-place",
    "href": "chapter_02_notes.html#modify-in-place",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "There are exceptions to copy-on-modify: single-named environments and objects. Objects with a single binding are performance optimized and environments are always modified in place.\n\nv &lt;- c(1, 2, 3)\nv[[3]] &lt;- 4 # modified in place\n\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nA slow for loop. Slow because the dataframe is being copied 15 times - 3 times per iteration.\n\ncat(tracemem(x), \"\\n\")\n\n&lt;000001EC10851B68&gt; \n\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\ntracemem[0x000001ec10851b68 -&gt; 0x000001ec15039428]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039428 -&gt; 0x000001ec150393b8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec150393b8 -&gt; 0x000001ec15039348]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039348 -&gt; 0x000001ec150392d8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec150392d8 -&gt; 0x000001ec15039268]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039268 -&gt; 0x000001ec150391f8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec150391f8 -&gt; 0x000001ec15039188]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039188 -&gt; 0x000001ec15039118]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec15039118 -&gt; 0x000001ec150390a8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001ec150390a8 -&gt; 0x000001ec15039038]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nUsing a list reduces the number of copies being made\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n\n&lt;000001EC158882A8&gt; \n\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\ntracemem[0x000001ec158882a8 -&gt; 0x000001ec15c05d58]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nEnvironments are always modified in place. This is referred to as reference semantics. Modifying an environment does not change the existing bindings within an environment.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nChanging a binding means the environment is modified in place. That is, after e1$c is modified, e2$c now points to the same object.\n\ne1$c &lt;- 4\ne2$c\n\n[1] 4\n\n#&gt; [1] 4\n\nEnvironments can contain themselves\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n\n█ [1:0x1ec1346f5b8] &lt;env&gt; \n└─self = [1:0x1ec1346f5b8] \n\n#&gt; █ [1:0x557140f86b08] &lt;env&gt; \n#&gt; └─self = [1:0x557140f86b08]\n\n\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n# Doesn't create a circular list because x is modified in place due to single binding?"
  },
  {
    "objectID": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "href": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The garbage collector frees memory from objects without a referenced name.\n\nx &lt;- 1:3\nx &lt;- 2:4\nrm(x)\n\nThe objects that x was bound to still exist. Use the garbage collector to get rid of them. This actually runs automatically when you need more memory, so you never need to run it yourself.\n\ngc() # it does tell you the memory being used, which can be useful\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1263981 67.6    2640687 141.1  2640687 141.1\nVcells 5824863 44.5   10146329  77.5  8282318  63.2\n\nmem_used()\n\n117.38 MB"
  },
  {
    "objectID": "chapter_04_notes.html",
    "href": "chapter_04_notes.html",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "Six ways to subset atomic vectors\nThree subsetting operators\nSubsetting operators interact differently with different vector types (e.g., atomic vectors, lists, factors, matrices, and data frames).\nSubsetting can be combined with assignment.\n\n\n\nSection 4.2 starts by teaching you about [. You’ll learn the six ways to subset atomic vectors. You’ll then learn how those six ways act when used to subset lists, matrices, and data frames.\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\nSubset with positive integers\n\nx[c(3, 1)]\n\n[1] 3.3 2.1\n\n#&gt; [1] 3.3 2.1\nx[order(x)]\n\n[1] 2.1 3.3 4.2 5.4\n\n#&gt; [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n\n[1] 2.1 2.1\n\n#&gt; [1] 2.1 2.1\n\n# Real numbers are silently truncated to integers - \n# rounding down and then giving the second integer\nx[c(2.1, 2.9)]\n\n[1] 4.2 4.2\n\n#&gt; [1] 4.2 4.2\n\nNegative integers exclude elements at specific positions\n\nx[-c(3, 1)]\n\n[1] 4.2 5.4\n\n#&gt; [1] 4.2 5.4\n\n# removes elements 3 and 1\n\nYou cannot mix positive and negative integers in a single subset.\nLogical vectors subset where the condition is met\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n\n[1] 2.1 4.2\n\n#&gt; [1] 2.1 4.2\nx[x &gt; 3]\n\n[1] 4.2 3.3 5.4\n\n#&gt; [1] 4.2 3.3 5.4\n\nNothing returns the original vector.\n\nx[]\n\n[1] 2.1 4.2 3.3 5.4\n\n#&gt; [1] 2.1 4.2 3.3 5.4\n\nNamed vectors can be subset with character vectors that match the names.\n\n(y &lt;- setNames(x, letters[1:4]))\n\n  a   b   c   d \n2.1 4.2 3.3 5.4 \n\n#&gt;   a   b   c   d \n#&gt; 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n\n  d   c   a \n5.4 3.3 2.1 \n\n#&gt;   d   c   a \n#&gt; 5.4 3.3 2.1\n\n# Like integer indices, you can repeat indices\ny[c(\"a\", \"a\", \"a\")]\n\n  a   a   a \n2.1 2.1 2.1 \n\n#&gt;   a   a   a \n#&gt; 2.1 2.1 2.1\n\n# When subsetting with [, names are always matched exactly\nz &lt;- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n\n&lt;NA&gt; &lt;NA&gt; \n  NA   NA \n\n#&gt; &lt;NA&gt; &lt;NA&gt; \n#&gt;   NA   NA\n\nAvoid subsetting with factors, as they use the underlying integer vector, not the character levels.\n\ny[factor(\"b\")]\n\n  a \n2.1 \n\n#&gt;   a \n#&gt; 2.1\n\n# Here the `factor(b)` call is return an integer of value 1, so it's returning the first element in the vector being subset, not the element with a name equivalent to \"b\".\n\nLists - Using [ always returns a list; [[ and $ let you pull out elements of a list.\nMatrices and arrays\nSubset higher dimensional structures in three ways 1. multiple vectors 2. single vector 3. a matrix\nblank subsetting retains all rows or columns.\n\na &lt;- matrix(1:9, nrow = 3)\ncolnames(a) &lt;- c(\"A\", \"B\", \"C\")\na[1:2, ]\n\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n\n#&gt;      A B C\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n\n     B A\n[1,] 4 1\n[2,] 6 3\n\n#&gt;      B A\n#&gt; [1,] 4 1\n#&gt; [2,] 6 3\na[0, -2]\n\n     A C\n\n#&gt;      A C\n\nBy default, [ simplifies to the lowest possible dimensionality.\n\na[1, ]\n\nA B C \n1 4 7 \n\n#&gt; A B C \n#&gt; 1 4 7\na[1, 1]\n\nA \n1 \n\n#&gt; A \n#&gt; 1\n\nmatrices are just vectors with special attributes, and so can be subset with a single vector\n\nvals &lt;- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n\n     [,1]  [,2]  [,3]  [,4]  [,5] \n[1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n[2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n[3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n[4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n[5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\n#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] \n#&gt; [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#&gt; [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#&gt; [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#&gt; [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#&gt; [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n\n[1] \"4,1\" \"5,3\"\n\n#&gt; [1] \"4,1\" \"5,3\"\n\nYou can also subset higher dimensional structures with an integer matrix\n\nselect &lt;- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nvals[select]\n\n[1] \"1,1\" \"3,1\" \"2,4\"\n\n#&gt; [1] \"1,1\" \"3,1\" \"2,4\"\n\nData frames and tibbles\nSubsetting with one index indexes the columns; with two you are indexing rows and then columns.\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n\n  x y z\n2 2 2 b\n\n#&gt;   x y z\n#&gt; 2 2 2 b\ndf[c(1, 3), ]\n\n  x y z\n1 1 3 a\n3 3 1 c\n\n#&gt;   x y z\n#&gt; 1 1 3 a\n#&gt; 3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n\n'data.frame':   3 obs. of  1 variable:\n $ x: int  1 2 3\n\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\nstr(df[, \"x\"])\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\n\nSubsetting a tibble with [ always returns a tibble.\n\ndf &lt;- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(df[\"x\"])\n\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\nstr(df[, \"x\"])\n\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n\nYou can use the drop argument when subsetting to preserve dimensionality\n\na &lt;- matrix(1:4, nrow = 2)\nstr(a[1, ])\n\n int [1:2] 1 3\n\n#&gt;  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n\n int [1, 1:2] 1 3\n\n#&gt;  int [1, 1:2] 1 3\n\nPreserving dimensionality for data frames\n\ndf &lt;- data.frame(a = 1:2, b = 1:2)\nstr(df[, \"a\"])\n\n int [1:2] 1 2\n\n#&gt;  int [1:2] 1 2\n\nstr(df[, \"a\", drop = FALSE])\n\n'data.frame':   2 obs. of  1 variable:\n $ a: int  1 2\n\n#&gt; 'data.frame':    2 obs. of  1 variable:\n#&gt;  $ a: int  1 2\n\nTibbles default to drop = FALSE.\nFactors also have drop = FALSE as a default.\n\nz &lt;- factor(c(\"a\", \"b\"))\nz[1]\n\n[1] a\nLevels: a b\n\n#&gt; [1] a\n#&gt; Levels: a b\nz[1, drop = TRUE]\n\n[1] a\nLevels: a\n\n#&gt; [1] a\n#&gt; Levels: a\n\n\n\n\n\nmtcars[mtcars$cyl == 4, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[-c(1:4), ]\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl &lt;= 5,]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\n\n\nSection 4.3 expands your knowledge of subsetting operators to include [[ and $ and focuses on the important principles of simplifying versus preserving.\n[[ is for extracting single items, while x$y is useful shorthand for x[[\"y\"]].\nNote that [ on a list always returns a list. Using [[ to return an item within a list. Note that [[ cannot be used with more than two items, unless you are subsetting within a single item within a list. This is best avoided in favor of purrr:pluck().\n\nx &lt;- list(1:3, \"a\", 4:6)\n\nNote the main difference between $ and [[ is that $ does partial matching.\n\nx &lt;- list(abc = 1)\nx$a\n\n[1] 1\n\n#&gt; [1] 1\nx[[\"a\"]]\n\nNULL\n\n#&gt; NULL\n\nMissing and out-of-bounds indices. These are well handled by pluck and chuck from purrr.\n\nx &lt;- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n\n[1] 1\n\n#&gt; [1] 1\n\npurrr::pluck(x, \"c\", 1)\n\nNULL\n\n#&gt; NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n\n[1] NA\n\n#&gt; [1] NA\n\n\n\n\nIn Section 4.4 you’ll learn the art of subassignment, which combines subsetting and assignment to modify parts of an object.\n\nx &lt;- 1:5\nx[c(1, 2)] &lt;- c(101, 102)\nx\n\n[1] 101 102   3   4   5\n\n#&gt; [1] 101 102   3   4   5\n\nYou can use NULL to remove a component from a list or set the value to NULL.\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- NULL\nstr(x)\n\nList of 1\n $ a: num 1\n\n#&gt; List of 1\n#&gt;  $ a: num 1\n\ny &lt;- list(a = 1, b = 2)\ny[\"b\"] &lt;- list(NULL)\nstr(y)\n\nList of 2\n $ a: num 1\n $ b: NULL\n\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: NULL\n\nChanging contents vs changing bound objects\n\n# mtcars[] &lt;- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n# #&gt; [1] TRUE\n\n# mtcars &lt;- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n#&gt; [1] FALSE\n\n\n\n\nSection 4.5 leads you through eight important, but not obvious, applications of subsetting to solve problems that you often encounter in data analysis.\n\n\nConvert abbreviations\n\nx &lt;- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup &lt;- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n\n       m        f        u        f        f        m        m \n  \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\" \n\n#&gt;        m        f        u        f        f        m        m \n#&gt;   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\n\nunname(lookup[x])\n\n[1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\"  \n\n\n\n\n\n\ngrades &lt;- c(1, 2, 2, 3, 1)\n\ninfo &lt;- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\n\nid &lt;- match(grades, info$grade)\nid\n\n[1] 3 2 2 1 3\n\n#&gt; [1] 3 2 2 1 3\ninfo[id, ]\n\n    grade      desc  fail\n3       1      Poor  TRUE\n2       2      Good FALSE\n2.1     2      Good FALSE\n1       3 Excellent FALSE\n3.1     1      Poor  TRUE\n\n#&gt;     grade      desc  fail\n#&gt; 3       1      Poor  TRUE\n#&gt; 2       2      Good FALSE\n#&gt; 2.1     2      Good FALSE\n#&gt; 1       3 Excellent FALSE\n#&gt; 3.1     1      Poor  TRUE\n\n\n\n\n\ndf &lt;- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Randomly reorder\ndf[sample(nrow(df)), ]\n\n  x y z\n1 1 5 a\n5 2 1 e\n2 2 4 b\n4 1 2 d\n3 3 3 c\n\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 3 3 3 c\n#&gt; 4 1 2 d\n#&gt; 1 1 5 a\n#&gt; 2 2 4 b\n\n# Select 3 random rows\ndf[sample(nrow(df), 3), ]\n\n  x y z\n4 1 2 d\n3 3 3 c\n1 1 5 a\n\n#&gt;   x y z\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 1 1 5 a\n\n# Select 6 bootstrap replicates\ndf[sample(nrow(df), 6, replace = TRUE), ]\n\n    x y z\n4   1 2 d\n2   2 4 b\n3   3 3 c\n4.1 1 2 d\n3.1 3 3 c\n1   1 5 a\n\n#&gt;     x y z\n#&gt; 5   2 1 e\n#&gt; 5.1 2 1 e\n#&gt; 5.2 2 1 e\n#&gt; 2   2 4 b\n#&gt; 3   3 3 c\n#&gt; 3.1 3 3 c\n\n\n\n\n\nx &lt;- c(\"b\", \"c\", \"a\")\norder(x)\n\n[1] 3 1 2\n\n#&gt; [1] 3 1 2\nx[order(x)]\n\n[1] \"a\" \"b\" \"c\"\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nUsing order with two dimensions.\n\n# Randomly reorder df\ndf2 &lt;- df[sample(nrow(df)), 3:1]\ndf2\n\n  z y x\n4 d 2 1\n2 b 4 2\n3 c 3 3\n1 a 5 1\n5 e 1 2\n\n#&gt;   z y x\n#&gt; 5 e 1 2\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\n\ndf2[order(df2$x), ]\n\n  z y x\n4 d 2 1\n1 a 5 1\n2 b 4 2\n5 e 1 2\n3 c 3 3\n\n#&gt;   z y x\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 5 e 1 2\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\ndf2[, order(names(df2))]\n\n  x y z\n4 1 2 d\n2 2 4 b\n3 3 3 c\n1 1 5 a\n5 2 1 e\n\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 1 1 5 a\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n\n\n\n\nwhen you get identical rows collapsed into one, with a column for count n.\n\ndf &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n\n[1] 1 1 1 2 2 2 2 2 3\n\n#&gt; [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n\n    x  y n\n1   2  9 3\n1.1 2  9 3\n1.2 2  9 3\n2   4 11 5\n2.1 4 11 5\n2.2 4 11 5\n2.3 4 11 5\n2.4 4 11 5\n3   1  6 1\n\n#&gt;     x  y n\n#&gt; 1   2  9 3\n#&gt; 1.1 2  9 3\n#&gt; 1.2 2  9 3\n#&gt; 2   4 11 5\n#&gt; 2.1 4 11 5\n#&gt; 2.2 4 11 5\n#&gt; 2.3 4 11 5\n#&gt; 2.4 4 11 5\n#&gt; 3   1  6 1\n\n\n\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z &lt;- NULL\ndf\n\n  x y\n1 1 3\n2 2 2\n3 3 1\n\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n\n  x y\n1 1 3\n2 2 2\n3 3 1\n\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\n\n\n\n\nmtcars[mtcars$gear == 5, ]\n\n                mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\nMaserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\n\n#&gt;                 mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6\n#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n\n               mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa  30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n\n#&gt;                mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n\n\n\n\n\nx &lt;- sample(10) &lt; 4\nwhich(x)\n\n[1] 5 8 9\n\n#&gt; [1] 2 3 4\n\nunwhich &lt;- function(x, n) {\n  out &lt;- rep_len(FALSE, n)\n  out[x] &lt;- TRUE\n  out\n}\nunwhich(which(x), 10)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\n#&gt;  [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n(x1 &lt;- 1:10 %% 2 == 0)\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n\n[1]  2  4  6  8 10\n\n#&gt; [1]  2  4  6  8 10\n(y1 &lt;- 1:10 %% 5 == 0)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n\n#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n\n[1]  5 10\n\n#&gt; [1]  5 10\n\n# X & Y &lt;-&gt; intersect(x, y)\nx1 & y1\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n\n#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n\n[1] 10\n\n#&gt; [1] 10\n\n# X | Y &lt;-&gt; union(x, y)\nx1 | y1\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n\n[1]  2  4  6  8 10  5\n\n#&gt; [1]  2  4  6  8 10  5\n\n# X & !Y &lt;-&gt; setdiff(x, y)\nx1 & !y1\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n\n[1] 2 4 6 8\n\n#&gt; [1] 2 4 6 8\n\n# xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n\n[1] 2 4 6 8 5\n\n#&gt; [1] 2 4 6 8 5"
  },
  {
    "objectID": "chapter_04_notes.html#selecting-multiple-elements",
    "href": "chapter_04_notes.html#selecting-multiple-elements",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "Section 4.2 starts by teaching you about [. You’ll learn the six ways to subset atomic vectors. You’ll then learn how those six ways act when used to subset lists, matrices, and data frames.\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\nSubset with positive integers\n\nx[c(3, 1)]\n\n[1] 3.3 2.1\n\n#&gt; [1] 3.3 2.1\nx[order(x)]\n\n[1] 2.1 3.3 4.2 5.4\n\n#&gt; [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n\n[1] 2.1 2.1\n\n#&gt; [1] 2.1 2.1\n\n# Real numbers are silently truncated to integers - \n# rounding down and then giving the second integer\nx[c(2.1, 2.9)]\n\n[1] 4.2 4.2\n\n#&gt; [1] 4.2 4.2\n\nNegative integers exclude elements at specific positions\n\nx[-c(3, 1)]\n\n[1] 4.2 5.4\n\n#&gt; [1] 4.2 5.4\n\n# removes elements 3 and 1\n\nYou cannot mix positive and negative integers in a single subset.\nLogical vectors subset where the condition is met\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n\n[1] 2.1 4.2\n\n#&gt; [1] 2.1 4.2\nx[x &gt; 3]\n\n[1] 4.2 3.3 5.4\n\n#&gt; [1] 4.2 3.3 5.4\n\nNothing returns the original vector.\n\nx[]\n\n[1] 2.1 4.2 3.3 5.4\n\n#&gt; [1] 2.1 4.2 3.3 5.4\n\nNamed vectors can be subset with character vectors that match the names.\n\n(y &lt;- setNames(x, letters[1:4]))\n\n  a   b   c   d \n2.1 4.2 3.3 5.4 \n\n#&gt;   a   b   c   d \n#&gt; 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n\n  d   c   a \n5.4 3.3 2.1 \n\n#&gt;   d   c   a \n#&gt; 5.4 3.3 2.1\n\n# Like integer indices, you can repeat indices\ny[c(\"a\", \"a\", \"a\")]\n\n  a   a   a \n2.1 2.1 2.1 \n\n#&gt;   a   a   a \n#&gt; 2.1 2.1 2.1\n\n# When subsetting with [, names are always matched exactly\nz &lt;- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n\n&lt;NA&gt; &lt;NA&gt; \n  NA   NA \n\n#&gt; &lt;NA&gt; &lt;NA&gt; \n#&gt;   NA   NA\n\nAvoid subsetting with factors, as they use the underlying integer vector, not the character levels.\n\ny[factor(\"b\")]\n\n  a \n2.1 \n\n#&gt;   a \n#&gt; 2.1\n\n# Here the `factor(b)` call is return an integer of value 1, so it's returning the first element in the vector being subset, not the element with a name equivalent to \"b\".\n\nLists - Using [ always returns a list; [[ and $ let you pull out elements of a list.\nMatrices and arrays\nSubset higher dimensional structures in three ways 1. multiple vectors 2. single vector 3. a matrix\nblank subsetting retains all rows or columns.\n\na &lt;- matrix(1:9, nrow = 3)\ncolnames(a) &lt;- c(\"A\", \"B\", \"C\")\na[1:2, ]\n\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n\n#&gt;      A B C\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n\n     B A\n[1,] 4 1\n[2,] 6 3\n\n#&gt;      B A\n#&gt; [1,] 4 1\n#&gt; [2,] 6 3\na[0, -2]\n\n     A C\n\n#&gt;      A C\n\nBy default, [ simplifies to the lowest possible dimensionality.\n\na[1, ]\n\nA B C \n1 4 7 \n\n#&gt; A B C \n#&gt; 1 4 7\na[1, 1]\n\nA \n1 \n\n#&gt; A \n#&gt; 1\n\nmatrices are just vectors with special attributes, and so can be subset with a single vector\n\nvals &lt;- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n\n     [,1]  [,2]  [,3]  [,4]  [,5] \n[1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n[2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n[3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n[4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n[5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\n#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] \n#&gt; [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#&gt; [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#&gt; [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#&gt; [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#&gt; [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n\n[1] \"4,1\" \"5,3\"\n\n#&gt; [1] \"4,1\" \"5,3\"\n\nYou can also subset higher dimensional structures with an integer matrix\n\nselect &lt;- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nvals[select]\n\n[1] \"1,1\" \"3,1\" \"2,4\"\n\n#&gt; [1] \"1,1\" \"3,1\" \"2,4\"\n\nData frames and tibbles\nSubsetting with one index indexes the columns; with two you are indexing rows and then columns.\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n\n  x y z\n2 2 2 b\n\n#&gt;   x y z\n#&gt; 2 2 2 b\ndf[c(1, 3), ]\n\n  x y z\n1 1 3 a\n3 3 1 c\n\n#&gt;   x y z\n#&gt; 1 1 3 a\n#&gt; 3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n\n'data.frame':   3 obs. of  1 variable:\n $ x: int  1 2 3\n\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\nstr(df[, \"x\"])\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\n\nSubsetting a tibble with [ always returns a tibble.\n\ndf &lt;- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(df[\"x\"])\n\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\nstr(df[, \"x\"])\n\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n\nYou can use the drop argument when subsetting to preserve dimensionality\n\na &lt;- matrix(1:4, nrow = 2)\nstr(a[1, ])\n\n int [1:2] 1 3\n\n#&gt;  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n\n int [1, 1:2] 1 3\n\n#&gt;  int [1, 1:2] 1 3\n\nPreserving dimensionality for data frames\n\ndf &lt;- data.frame(a = 1:2, b = 1:2)\nstr(df[, \"a\"])\n\n int [1:2] 1 2\n\n#&gt;  int [1:2] 1 2\n\nstr(df[, \"a\", drop = FALSE])\n\n'data.frame':   2 obs. of  1 variable:\n $ a: int  1 2\n\n#&gt; 'data.frame':    2 obs. of  1 variable:\n#&gt;  $ a: int  1 2\n\nTibbles default to drop = FALSE.\nFactors also have drop = FALSE as a default.\n\nz &lt;- factor(c(\"a\", \"b\"))\nz[1]\n\n[1] a\nLevels: a b\n\n#&gt; [1] a\n#&gt; Levels: a b\nz[1, drop = TRUE]\n\n[1] a\nLevels: a\n\n#&gt; [1] a\n#&gt; Levels: a"
  },
  {
    "objectID": "chapter_04_notes.html#exercises",
    "href": "chapter_04_notes.html#exercises",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "mtcars[mtcars$cyl == 4, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[-c(1:4), ]\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl &lt;= 5,]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"
  },
  {
    "objectID": "chapter_04_notes.html#selecting-a-single-element",
    "href": "chapter_04_notes.html#selecting-a-single-element",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "Section 4.3 expands your knowledge of subsetting operators to include [[ and $ and focuses on the important principles of simplifying versus preserving.\n[[ is for extracting single items, while x$y is useful shorthand for x[[\"y\"]].\nNote that [ on a list always returns a list. Using [[ to return an item within a list. Note that [[ cannot be used with more than two items, unless you are subsetting within a single item within a list. This is best avoided in favor of purrr:pluck().\n\nx &lt;- list(1:3, \"a\", 4:6)\n\nNote the main difference between $ and [[ is that $ does partial matching.\n\nx &lt;- list(abc = 1)\nx$a\n\n[1] 1\n\n#&gt; [1] 1\nx[[\"a\"]]\n\nNULL\n\n#&gt; NULL\n\nMissing and out-of-bounds indices. These are well handled by pluck and chuck from purrr.\n\nx &lt;- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n\n[1] 1\n\n#&gt; [1] 1\n\npurrr::pluck(x, \"c\", 1)\n\nNULL\n\n#&gt; NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n\n[1] NA\n\n#&gt; [1] NA"
  },
  {
    "objectID": "chapter_04_notes.html#subsetting-and-assignment",
    "href": "chapter_04_notes.html#subsetting-and-assignment",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "In Section 4.4 you’ll learn the art of subassignment, which combines subsetting and assignment to modify parts of an object.\n\nx &lt;- 1:5\nx[c(1, 2)] &lt;- c(101, 102)\nx\n\n[1] 101 102   3   4   5\n\n#&gt; [1] 101 102   3   4   5\n\nYou can use NULL to remove a component from a list or set the value to NULL.\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- NULL\nstr(x)\n\nList of 1\n $ a: num 1\n\n#&gt; List of 1\n#&gt;  $ a: num 1\n\ny &lt;- list(a = 1, b = 2)\ny[\"b\"] &lt;- list(NULL)\nstr(y)\n\nList of 2\n $ a: num 1\n $ b: NULL\n\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: NULL\n\nChanging contents vs changing bound objects\n\n# mtcars[] &lt;- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n# #&gt; [1] TRUE\n\n# mtcars &lt;- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n#&gt; [1] FALSE"
  },
  {
    "objectID": "chapter_04_notes.html#applications",
    "href": "chapter_04_notes.html#applications",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "Section 4.5 leads you through eight important, but not obvious, applications of subsetting to solve problems that you often encounter in data analysis.\n\n\nConvert abbreviations\n\nx &lt;- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup &lt;- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n\n       m        f        u        f        f        m        m \n  \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\" \n\n#&gt;        m        f        u        f        f        m        m \n#&gt;   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\n\nunname(lookup[x])\n\n[1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\"  \n\n\n\n\n\n\ngrades &lt;- c(1, 2, 2, 3, 1)\n\ninfo &lt;- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\n\nid &lt;- match(grades, info$grade)\nid\n\n[1] 3 2 2 1 3\n\n#&gt; [1] 3 2 2 1 3\ninfo[id, ]\n\n    grade      desc  fail\n3       1      Poor  TRUE\n2       2      Good FALSE\n2.1     2      Good FALSE\n1       3 Excellent FALSE\n3.1     1      Poor  TRUE\n\n#&gt;     grade      desc  fail\n#&gt; 3       1      Poor  TRUE\n#&gt; 2       2      Good FALSE\n#&gt; 2.1     2      Good FALSE\n#&gt; 1       3 Excellent FALSE\n#&gt; 3.1     1      Poor  TRUE\n\n\n\n\n\ndf &lt;- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Randomly reorder\ndf[sample(nrow(df)), ]\n\n  x y z\n1 1 5 a\n5 2 1 e\n2 2 4 b\n4 1 2 d\n3 3 3 c\n\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 3 3 3 c\n#&gt; 4 1 2 d\n#&gt; 1 1 5 a\n#&gt; 2 2 4 b\n\n# Select 3 random rows\ndf[sample(nrow(df), 3), ]\n\n  x y z\n4 1 2 d\n3 3 3 c\n1 1 5 a\n\n#&gt;   x y z\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 1 1 5 a\n\n# Select 6 bootstrap replicates\ndf[sample(nrow(df), 6, replace = TRUE), ]\n\n    x y z\n4   1 2 d\n2   2 4 b\n3   3 3 c\n4.1 1 2 d\n3.1 3 3 c\n1   1 5 a\n\n#&gt;     x y z\n#&gt; 5   2 1 e\n#&gt; 5.1 2 1 e\n#&gt; 5.2 2 1 e\n#&gt; 2   2 4 b\n#&gt; 3   3 3 c\n#&gt; 3.1 3 3 c\n\n\n\n\n\nx &lt;- c(\"b\", \"c\", \"a\")\norder(x)\n\n[1] 3 1 2\n\n#&gt; [1] 3 1 2\nx[order(x)]\n\n[1] \"a\" \"b\" \"c\"\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nUsing order with two dimensions.\n\n# Randomly reorder df\ndf2 &lt;- df[sample(nrow(df)), 3:1]\ndf2\n\n  z y x\n4 d 2 1\n2 b 4 2\n3 c 3 3\n1 a 5 1\n5 e 1 2\n\n#&gt;   z y x\n#&gt; 5 e 1 2\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\n\ndf2[order(df2$x), ]\n\n  z y x\n4 d 2 1\n1 a 5 1\n2 b 4 2\n5 e 1 2\n3 c 3 3\n\n#&gt;   z y x\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 5 e 1 2\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\ndf2[, order(names(df2))]\n\n  x y z\n4 1 2 d\n2 2 4 b\n3 3 3 c\n1 1 5 a\n5 2 1 e\n\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 1 1 5 a\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n\n\n\n\nwhen you get identical rows collapsed into one, with a column for count n.\n\ndf &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n\n[1] 1 1 1 2 2 2 2 2 3\n\n#&gt; [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n\n    x  y n\n1   2  9 3\n1.1 2  9 3\n1.2 2  9 3\n2   4 11 5\n2.1 4 11 5\n2.2 4 11 5\n2.3 4 11 5\n2.4 4 11 5\n3   1  6 1\n\n#&gt;     x  y n\n#&gt; 1   2  9 3\n#&gt; 1.1 2  9 3\n#&gt; 1.2 2  9 3\n#&gt; 2   4 11 5\n#&gt; 2.1 4 11 5\n#&gt; 2.2 4 11 5\n#&gt; 2.3 4 11 5\n#&gt; 2.4 4 11 5\n#&gt; 3   1  6 1\n\n\n\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z &lt;- NULL\ndf\n\n  x y\n1 1 3\n2 2 2\n3 3 1\n\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n\n  x y\n1 1 3\n2 2 2\n3 3 1\n\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\n\n\n\n\nmtcars[mtcars$gear == 5, ]\n\n                mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\nMaserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\n\n#&gt;                 mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6\n#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n\n               mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa  30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n\n#&gt;                mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n\n\n\n\n\nx &lt;- sample(10) &lt; 4\nwhich(x)\n\n[1] 5 8 9\n\n#&gt; [1] 2 3 4\n\nunwhich &lt;- function(x, n) {\n  out &lt;- rep_len(FALSE, n)\n  out[x] &lt;- TRUE\n  out\n}\nunwhich(which(x), 10)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\n#&gt;  [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n(x1 &lt;- 1:10 %% 2 == 0)\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n\n[1]  2  4  6  8 10\n\n#&gt; [1]  2  4  6  8 10\n(y1 &lt;- 1:10 %% 5 == 0)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n\n#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n\n[1]  5 10\n\n#&gt; [1]  5 10\n\n# X & Y &lt;-&gt; intersect(x, y)\nx1 & y1\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n\n#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n\n[1] 10\n\n#&gt; [1] 10\n\n# X | Y &lt;-&gt; union(x, y)\nx1 | y1\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n\n[1]  2  4  6  8 10  5\n\n#&gt; [1]  2  4  6  8 10  5\n\n# X & !Y &lt;-&gt; setdiff(x, y)\nx1 & !y1\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n\n[1] 2 4 6 8\n\n#&gt; [1] 2 4 6 8\n\n# xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n\n[1] 2 4 6 8 5\n\n#&gt; [1] 2 4 6 8 5"
  },
  {
    "objectID": "chapter_06_notes.html",
    "href": "chapter_06_notes.html",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "6 Functions"
  }
]