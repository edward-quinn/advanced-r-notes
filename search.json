[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Notebook",
    "section": "",
    "text": "Wickham (2019) Book Notes\nWickham’s book can be found here\n\nChapter 1 Notes\nChapter 2 Notes\nChapter 3 Notes\nChapter 4 Notes\nChapter 5 Notes\nChapter 6 Notes\nChapter 7 Notes\nChapter 8 Notes\nChapter 9 Notes\n\n\n\n\n\n\nReferences\n\nWickham, Hadley. 2019. Advanced R. 2nd Edition. New York: Chapman; Hall/CRC."
  },
  {
    "objectID": "chapter_08_notes.html",
    "href": "chapter_08_notes.html",
    "title": "Advanced R - Chapter 8 Notes",
    "section": "",
    "text": "Authors of functions can indicate that something unusual is happening, and that the user needs to deal with it. The function author can signal conditions with functions like stop() for errors, warning() for warnings, and message() for messages, then the function user can handle them with functions like tryCatch() and withCallingHandlers().\n\n\nSection 8.2 introduces the basic tools for signalling conditions, and discusses when it is appropriate to use each type. You can signal errors, warnings, or messages.\n\nlibrary(rlang)\n\n# stop(\"This is what an error looks like\")\n# #&gt; Error: This is what an error looks like\n\nwarning(\"This is what a warning looks like\")\n\nWarning: This is what a warning looks like\n\n#&gt; Warning: This is what a warning looks like\n\nmessage(\"This is what a message looks like\")\n\nThis is what a message looks like\n\n#&gt; This is what a message looks like\n\nErrors are signaled, or thrown, by stop(), or by rlang::abort().\n\n# f &lt;- function() g()\n# g &lt;- function() h()\n# h &lt;- function() stop(\"This is an error!\")\n\n# f()\n# #&gt; Error in h(): This is an error!\n\n# h &lt;- function() abort(\"This is an error!\")\n# f()\n# #&gt; Error in h(): This is an error!\n\nWarnings can be generated (any amount) from a single function call. warning() and rlang::warn() do the same thing with slightly different defaults.\n\nfw &lt;- function() {\n  cat(\"1\\n\")\n  warning(\"W1\")\n  cat(\"2\\n\")\n  warning(\"W2\")\n  cat(\"3\\n\")\n  warning(\"W3\")\n}\n\nfw()\n\n1\n\n\nWarning in fw(): W1\n\n\n2\n\n\nWarning in fw(): W2\n\n\n3\n\n\nWarning in fw(): W3\n\n\nWarnings are appropriate to notify users of a deprecated function and when you are reasonably certain you can recover from a problem.\nMessages are useful when: 1. When a default argument requires some non-trivial amount of computation and you want to tell the user what value was used. 2. To provide regular status updates in functions that are called for side-effects, like writing to disk. 3. When you’re about to start a long running process with no intermediate output. 4. When writing a package, and you want to display a message when your package is loaded.\n\n\n\nSection 8.3 teaches you about the simplest tools for handling conditions: functions like try() and suppressMessages() that swallow conditions and prevent them from getting to the top level.\n\nIgnore errors with try().\nIgnore warnings with suppressWarnings().\nIgnore messages with suppressMessages().\n\n\n# f1 &lt;- function(x) {\n#   log(x)\n#   10\n# }\n# f1(\"x\")\n# #&gt; Error in log(x): non-numeric argument to mathematical function\n\nf2 &lt;- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n\nError in log(x) : non-numeric argument to mathematical function\n\n\n[1] 10\n\n#&gt; Error in log(x) : non-numeric argument to mathematical function\n#&gt; [1] 10\n\n\nsuppressWarnings({\n  warning(\"Uhoh!\")\n  warning(\"Another warning\")\n  1\n})\n\n[1] 1\n\n#&gt; [1] 1\n\nsuppressMessages({\n  message(\"Hello there\")\n  2\n})\n\n[1] 2\n\n#&gt; [1] 2\n\nsuppressWarnings({\n  message(\"You can still see me\")\n  3\n})\n\nYou can still see me\n\n\n[1] 3\n\n#&gt; You can still see me\n#&gt; [1] 3\n\n\n\n\nSection 8.4 introduces the condition object, and the two fundamental tools of condition handling: tryCatch() for error conditions, and withCallingHandlers() for everything else. These are the registration handlers.\n\n# tryCatch(\n#   error = function(cnd) {\n#     # code to run when error is thrown\n#   },\n#   code_to_run_while_handlers_are_active\n# )\n\n# withCallingHandlers(\n#   warning = function(cnd) {\n#     # code to run when warning is signalled\n#   },\n#   message = function(cnd) {\n#     # code to run when message is signalled\n#   },\n#   code_to_run_while_handlers_are_active\n# )\n\ntryCatch() and withCallingHandlers() differ in the type of handlers that they create:\ntryCatch() defines exiting handlers. withCallingHandlers() defines calling handlers. After the condition is captured control returns to the context where the condition was signalled. Suitable for non-error conditions.\nCondition objects are created implicitly whenever you signal a condition, but become explicit inside the handler. You can catch a condition object using rlang::catch_cnd().\n\ncnd &lt;- catch_cnd(stop(\"An error\"))\nstr(cnd)\n\nList of 2\n $ message: chr \"An error\"\n $ call   : language force(expr)\n - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n#&gt; List of 2\n#&gt;  $ message: chr \"An error\"\n#&gt;  $ call   : language force(expr)\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nBuilt-in conditions are lists with two elements: 1. message, a length-1 character vector containing the text to display to a user. 2. call, the call which triggered the condition.\nThey also have a class attribute, which makes them S3 objects. This is a character vector that determines which handlers will match the condition.\nExiting handlers\ntryCatch() registers exiting handlers and is typically used to handle error conditions.\n\nf3 &lt;- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n\n[1] NA\n\n#&gt; [1] NA\n\nThe handlers set up by tryCatch() are called exiting handlers because after the condition is signalled, control passes to the handler and never returns tothe original code, effectively meaning that the code exits.\n\ntryCatch(\n  message = function(cnd) \"There\",\n  {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n\n[1] \"There\"\n\n#&gt; [1] \"There\"\n\n\ntryCatch(\n  error = function(cnd) {\n    paste0(\"--\", conditionMessage(cnd), \"--\")\n  },\n  stop(\"This is an error\")\n)\n\n[1] \"--This is an error--\"\n\n#&gt; [1] \"--This is an error--\"\n\nUse the finally argument in tryCatch() to always end a block of code with another block of code\n\npath &lt;- tempfile()\ntryCatch(\n  {\n    writeLines(\"Hi!\", path)\n    # ...\n  },\n  finally = {\n    # always run\n    unlink(path)\n  }\n)\n\nCalling handlers. Use withCallingHandlers() to set up calling handlers; code execution continues normally once the handler returns.\nNB: there is a difference between exiting handlers handle problems by making them go away. A calling handler handles a problem like you handle a car.\n\ntryCatch(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n\nCaught a message!\n\n#&gt; Caught a message!\n\nwithCallingHandlers(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n\nCaught a message!\n\n\nSomeone there?\n\n\nCaught a message!\n\n\nWhy, yes!\n\n#&gt; Caught a message!\n#&gt; Someone there?\n#&gt; Caught a message!\n#&gt; Why, yes!\n\n\n# Bubbles all the way up to default handler which generates the message\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\nLevel 1\nLevel 2\n\n\nHello\n\n#&gt; Level 1\n#&gt; Level 2\n#&gt; Hello\n\n# Bubbles up to tryCatch\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\nLevel 1\nLevel 2\n\n#&gt; Level 1\n#&gt; Level 2\n\nYou can muffle conditions to prevent them from “bubbling up” to parent handlers.\n\n# Muffles the default handler which prints the messages\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Level 2\\n\")\n    cnd_muffle(cnd)\n  },\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\nLevel 1\nLevel 2\n\n#&gt; Level 1\n#&gt; Level 2\n\n# Muffles level 2 handler and the default handler\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n\nLevel 1\n\n#&gt; Level 1\n\nCall stacks are different between exiting and calling handlers.\n\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() message(\"!\")\n\nwithCallingHandlers(f(), message = function(cnd) {\n  lobstr::cst()\n  cnd_muffle(cnd)\n})\n\n     ▆\n  1. ├─base::withCallingHandlers(...)\n  2. ├─global f()\n  3. │ └─global g()\n  4. │   └─global h()\n  5. │     └─base::message(\"!\")\n  6. │       ├─base::withRestarts(...)\n  7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n  8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n  9. │       └─base::signalCondition(cond)\n 10. └─global `&lt;fn&gt;`(`&lt;smplMssg&gt;`)\n 11.   └─lobstr::cst()\n\n#&gt;      ▆\n#&gt;   1. ├─base::withCallingHandlers(...)\n#&gt;   2. ├─global f()\n#&gt;   3. │ └─global g()\n#&gt;   4. │   └─global h()\n#&gt;   5. │     └─base::message(\"!\")\n#&gt;   6. │       ├─base::withRestarts(...)\n#&gt;   7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n#&gt;   8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n#&gt;   9. │       └─base::signalCondition(cond)\n#&gt;  10. └─global `&lt;fn&gt;`(`&lt;smplMssg&gt;`)\n#&gt;  11.   └─lobstr::cst()\n\ntryCatch(f(), message = function(cnd) lobstr::cst())\n\n    ▆\n 1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n 2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n 3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n 4.       └─value[[3L]](cond)\n 5.         └─lobstr::cst()\n\n#&gt;     ▆\n#&gt;  1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n#&gt;  2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n#&gt;  3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt;  4.       └─value[[3L]](cond)\n#&gt;  5.         └─lobstr::cst()\n\n\n\n\nSection 8.5 shows you how to extend the built-in condition objects to store useful data that condition handlers can use to make more informed decisions.\nHere is the basic pattern:\n\n# abort(\n#   \"error_not_found\",\n#   message = \"Path `blah.csv` not found\", \n#   path = \"blah.csv\"\n# )\n# #&gt; Error: Path `blah.csv` not found\n\nMotivation.\n\n# log(letters)\n# #&gt; Error in log(letters): non-numeric argument to mathematical function\n# log(1:10, base = letters)\n# #&gt; Error in log(1:10, base = letters): non-numeric argument to mathematical\n# #&gt; function\n\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort(paste0(\n      \"`x` must be a numeric vector; not \", typeof(x), \".\"\n    ))\n  }\n  if (!is.numeric(base)) {\n    abort(paste0(\n      \"`base` must be a numeric vector; not \", typeof(base), \".\"\n    ))\n  }\n\n  base::log(x, base = base)\n}\n\nAnd now we have more useful error messages:\n\n# my_log(letters)\n# #&gt; Error in my_log(letters): `x` must be a numeric vector; not character.\n# my_log(1:10, base = letters)\n# #&gt; Error in my_log(1:10, base = letters): `base` must be a numeric vector; not\n# #&gt; character.\n\nSignalling\n\nabort_bad_argument &lt;- function(arg, must, not = NULL) {\n  msg &lt;- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not &lt;- typeof(not)\n    msg &lt;- glue::glue(\"{msg}; not {not}.\")\n  }\n  \n  abort(\"error_bad_argument\", \n    message = msg, \n    arg = arg, \n    must = must, \n    not = not\n  )\n}\n\n# OR if you don't want a dependency on rlang\n\nstop_custom &lt;- function(.subclass, message, call = NULL, ...) {\n  err &lt;- structure(\n    list(\n      message = message,\n      call = call,\n      ...\n    ),\n    class = c(.subclass, \"error\", \"condition\")\n  )\n  stop(err)\n}\n\nerr &lt;- catch_cnd(\n  stop_custom(\"error_new\", \"This is a custom error\", x = 10)\n)\nclass(err)\n\n[1] \"error_new\" \"error\"     \"condition\"\n\nerr$x\n\n[1] 10\n\n\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\n\n\n# my_log(letters)\n# #&gt; Error in abort_bad_argument(\"x\", must = \"be numeric\", not = x): `x` must be\n# #&gt; numeric; not character.\n# my_log(1:10, base = letters)\n# #&gt; Error in abort_bad_argument(\"base\", must = \"be numeric\", not = base): `base`\n# #&gt; must be numeric; not character.\n\nHandling. Structured condition objects are much easier to program with.\n\nlibrary(testthat)\n\nerr &lt;- catch_cnd(my_log(\"a\"))\nexpect_s3_class(err, \"error_bad_argument\")\nexpect_equal(err$arg, \"x\")\nexpect_equal(err$not, \"character\")\n\n\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n\n[1] \"bad_argument\"\n\n#&gt; [1] \"bad_argument\"\n\n\n\n\nSection 8.6 closes out the chapter with a grab bag of practical applications based on the low-level tools found in earlier sections.\nFailure values can be useful with tryCatch().\n\nfail_with &lt;- function(expr, value = NULL) {\n  tryCatch(\n    error = function(cnd) value,\n    expr\n  )\n}\n\nfail_with(log(10), NA_real_)\n\n[1] 2.302585\n\n#&gt; [1] 2.3\nfail_with(log(\"x\"), NA_real_)\n\n[1] NA\n\n#&gt; [1] NA\n\n\ntry2 &lt;- function(expr, silent = FALSE) {\n  tryCatch(\n    error = function(cnd) {\n      msg &lt;- conditionMessage(cnd)\n      if (!silent) {\n        message(\"Error: \", msg)\n      }\n      structure(msg, class = \"try-error\")\n    },\n    expr\n  )\n}\n\ntry2(1)\n\n[1] 1\n\n#&gt; [1] 1\ntry2(stop(\"Hi\"))\n\nError: Hi\n\n\n[1] \"Hi\"\nattr(,\"class\")\n[1] \"try-error\"\n\n#&gt; Error: Hi\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\ntry2(stop(\"Hi\"), silent = TRUE)\n\n[1] \"Hi\"\nattr(,\"class\")\n[1] \"try-error\"\n\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\n\nSuccess and failure values are another use case. Return one success when the code works, and fail when it doesn’t.\n\nfoo &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) error_val,\n    {\n      expr\n      success_val\n    }\n  )\n}\n\ndoes_error &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) TRUE,\n    {\n      expr\n      FALSE\n    }\n  )\n}\n\nYou can also use this sort of pattern to create a try() variant:\n\nsafety &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) {\n      list(result = NULL, error = cnd)\n    },\n    list(result = expr, error = NULL)\n  )\n}\n\nstr(safety(1 + 10))\n\nList of 2\n $ result: num 11\n $ error : NULL\n\n#&gt; List of 2\n#&gt;  $ result: num 11\n#&gt;  $ error : NULL\nstr(safety(stop(\"Error!\")))\n\nList of 2\n $ result: NULL\n $ error :List of 2\n  ..$ message: chr \"Error!\"\n  ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n  ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n#&gt; List of 2\n#&gt;  $ result: NULL\n#&gt;  $ error :List of 2\n#&gt;   ..$ message: chr \"Error!\"\n#&gt;   ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n#&gt;   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nResignal meaning turn warnings into errors, for example.\n\nwarning2error &lt;- function(expr) {\n  withCallingHandlers(\n    warning = function(cnd) abort(conditionMessage(cnd)),\n    expr\n  )\n}\n\n# warning2error({\n#   x &lt;- 2 ^ 4\n#   warn(\"Hello\")\n# })\n# #&gt; Error in (function (cnd) : Hello\n\nRecord. The problem is that calling handlers have side-effects, not return values. Need to modify objects in place.\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n  \n  withCallingHandlers(\n    message = add_cond,\n    warning = add_cond,\n    expr\n  )\n  \n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  inform(\"c\")\n})\n\n[[1]]\n&lt;message/rlang_message&gt;\nMessage:\na\n\n[[2]]\n&lt;warning/rlang_warning&gt;\nWarning:\nb\n\n[[3]]\n&lt;message/rlang_message&gt;\nMessage:\nc\n\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; c"
  },
  {
    "objectID": "chapter_08_notes.html#signalling-conditions",
    "href": "chapter_08_notes.html#signalling-conditions",
    "title": "Advanced R - Chapter 8 Notes",
    "section": "",
    "text": "Section 8.2 introduces the basic tools for signalling conditions, and discusses when it is appropriate to use each type. You can signal errors, warnings, or messages.\n\nlibrary(rlang)\n\n# stop(\"This is what an error looks like\")\n# #&gt; Error: This is what an error looks like\n\nwarning(\"This is what a warning looks like\")\n\nWarning: This is what a warning looks like\n\n#&gt; Warning: This is what a warning looks like\n\nmessage(\"This is what a message looks like\")\n\nThis is what a message looks like\n\n#&gt; This is what a message looks like\n\nErrors are signaled, or thrown, by stop(), or by rlang::abort().\n\n# f &lt;- function() g()\n# g &lt;- function() h()\n# h &lt;- function() stop(\"This is an error!\")\n\n# f()\n# #&gt; Error in h(): This is an error!\n\n# h &lt;- function() abort(\"This is an error!\")\n# f()\n# #&gt; Error in h(): This is an error!\n\nWarnings can be generated (any amount) from a single function call. warning() and rlang::warn() do the same thing with slightly different defaults.\n\nfw &lt;- function() {\n  cat(\"1\\n\")\n  warning(\"W1\")\n  cat(\"2\\n\")\n  warning(\"W2\")\n  cat(\"3\\n\")\n  warning(\"W3\")\n}\n\nfw()\n\n1\n\n\nWarning in fw(): W1\n\n\n2\n\n\nWarning in fw(): W2\n\n\n3\n\n\nWarning in fw(): W3\n\n\nWarnings are appropriate to notify users of a deprecated function and when you are reasonably certain you can recover from a problem.\nMessages are useful when: 1. When a default argument requires some non-trivial amount of computation and you want to tell the user what value was used. 2. To provide regular status updates in functions that are called for side-effects, like writing to disk. 3. When you’re about to start a long running process with no intermediate output. 4. When writing a package, and you want to display a message when your package is loaded."
  },
  {
    "objectID": "chapter_08_notes.html#ignoring-conditions",
    "href": "chapter_08_notes.html#ignoring-conditions",
    "title": "Advanced R - Chapter 8 Notes",
    "section": "",
    "text": "Section 8.3 teaches you about the simplest tools for handling conditions: functions like try() and suppressMessages() that swallow conditions and prevent them from getting to the top level.\n\nIgnore errors with try().\nIgnore warnings with suppressWarnings().\nIgnore messages with suppressMessages().\n\n\n# f1 &lt;- function(x) {\n#   log(x)\n#   10\n# }\n# f1(\"x\")\n# #&gt; Error in log(x): non-numeric argument to mathematical function\n\nf2 &lt;- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n\nError in log(x) : non-numeric argument to mathematical function\n\n\n[1] 10\n\n#&gt; Error in log(x) : non-numeric argument to mathematical function\n#&gt; [1] 10\n\n\nsuppressWarnings({\n  warning(\"Uhoh!\")\n  warning(\"Another warning\")\n  1\n})\n\n[1] 1\n\n#&gt; [1] 1\n\nsuppressMessages({\n  message(\"Hello there\")\n  2\n})\n\n[1] 2\n\n#&gt; [1] 2\n\nsuppressWarnings({\n  message(\"You can still see me\")\n  3\n})\n\nYou can still see me\n\n\n[1] 3\n\n#&gt; You can still see me\n#&gt; [1] 3"
  },
  {
    "objectID": "chapter_08_notes.html#handling-conditions",
    "href": "chapter_08_notes.html#handling-conditions",
    "title": "Advanced R - Chapter 8 Notes",
    "section": "",
    "text": "Section 8.4 introduces the condition object, and the two fundamental tools of condition handling: tryCatch() for error conditions, and withCallingHandlers() for everything else. These are the registration handlers.\n\n# tryCatch(\n#   error = function(cnd) {\n#     # code to run when error is thrown\n#   },\n#   code_to_run_while_handlers_are_active\n# )\n\n# withCallingHandlers(\n#   warning = function(cnd) {\n#     # code to run when warning is signalled\n#   },\n#   message = function(cnd) {\n#     # code to run when message is signalled\n#   },\n#   code_to_run_while_handlers_are_active\n# )\n\ntryCatch() and withCallingHandlers() differ in the type of handlers that they create:\ntryCatch() defines exiting handlers. withCallingHandlers() defines calling handlers. After the condition is captured control returns to the context where the condition was signalled. Suitable for non-error conditions.\nCondition objects are created implicitly whenever you signal a condition, but become explicit inside the handler. You can catch a condition object using rlang::catch_cnd().\n\ncnd &lt;- catch_cnd(stop(\"An error\"))\nstr(cnd)\n\nList of 2\n $ message: chr \"An error\"\n $ call   : language force(expr)\n - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n#&gt; List of 2\n#&gt;  $ message: chr \"An error\"\n#&gt;  $ call   : language force(expr)\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nBuilt-in conditions are lists with two elements: 1. message, a length-1 character vector containing the text to display to a user. 2. call, the call which triggered the condition.\nThey also have a class attribute, which makes them S3 objects. This is a character vector that determines which handlers will match the condition.\nExiting handlers\ntryCatch() registers exiting handlers and is typically used to handle error conditions.\n\nf3 &lt;- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n\n[1] NA\n\n#&gt; [1] NA\n\nThe handlers set up by tryCatch() are called exiting handlers because after the condition is signalled, control passes to the handler and never returns tothe original code, effectively meaning that the code exits.\n\ntryCatch(\n  message = function(cnd) \"There\",\n  {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n\n[1] \"There\"\n\n#&gt; [1] \"There\"\n\n\ntryCatch(\n  error = function(cnd) {\n    paste0(\"--\", conditionMessage(cnd), \"--\")\n  },\n  stop(\"This is an error\")\n)\n\n[1] \"--This is an error--\"\n\n#&gt; [1] \"--This is an error--\"\n\nUse the finally argument in tryCatch() to always end a block of code with another block of code\n\npath &lt;- tempfile()\ntryCatch(\n  {\n    writeLines(\"Hi!\", path)\n    # ...\n  },\n  finally = {\n    # always run\n    unlink(path)\n  }\n)\n\nCalling handlers. Use withCallingHandlers() to set up calling handlers; code execution continues normally once the handler returns.\nNB: there is a difference between exiting handlers handle problems by making them go away. A calling handler handles a problem like you handle a car.\n\ntryCatch(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n\nCaught a message!\n\n#&gt; Caught a message!\n\nwithCallingHandlers(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n\nCaught a message!\n\n\nSomeone there?\n\n\nCaught a message!\n\n\nWhy, yes!\n\n#&gt; Caught a message!\n#&gt; Someone there?\n#&gt; Caught a message!\n#&gt; Why, yes!\n\n\n# Bubbles all the way up to default handler which generates the message\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\nLevel 1\nLevel 2\n\n\nHello\n\n#&gt; Level 1\n#&gt; Level 2\n#&gt; Hello\n\n# Bubbles up to tryCatch\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\nLevel 1\nLevel 2\n\n#&gt; Level 1\n#&gt; Level 2\n\nYou can muffle conditions to prevent them from “bubbling up” to parent handlers.\n\n# Muffles the default handler which prints the messages\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Level 2\\n\")\n    cnd_muffle(cnd)\n  },\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\nLevel 1\nLevel 2\n\n#&gt; Level 1\n#&gt; Level 2\n\n# Muffles level 2 handler and the default handler\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n\nLevel 1\n\n#&gt; Level 1\n\nCall stacks are different between exiting and calling handlers.\n\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() message(\"!\")\n\nwithCallingHandlers(f(), message = function(cnd) {\n  lobstr::cst()\n  cnd_muffle(cnd)\n})\n\n     ▆\n  1. ├─base::withCallingHandlers(...)\n  2. ├─global f()\n  3. │ └─global g()\n  4. │   └─global h()\n  5. │     └─base::message(\"!\")\n  6. │       ├─base::withRestarts(...)\n  7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n  8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n  9. │       └─base::signalCondition(cond)\n 10. └─global `&lt;fn&gt;`(`&lt;smplMssg&gt;`)\n 11.   └─lobstr::cst()\n\n#&gt;      ▆\n#&gt;   1. ├─base::withCallingHandlers(...)\n#&gt;   2. ├─global f()\n#&gt;   3. │ └─global g()\n#&gt;   4. │   └─global h()\n#&gt;   5. │     └─base::message(\"!\")\n#&gt;   6. │       ├─base::withRestarts(...)\n#&gt;   7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n#&gt;   8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n#&gt;   9. │       └─base::signalCondition(cond)\n#&gt;  10. └─global `&lt;fn&gt;`(`&lt;smplMssg&gt;`)\n#&gt;  11.   └─lobstr::cst()\n\ntryCatch(f(), message = function(cnd) lobstr::cst())\n\n    ▆\n 1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n 2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n 3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n 4.       └─value[[3L]](cond)\n 5.         └─lobstr::cst()\n\n#&gt;     ▆\n#&gt;  1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n#&gt;  2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n#&gt;  3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt;  4.       └─value[[3L]](cond)\n#&gt;  5.         └─lobstr::cst()"
  },
  {
    "objectID": "chapter_08_notes.html#custom-conditions",
    "href": "chapter_08_notes.html#custom-conditions",
    "title": "Advanced R - Chapter 8 Notes",
    "section": "",
    "text": "Section 8.5 shows you how to extend the built-in condition objects to store useful data that condition handlers can use to make more informed decisions.\nHere is the basic pattern:\n\n# abort(\n#   \"error_not_found\",\n#   message = \"Path `blah.csv` not found\", \n#   path = \"blah.csv\"\n# )\n# #&gt; Error: Path `blah.csv` not found\n\nMotivation.\n\n# log(letters)\n# #&gt; Error in log(letters): non-numeric argument to mathematical function\n# log(1:10, base = letters)\n# #&gt; Error in log(1:10, base = letters): non-numeric argument to mathematical\n# #&gt; function\n\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort(paste0(\n      \"`x` must be a numeric vector; not \", typeof(x), \".\"\n    ))\n  }\n  if (!is.numeric(base)) {\n    abort(paste0(\n      \"`base` must be a numeric vector; not \", typeof(base), \".\"\n    ))\n  }\n\n  base::log(x, base = base)\n}\n\nAnd now we have more useful error messages:\n\n# my_log(letters)\n# #&gt; Error in my_log(letters): `x` must be a numeric vector; not character.\n# my_log(1:10, base = letters)\n# #&gt; Error in my_log(1:10, base = letters): `base` must be a numeric vector; not\n# #&gt; character.\n\nSignalling\n\nabort_bad_argument &lt;- function(arg, must, not = NULL) {\n  msg &lt;- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not &lt;- typeof(not)\n    msg &lt;- glue::glue(\"{msg}; not {not}.\")\n  }\n  \n  abort(\"error_bad_argument\", \n    message = msg, \n    arg = arg, \n    must = must, \n    not = not\n  )\n}\n\n# OR if you don't want a dependency on rlang\n\nstop_custom &lt;- function(.subclass, message, call = NULL, ...) {\n  err &lt;- structure(\n    list(\n      message = message,\n      call = call,\n      ...\n    ),\n    class = c(.subclass, \"error\", \"condition\")\n  )\n  stop(err)\n}\n\nerr &lt;- catch_cnd(\n  stop_custom(\"error_new\", \"This is a custom error\", x = 10)\n)\nclass(err)\n\n[1] \"error_new\" \"error\"     \"condition\"\n\nerr$x\n\n[1] 10\n\n\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\n\n\n# my_log(letters)\n# #&gt; Error in abort_bad_argument(\"x\", must = \"be numeric\", not = x): `x` must be\n# #&gt; numeric; not character.\n# my_log(1:10, base = letters)\n# #&gt; Error in abort_bad_argument(\"base\", must = \"be numeric\", not = base): `base`\n# #&gt; must be numeric; not character.\n\nHandling. Structured condition objects are much easier to program with.\n\nlibrary(testthat)\n\nerr &lt;- catch_cnd(my_log(\"a\"))\nexpect_s3_class(err, \"error_bad_argument\")\nexpect_equal(err$arg, \"x\")\nexpect_equal(err$not, \"character\")\n\n\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n\n[1] \"bad_argument\"\n\n#&gt; [1] \"bad_argument\""
  },
  {
    "objectID": "chapter_08_notes.html#applications",
    "href": "chapter_08_notes.html#applications",
    "title": "Advanced R - Chapter 8 Notes",
    "section": "",
    "text": "Section 8.6 closes out the chapter with a grab bag of practical applications based on the low-level tools found in earlier sections.\nFailure values can be useful with tryCatch().\n\nfail_with &lt;- function(expr, value = NULL) {\n  tryCatch(\n    error = function(cnd) value,\n    expr\n  )\n}\n\nfail_with(log(10), NA_real_)\n\n[1] 2.302585\n\n#&gt; [1] 2.3\nfail_with(log(\"x\"), NA_real_)\n\n[1] NA\n\n#&gt; [1] NA\n\n\ntry2 &lt;- function(expr, silent = FALSE) {\n  tryCatch(\n    error = function(cnd) {\n      msg &lt;- conditionMessage(cnd)\n      if (!silent) {\n        message(\"Error: \", msg)\n      }\n      structure(msg, class = \"try-error\")\n    },\n    expr\n  )\n}\n\ntry2(1)\n\n[1] 1\n\n#&gt; [1] 1\ntry2(stop(\"Hi\"))\n\nError: Hi\n\n\n[1] \"Hi\"\nattr(,\"class\")\n[1] \"try-error\"\n\n#&gt; Error: Hi\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\ntry2(stop(\"Hi\"), silent = TRUE)\n\n[1] \"Hi\"\nattr(,\"class\")\n[1] \"try-error\"\n\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\n\nSuccess and failure values are another use case. Return one success when the code works, and fail when it doesn’t.\n\nfoo &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) error_val,\n    {\n      expr\n      success_val\n    }\n  )\n}\n\ndoes_error &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) TRUE,\n    {\n      expr\n      FALSE\n    }\n  )\n}\n\nYou can also use this sort of pattern to create a try() variant:\n\nsafety &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) {\n      list(result = NULL, error = cnd)\n    },\n    list(result = expr, error = NULL)\n  )\n}\n\nstr(safety(1 + 10))\n\nList of 2\n $ result: num 11\n $ error : NULL\n\n#&gt; List of 2\n#&gt;  $ result: num 11\n#&gt;  $ error : NULL\nstr(safety(stop(\"Error!\")))\n\nList of 2\n $ result: NULL\n $ error :List of 2\n  ..$ message: chr \"Error!\"\n  ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n  ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n#&gt; List of 2\n#&gt;  $ result: NULL\n#&gt;  $ error :List of 2\n#&gt;   ..$ message: chr \"Error!\"\n#&gt;   ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n#&gt;   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nResignal meaning turn warnings into errors, for example.\n\nwarning2error &lt;- function(expr) {\n  withCallingHandlers(\n    warning = function(cnd) abort(conditionMessage(cnd)),\n    expr\n  )\n}\n\n# warning2error({\n#   x &lt;- 2 ^ 4\n#   warn(\"Hello\")\n# })\n# #&gt; Error in (function (cnd) : Hello\n\nRecord. The problem is that calling handlers have side-effects, not return values. Need to modify objects in place.\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n  \n  withCallingHandlers(\n    message = add_cond,\n    warning = add_cond,\n    expr\n  )\n  \n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  inform(\"c\")\n})\n\n[[1]]\n&lt;message/rlang_message&gt;\nMessage:\na\n\n[[2]]\n&lt;warning/rlang_warning&gt;\nWarning:\nb\n\n[[3]]\n&lt;message/rlang_message&gt;\nMessage:\nc\n\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; c"
  },
  {
    "objectID": "chapter_06_notes.html",
    "href": "chapter_06_notes.html",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "Section 6.2 describes the basics of creating a function, the three main components of a function, and the exception to many function rules: primitive functions (which are implemented in C, not R).\nFunctions are objects, just like vectors.\nParts of a function - The formals(), the list of arguments that control how you call the function - The body(), the code inside the function - The environment(), the data structure that determines how the function finds the values associated with the names.\nYou specify the formals and body, but the environment is implicitly specified.\n\nf02 &lt;- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n\n$x\n\n\n$y\n\n#&gt; $x\n#&gt; \n#&gt; \n#&gt; $y\n\nbody(f02)\n\n{\n    x + y\n}\n\n#&gt; {\n#&gt;     x + y\n#&gt; }\n\nenvironment(f02)\n\n&lt;environment: R_GlobalEnv&gt;\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nFunctions can posses attributes.\nThere is one exception to the rule that a function has three components. Primitive functions like sum() and [ call C code directly.\n\nsum\n\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n\n#&gt; function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n\n.Primitive(\"[\")\n\n#&gt; .Primitive(\"[\")\n\n# they are types 'builtin' or 'special'\n\ntypeof(sum)\n\n[1] \"builtin\"\n\n#&gt; [1] \"builtin\"\ntypeof(`[`)\n\n[1] \"special\"\n\n#&gt; [1] \"special\"\n\n# because they exist in C, their formals, body, and environment are NULL\n\nformals(sum)\n\nNULL\n\n#&gt; NULL\nbody(sum)\n\nNULL\n\n#&gt; NULL\nenvironment(sum)\n\nNULL\n\n#&gt; NULL\n\nFirst-class functions just means R functions are objects. They don’t require special syntax to define.\n\nf01 &lt;- function(x) {\n  sin(1 / x ^ 2)\n}\n\nNaming functions is not strictly necessary. Unnamed functions are called anonymous functions.\n\nlapply(mtcars, function(x) length(unique(x)))\n\n$mpg\n[1] 25\n\n$cyl\n[1] 3\n\n$disp\n[1] 27\n\n$hp\n[1] 22\n\n$drat\n[1] 22\n\n$wt\n[1] 29\n\n$qsec\n[1] 30\n\n$vs\n[1] 2\n\n$am\n[1] 2\n\n$gear\n[1] 3\n\n$carb\n[1] 6\n\nFilter(function(x) !is.numeric(x), mtcars)\n\ndata frame with 0 columns and 32 rows\n\nintegrate(function(x) sin(x) ^ 2, 0, pi)\n\n1.570796 with absolute error &lt; 1.7e-14\n\n\nFunctions can be contained in a list\n\nfuns &lt;- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\n\nfuns$double(10)\n\n[1] 20\n\n#&gt; [1] 20\n\nIf you already have the arguments in a data structure, you can use do.call()\n\nargs &lt;- list(1:10, na.rm = TRUE)\n\ndo.call(mean, args)\n\n[1] 5.5\n\n#&gt; [1] 5.5\n\n\n\n\nSection 6.3 discusses the strengths and weaknesses of the three forms of function composition commonly used in R code.\nYou can nest function calls or save intermediate results as variables. You can also pipe.\n\nsquare &lt;- function(x) x^2\ndeviation &lt;- function(x) x - mean(x)\nx &lt;- runif(100)\n\nsqrt(mean(square(deviation(x))))\n\n[1] 0.2979194\n\n#&gt; [1] 0.274\n\nout &lt;- deviation(x)\nout &lt;- square(out)\nout &lt;- mean(out)\nout &lt;- sqrt(out)\nout\n\n[1] 0.2979194\n\n#&gt; [1] 0.274\n\n\n\n\nSection 6.4 shows you how R finds the value associated with a given name, i.e. the rules of lexical scoping.\nScoping is finding the value associated with a name.\n\nx &lt;- 10\ng01 &lt;- function() {\n  x &lt;- 20\n  x\n}\n\ng01()\n\n[1] 20\n\n\nR uses lexical scoping: it looks up the values of names based on how a function is defined, not how it is called. “Lexical” indicates that the scoping rules use a parse-time, rather than a run-time structure.\nR’s lexical scoping follows four primary rules: 1. Name masking 2. Functions versus variables 3. A fresh start 4. Dynmamic lookup\nNames defined inside a function mask names defined outside a function.\n\nx &lt;- 10\ny &lt;- 20\ng02 &lt;- function() {\n  x &lt;- 1\n  y &lt;- 2\n  c(x, y)\n}\ng02()\n\n[1] 1 2\n\n#&gt; [1] 1 2\n\nIf a name isn’t defined inside a function, R looks one level up.\n\nx &lt;- 2\ng03 &lt;- function() {\n  y &lt;- 1\n  c(x, y)\n}\ng03()\n\n[1] 2 1\n\n#&gt; [1] 2 1\n\n# And this doesn't change the previous value of y\ny\n\n[1] 20\n\n#&gt; [1] 20\n\nThe same rules apply for a function defined inside of another function.\n\nx &lt;- 1\ng04 &lt;- function() {\n  y &lt;- 2\n  i &lt;- function() {\n    z &lt;- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()\n\n[1] 1 2 3\n\n\nThe same scoping rules apply to functions themselves, not just the arguments or body of a function.\n\ng07 &lt;- function(x) x + 1\ng08 &lt;- function() {\n  g07 &lt;- function(x) x + 100\n  g07(10)\n}\ng08()\n\n[1] 110\n\n#&gt; [1] 110\n\nA fresh start\n\ng11 &lt;- function() {\n  if (!exists(\"a\")) {\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\ng11()\n\n[1] 1\n\ng11()\n\n[1] 1\n\n\ng11() always returns the same value because every time a function is called a new environment is created to host its execution.\nR looks fo r values when a function is run, not when the function is created.\n\ng12 &lt;- function() x + 1\nx &lt;- 15\ng12()\n\n[1] 16\n\n#&gt; [1] 16\n\nx &lt;- 20\ng12()\n\n[1] 21\n\n#&gt; [1] 21\n\n\n\n\nSection 6.5 is devoted to an important property of function arguments: they are only evaluated when used for the first time. Evaluation only takes place for function arguments when they are accessed.\nLazy evaluation powered by promises, which have three components: 1. An expression, like x + y which gives rise to the delayed computation 2. An environment where the expression should be evaluated 3. A value, which is computed and cached the first time a promise is accessed when the expression is evaluated in the specified environment.\nLazy evaluation allows default values to be defined in terms of other arguments, or in terms of variables defined later in the function:\n\nh04 &lt;- function(x = 1, y = x * 2, z = a + b) {\n  a &lt;- 10\n  b &lt;- 100\n  \n  c(x, y, z)\n}\n\nh04()\n\n[1]   1   2 110\n\n#&gt; [1]   1   2 110\n\nThis technique is not recommended. Default and user supplied arguments have slightly different evaluation environments.\n\nh05 &lt;- function(x = ls()) {\n  a &lt;- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n\n[1] \"a\" \"x\"\n\n#&gt; [1] \"a\" \"x\"\n\n# ls() evaluated in global environment:\nh05(ls())\n\n [1] \"args\"      \"deviation\" \"f01\"       \"f02\"       \"funs\"      \"g01\"      \n [7] \"g02\"       \"g03\"       \"g04\"       \"g07\"       \"g08\"       \"g11\"      \n[13] \"g12\"       \"h04\"       \"h05\"       \"out\"       \"square\"    \"x\"        \n[19] \"y\"        \n\n#&gt; [1] \"h05\"\n\nTo determine is an argument’s value comes from the user or from a default, you can use missing():\n\nh06 &lt;- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n\nList of 2\n $ : logi TRUE\n $ : num 10\n\n#&gt; List of 2\n#&gt;  $ : logi TRUE\n#&gt;  $ : num 10\nstr(h06(10))\n\nList of 2\n $ : logi FALSE\n $ : num 10\n\n#&gt; List of 2\n#&gt;  $ : logi FALSE\n#&gt;  $ : num 10\n\nI don’t get how missing() is working here.\n\n\n\nSection 6.6 discusses the special … argument, which allows you to pass on extra arguments to another function.\n\ni01 &lt;- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 &lt;- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n\nList of 2\n $ y: num 2\n $ z: num 3\n\n#&gt; List of 2\n#&gt;  $ y: num 2\n#&gt;  $ z: num 3\n\nlist(...) evaluates the arguments and stores them in a list:\n\ni04 &lt;- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n\nList of 2\n $ a: num 1\n $ b: num 2\n\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: num 2\n\nThere are two primary uses of ...: 1. When a function takes a function as an argument, you need a way to pass additional arguments:\n\nx &lt;- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n\nList of 2\n $ : num 2\n $ : num 5\n\n#&gt; List of 2\n#&gt;  $ : num 2\n#&gt;  $ : num 5\n\n\nTo allow S3 objects to take arbitray extra arguments.\n\n\nprint(factor(letters), max.levels = 4)\n\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n26 Levels: a b c ... z\n\nprint(y ~ x, showEnv = TRUE)\n\ny ~ x\n&lt;environment: R_GlobalEnv&gt;\n\n\nThere are disadvantages of using ...:\n\nMust explain where arguments go\nA misspelled argument does not raise an error.\n\n\nsum(1, 2, NA, na_rm = TRUE)\n\n[1] NA\n\n#&gt; [1] NA\n\n\n\n\nSection 6.7 discusses the two primary ways that a function can exit, and how to define an exit handler, code that is run on exit, regardless of what triggers it.\nMost functions exit by returning a value or throwing an error.\nReturns can be implicit or explicit. With the implicit method, the last evaluated expression is returned:\n\nj01 &lt;- function(x) {\n  if (x &lt; 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n\n[1] 0\n\n#&gt; [1] 0\nj01(15)\n\n[1] 10\n\n#&gt; [1] 10\n\nUse return() to be explicit:\n\nj02 &lt;- function(x) {\n  if (x &lt; 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\n\nj02(11)\n\n[1] 10\n\n\nMost functions return visibly:\n\nj03 &lt;- function() 1\nj03()\n\n[1] 1\n\n#&gt; [1] 1\n\nbut you can turn off automatic printing with invisible():\n\nj04 &lt;- function() invisible(1)\nj04()\n\nThe most common function that returns invisibly is &lt;-.\n\na &lt;- 2\n(a &lt;- 2)\n\n[1] 2\n\n#&gt; [1] 2\n\nErrors. If a function cannot complete its assigned task, it should throw an error with stop(). This immediately terminates the execution of a function.\n\n# j05 &lt;- function() {\n#   stop(\"I'm an error\")\n#   return(10)\n# }\n# j05()\n# #&gt; Error in j05(): I'm an error\n\nuse on.exit() to restore an environment after altering it inside of a function. Now you can place clean-up code next to the code that requires clean-up:\n\n# cleanup &lt;- function(dir, code) {\n#   old_dir &lt;- setwd(dir)\n#   on.exit(setwd(old_dir), add = TRUE)\n  \n#   old_opt &lt;- options(stringsAsFactors = FALSE)\n#   on.exit(options(old_opt), add = TRUE)\n# }\n\n\n\n\nSection 6.8 shows you the various ways in which R disguises ordinary function calls, and how you can use the standard prefix form to better understand what’s going on.\nFunction calls come in four varieties:\n\nprefix: the function name comes before the arguments\ninfix: the function name comes in between the arguments, like x + y\nreplacement: functions that replace values by assignment, like names(df)\nspecial: functions like [[, if, and for. No consistent structure but important.\n\nAll can be written in prefix form.\n\n# x + y\n# `+`(x, y)\n\n# names(df) &lt;- c(\"x\", \"y\", \"z\")\n# `names&lt;-`(df, c(\"x\", \"y\", \"z\"))\n\n# for(i in 1:10) print(i)\n# `for`(i, 1:10, print(i))\n\n\nadd &lt;- function(x, y) x + y\nlapply(list(1:3, 4:5), add, 3)\n\n[[1]]\n[1] 4 5 6\n\n[[2]]\n[1] 7 8\n\n#&gt; [[1]]\n#&gt; [1] 4 5 6\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 7 8\n\nis the same as…\n\nlapply(list(1:3, 4:5), `+`, 3)\n\n[[1]]\n[1] 4 5 6\n\n[[2]]\n[1] 7 8\n\n#&gt; [[1]]\n#&gt; [1] 4 5 6\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 7 8\n\nPrefix form\nYOu can specify arguments in three ways with the prefix form: 1. by position 2. partial matching 3. by name\n\nk01 &lt;- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\nstr(k01(1, 2, 3))\n\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\nstr(k01(2, 3, abcdef = 1))\n\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\n\n# Can abbreviate long argument names:\nstr(k01(2, 3, a = 1))\n\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\n\n# # But this doesn't work because abbreviation is ambiguous\n# str(k01(1, 3, b = 1))\n# #&gt; Error in k01(1, 3, b = 1): argument 3 matches multiple formal arguments\n\ninfix functions are functions that come in between its arguments, and therefore have two arguments.\n\n`%+%` &lt;- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n\n[1] \"new string\"\n\n#&gt; [1] \"new string\"\n\n\n`% %` &lt;- function(a, b) paste(a, b)\n`%/\\\\%` &lt;- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n\n[1] \"a b\"\n\n#&gt; [1] \"a b\"\n\"a\" %/\\% \"b\"\n\n[1] \"a b\"\n\n#&gt; [1] \"a b\"\n\nReplacement functions act like they modify their arguments in place, and have the special name xxx&lt;-.\n\n`second&lt;-` &lt;- function(x, value) {\n  x[2] &lt;- value\n  x\n}\n\nx &lt;- 1:10\nsecond(x) &lt;- 5L\nx\n\n [1]  1  5  3  4  5  6  7  8  9 10\n\n#&gt;  [1]  1  5  3  4  5  6  7  8  9 10\n\n\nx &lt;- 1:10\ntracemem(x)\n\n[1] \"&lt;000001D9D6934B30&gt;\"\n\n#&gt; &lt;0x7ffae71bd880&gt;\n\nsecond(x) &lt;- 6L\n\ntracemem[0x000001d9d6934b30 -&gt; 0x000001d9da116938]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001d9da116938 -&gt; 0x000001d9da1077a8]: second&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7ffae71bd880 -&gt; 0x7ffae61b5480]: \n#&gt; tracemem[0x7ffae61b5480 -&gt; 0x7ffae73f0408]: second&lt;- \n\nSpecial forms"
  },
  {
    "objectID": "chapter_06_notes.html#function-fundamentals",
    "href": "chapter_06_notes.html#function-fundamentals",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "Section 6.2 describes the basics of creating a function, the three main components of a function, and the exception to many function rules: primitive functions (which are implemented in C, not R).\nFunctions are objects, just like vectors.\nParts of a function - The formals(), the list of arguments that control how you call the function - The body(), the code inside the function - The environment(), the data structure that determines how the function finds the values associated with the names.\nYou specify the formals and body, but the environment is implicitly specified.\n\nf02 &lt;- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n\n$x\n\n\n$y\n\n#&gt; $x\n#&gt; \n#&gt; \n#&gt; $y\n\nbody(f02)\n\n{\n    x + y\n}\n\n#&gt; {\n#&gt;     x + y\n#&gt; }\n\nenvironment(f02)\n\n&lt;environment: R_GlobalEnv&gt;\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nFunctions can posses attributes.\nThere is one exception to the rule that a function has three components. Primitive functions like sum() and [ call C code directly.\n\nsum\n\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n\n#&gt; function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n\n.Primitive(\"[\")\n\n#&gt; .Primitive(\"[\")\n\n# they are types 'builtin' or 'special'\n\ntypeof(sum)\n\n[1] \"builtin\"\n\n#&gt; [1] \"builtin\"\ntypeof(`[`)\n\n[1] \"special\"\n\n#&gt; [1] \"special\"\n\n# because they exist in C, their formals, body, and environment are NULL\n\nformals(sum)\n\nNULL\n\n#&gt; NULL\nbody(sum)\n\nNULL\n\n#&gt; NULL\nenvironment(sum)\n\nNULL\n\n#&gt; NULL\n\nFirst-class functions just means R functions are objects. They don’t require special syntax to define.\n\nf01 &lt;- function(x) {\n  sin(1 / x ^ 2)\n}\n\nNaming functions is not strictly necessary. Unnamed functions are called anonymous functions.\n\nlapply(mtcars, function(x) length(unique(x)))\n\n$mpg\n[1] 25\n\n$cyl\n[1] 3\n\n$disp\n[1] 27\n\n$hp\n[1] 22\n\n$drat\n[1] 22\n\n$wt\n[1] 29\n\n$qsec\n[1] 30\n\n$vs\n[1] 2\n\n$am\n[1] 2\n\n$gear\n[1] 3\n\n$carb\n[1] 6\n\nFilter(function(x) !is.numeric(x), mtcars)\n\ndata frame with 0 columns and 32 rows\n\nintegrate(function(x) sin(x) ^ 2, 0, pi)\n\n1.570796 with absolute error &lt; 1.7e-14\n\n\nFunctions can be contained in a list\n\nfuns &lt;- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\n\nfuns$double(10)\n\n[1] 20\n\n#&gt; [1] 20\n\nIf you already have the arguments in a data structure, you can use do.call()\n\nargs &lt;- list(1:10, na.rm = TRUE)\n\ndo.call(mean, args)\n\n[1] 5.5\n\n#&gt; [1] 5.5"
  },
  {
    "objectID": "chapter_06_notes.html#function-composition",
    "href": "chapter_06_notes.html#function-composition",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "Section 6.3 discusses the strengths and weaknesses of the three forms of function composition commonly used in R code.\nYou can nest function calls or save intermediate results as variables. You can also pipe.\n\nsquare &lt;- function(x) x^2\ndeviation &lt;- function(x) x - mean(x)\nx &lt;- runif(100)\n\nsqrt(mean(square(deviation(x))))\n\n[1] 0.2979194\n\n#&gt; [1] 0.274\n\nout &lt;- deviation(x)\nout &lt;- square(out)\nout &lt;- mean(out)\nout &lt;- sqrt(out)\nout\n\n[1] 0.2979194\n\n#&gt; [1] 0.274"
  },
  {
    "objectID": "chapter_06_notes.html#lexical-scoping",
    "href": "chapter_06_notes.html#lexical-scoping",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "Section 6.4 shows you how R finds the value associated with a given name, i.e. the rules of lexical scoping.\nScoping is finding the value associated with a name.\n\nx &lt;- 10\ng01 &lt;- function() {\n  x &lt;- 20\n  x\n}\n\ng01()\n\n[1] 20\n\n\nR uses lexical scoping: it looks up the values of names based on how a function is defined, not how it is called. “Lexical” indicates that the scoping rules use a parse-time, rather than a run-time structure.\nR’s lexical scoping follows four primary rules: 1. Name masking 2. Functions versus variables 3. A fresh start 4. Dynmamic lookup\nNames defined inside a function mask names defined outside a function.\n\nx &lt;- 10\ny &lt;- 20\ng02 &lt;- function() {\n  x &lt;- 1\n  y &lt;- 2\n  c(x, y)\n}\ng02()\n\n[1] 1 2\n\n#&gt; [1] 1 2\n\nIf a name isn’t defined inside a function, R looks one level up.\n\nx &lt;- 2\ng03 &lt;- function() {\n  y &lt;- 1\n  c(x, y)\n}\ng03()\n\n[1] 2 1\n\n#&gt; [1] 2 1\n\n# And this doesn't change the previous value of y\ny\n\n[1] 20\n\n#&gt; [1] 20\n\nThe same rules apply for a function defined inside of another function.\n\nx &lt;- 1\ng04 &lt;- function() {\n  y &lt;- 2\n  i &lt;- function() {\n    z &lt;- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()\n\n[1] 1 2 3\n\n\nThe same scoping rules apply to functions themselves, not just the arguments or body of a function.\n\ng07 &lt;- function(x) x + 1\ng08 &lt;- function() {\n  g07 &lt;- function(x) x + 100\n  g07(10)\n}\ng08()\n\n[1] 110\n\n#&gt; [1] 110\n\nA fresh start\n\ng11 &lt;- function() {\n  if (!exists(\"a\")) {\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\ng11()\n\n[1] 1\n\ng11()\n\n[1] 1\n\n\ng11() always returns the same value because every time a function is called a new environment is created to host its execution.\nR looks fo r values when a function is run, not when the function is created.\n\ng12 &lt;- function() x + 1\nx &lt;- 15\ng12()\n\n[1] 16\n\n#&gt; [1] 16\n\nx &lt;- 20\ng12()\n\n[1] 21\n\n#&gt; [1] 21"
  },
  {
    "objectID": "chapter_06_notes.html#lazy-evaluation",
    "href": "chapter_06_notes.html#lazy-evaluation",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "Section 6.5 is devoted to an important property of function arguments: they are only evaluated when used for the first time. Evaluation only takes place for function arguments when they are accessed.\nLazy evaluation powered by promises, which have three components: 1. An expression, like x + y which gives rise to the delayed computation 2. An environment where the expression should be evaluated 3. A value, which is computed and cached the first time a promise is accessed when the expression is evaluated in the specified environment.\nLazy evaluation allows default values to be defined in terms of other arguments, or in terms of variables defined later in the function:\n\nh04 &lt;- function(x = 1, y = x * 2, z = a + b) {\n  a &lt;- 10\n  b &lt;- 100\n  \n  c(x, y, z)\n}\n\nh04()\n\n[1]   1   2 110\n\n#&gt; [1]   1   2 110\n\nThis technique is not recommended. Default and user supplied arguments have slightly different evaluation environments.\n\nh05 &lt;- function(x = ls()) {\n  a &lt;- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n\n[1] \"a\" \"x\"\n\n#&gt; [1] \"a\" \"x\"\n\n# ls() evaluated in global environment:\nh05(ls())\n\n [1] \"args\"      \"deviation\" \"f01\"       \"f02\"       \"funs\"      \"g01\"      \n [7] \"g02\"       \"g03\"       \"g04\"       \"g07\"       \"g08\"       \"g11\"      \n[13] \"g12\"       \"h04\"       \"h05\"       \"out\"       \"square\"    \"x\"        \n[19] \"y\"        \n\n#&gt; [1] \"h05\"\n\nTo determine is an argument’s value comes from the user or from a default, you can use missing():\n\nh06 &lt;- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n\nList of 2\n $ : logi TRUE\n $ : num 10\n\n#&gt; List of 2\n#&gt;  $ : logi TRUE\n#&gt;  $ : num 10\nstr(h06(10))\n\nList of 2\n $ : logi FALSE\n $ : num 10\n\n#&gt; List of 2\n#&gt;  $ : logi FALSE\n#&gt;  $ : num 10\n\nI don’t get how missing() is working here."
  },
  {
    "objectID": "chapter_06_notes.html#dot-dot-dot",
    "href": "chapter_06_notes.html#dot-dot-dot",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "Section 6.6 discusses the special … argument, which allows you to pass on extra arguments to another function.\n\ni01 &lt;- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 &lt;- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n\nList of 2\n $ y: num 2\n $ z: num 3\n\n#&gt; List of 2\n#&gt;  $ y: num 2\n#&gt;  $ z: num 3\n\nlist(...) evaluates the arguments and stores them in a list:\n\ni04 &lt;- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n\nList of 2\n $ a: num 1\n $ b: num 2\n\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: num 2\n\nThere are two primary uses of ...: 1. When a function takes a function as an argument, you need a way to pass additional arguments:\n\nx &lt;- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n\nList of 2\n $ : num 2\n $ : num 5\n\n#&gt; List of 2\n#&gt;  $ : num 2\n#&gt;  $ : num 5\n\n\nTo allow S3 objects to take arbitray extra arguments.\n\n\nprint(factor(letters), max.levels = 4)\n\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n26 Levels: a b c ... z\n\nprint(y ~ x, showEnv = TRUE)\n\ny ~ x\n&lt;environment: R_GlobalEnv&gt;\n\n\nThere are disadvantages of using ...:\n\nMust explain where arguments go\nA misspelled argument does not raise an error.\n\n\nsum(1, 2, NA, na_rm = TRUE)\n\n[1] NA\n\n#&gt; [1] NA"
  },
  {
    "objectID": "chapter_06_notes.html#exiting-a-function",
    "href": "chapter_06_notes.html#exiting-a-function",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "Section 6.7 discusses the two primary ways that a function can exit, and how to define an exit handler, code that is run on exit, regardless of what triggers it.\nMost functions exit by returning a value or throwing an error.\nReturns can be implicit or explicit. With the implicit method, the last evaluated expression is returned:\n\nj01 &lt;- function(x) {\n  if (x &lt; 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n\n[1] 0\n\n#&gt; [1] 0\nj01(15)\n\n[1] 10\n\n#&gt; [1] 10\n\nUse return() to be explicit:\n\nj02 &lt;- function(x) {\n  if (x &lt; 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\n\nj02(11)\n\n[1] 10\n\n\nMost functions return visibly:\n\nj03 &lt;- function() 1\nj03()\n\n[1] 1\n\n#&gt; [1] 1\n\nbut you can turn off automatic printing with invisible():\n\nj04 &lt;- function() invisible(1)\nj04()\n\nThe most common function that returns invisibly is &lt;-.\n\na &lt;- 2\n(a &lt;- 2)\n\n[1] 2\n\n#&gt; [1] 2\n\nErrors. If a function cannot complete its assigned task, it should throw an error with stop(). This immediately terminates the execution of a function.\n\n# j05 &lt;- function() {\n#   stop(\"I'm an error\")\n#   return(10)\n# }\n# j05()\n# #&gt; Error in j05(): I'm an error\n\nuse on.exit() to restore an environment after altering it inside of a function. Now you can place clean-up code next to the code that requires clean-up:\n\n# cleanup &lt;- function(dir, code) {\n#   old_dir &lt;- setwd(dir)\n#   on.exit(setwd(old_dir), add = TRUE)\n  \n#   old_opt &lt;- options(stringsAsFactors = FALSE)\n#   on.exit(options(old_opt), add = TRUE)\n# }"
  },
  {
    "objectID": "chapter_06_notes.html#function-forms",
    "href": "chapter_06_notes.html#function-forms",
    "title": "Advanced R - Chapter 6 Notes",
    "section": "",
    "text": "Section 6.8 shows you the various ways in which R disguises ordinary function calls, and how you can use the standard prefix form to better understand what’s going on.\nFunction calls come in four varieties:\n\nprefix: the function name comes before the arguments\ninfix: the function name comes in between the arguments, like x + y\nreplacement: functions that replace values by assignment, like names(df)\nspecial: functions like [[, if, and for. No consistent structure but important.\n\nAll can be written in prefix form.\n\n# x + y\n# `+`(x, y)\n\n# names(df) &lt;- c(\"x\", \"y\", \"z\")\n# `names&lt;-`(df, c(\"x\", \"y\", \"z\"))\n\n# for(i in 1:10) print(i)\n# `for`(i, 1:10, print(i))\n\n\nadd &lt;- function(x, y) x + y\nlapply(list(1:3, 4:5), add, 3)\n\n[[1]]\n[1] 4 5 6\n\n[[2]]\n[1] 7 8\n\n#&gt; [[1]]\n#&gt; [1] 4 5 6\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 7 8\n\nis the same as…\n\nlapply(list(1:3, 4:5), `+`, 3)\n\n[[1]]\n[1] 4 5 6\n\n[[2]]\n[1] 7 8\n\n#&gt; [[1]]\n#&gt; [1] 4 5 6\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 7 8\n\nPrefix form\nYOu can specify arguments in three ways with the prefix form: 1. by position 2. partial matching 3. by name\n\nk01 &lt;- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\nstr(k01(1, 2, 3))\n\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\nstr(k01(2, 3, abcdef = 1))\n\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\n\n# Can abbreviate long argument names:\nstr(k01(2, 3, a = 1))\n\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\n\n# # But this doesn't work because abbreviation is ambiguous\n# str(k01(1, 3, b = 1))\n# #&gt; Error in k01(1, 3, b = 1): argument 3 matches multiple formal arguments\n\ninfix functions are functions that come in between its arguments, and therefore have two arguments.\n\n`%+%` &lt;- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n\n[1] \"new string\"\n\n#&gt; [1] \"new string\"\n\n\n`% %` &lt;- function(a, b) paste(a, b)\n`%/\\\\%` &lt;- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n\n[1] \"a b\"\n\n#&gt; [1] \"a b\"\n\"a\" %/\\% \"b\"\n\n[1] \"a b\"\n\n#&gt; [1] \"a b\"\n\nReplacement functions act like they modify their arguments in place, and have the special name xxx&lt;-.\n\n`second&lt;-` &lt;- function(x, value) {\n  x[2] &lt;- value\n  x\n}\n\nx &lt;- 1:10\nsecond(x) &lt;- 5L\nx\n\n [1]  1  5  3  4  5  6  7  8  9 10\n\n#&gt;  [1]  1  5  3  4  5  6  7  8  9 10\n\n\nx &lt;- 1:10\ntracemem(x)\n\n[1] \"&lt;000001D9D6934B30&gt;\"\n\n#&gt; &lt;0x7ffae71bd880&gt;\n\nsecond(x) &lt;- 6L\n\ntracemem[0x000001d9d6934b30 -&gt; 0x000001d9da116938]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001d9da116938 -&gt; 0x000001d9da1077a8]: second&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7ffae71bd880 -&gt; 0x7ffae61b5480]: \n#&gt; tracemem[0x7ffae61b5480 -&gt; 0x7ffae73f0408]: second&lt;- \n\nSpecial forms"
  },
  {
    "objectID": "chapter_04_notes.html",
    "href": "chapter_04_notes.html",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "Six ways to subset atomic vectors\nThree subsetting operators\nSubsetting operators interact differently with different vector types (e.g., atomic vectors, lists, factors, matrices, and data frames).\nSubsetting can be combined with assignment.\n\n\n\nSection 4.2 starts by teaching you about [. You’ll learn the six ways to subset atomic vectors. You’ll then learn how those six ways act when used to subset lists, matrices, and data frames.\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\nSubset with positive integers\n\nx[c(3, 1)]\n\n[1] 3.3 2.1\n\n#&gt; [1] 3.3 2.1\nx[order(x)]\n\n[1] 2.1 3.3 4.2 5.4\n\n#&gt; [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n\n[1] 2.1 2.1\n\n#&gt; [1] 2.1 2.1\n\n# Real numbers are silently truncated to integers - \n# rounding down and then giving the second integer\nx[c(2.1, 2.9)]\n\n[1] 4.2 4.2\n\n#&gt; [1] 4.2 4.2\n\nNegative integers exclude elements at specific positions\n\nx[-c(3, 1)]\n\n[1] 4.2 5.4\n\n#&gt; [1] 4.2 5.4\n\n# removes elements 3 and 1\n\nYou cannot mix positive and negative integers in a single subset.\nLogical vectors subset where the condition is met\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n\n[1] 2.1 4.2\n\n#&gt; [1] 2.1 4.2\nx[x &gt; 3]\n\n[1] 4.2 3.3 5.4\n\n#&gt; [1] 4.2 3.3 5.4\n\nNothing returns the original vector.\n\nx[]\n\n[1] 2.1 4.2 3.3 5.4\n\n#&gt; [1] 2.1 4.2 3.3 5.4\n\nNamed vectors can be subset with character vectors that match the names.\n\n(y &lt;- setNames(x, letters[1:4]))\n\n  a   b   c   d \n2.1 4.2 3.3 5.4 \n\n#&gt;   a   b   c   d \n#&gt; 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n\n  d   c   a \n5.4 3.3 2.1 \n\n#&gt;   d   c   a \n#&gt; 5.4 3.3 2.1\n\n# Like integer indices, you can repeat indices\ny[c(\"a\", \"a\", \"a\")]\n\n  a   a   a \n2.1 2.1 2.1 \n\n#&gt;   a   a   a \n#&gt; 2.1 2.1 2.1\n\n# When subsetting with [, names are always matched exactly\nz &lt;- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n\n&lt;NA&gt; &lt;NA&gt; \n  NA   NA \n\n#&gt; &lt;NA&gt; &lt;NA&gt; \n#&gt;   NA   NA\n\nAvoid subsetting with factors, as they use the underlying integer vector, not the character levels.\n\ny[factor(\"b\")]\n\n  a \n2.1 \n\n#&gt;   a \n#&gt; 2.1\n\n# Here the `factor(b)` call is return an integer of value 1, so it's returning the first element in the vector being subset, not the element with a name equivalent to \"b\".\n\nLists - Using [ always returns a list; [[ and $ let you pull out elements of a list.\nMatrices and arrays\nSubset higher dimensional structures in three ways 1. multiple vectors 2. single vector 3. a matrix\nblank subsetting retains all rows or columns.\n\na &lt;- matrix(1:9, nrow = 3)\ncolnames(a) &lt;- c(\"A\", \"B\", \"C\")\na[1:2, ]\n\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n\n#&gt;      A B C\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n\n     B A\n[1,] 4 1\n[2,] 6 3\n\n#&gt;      B A\n#&gt; [1,] 4 1\n#&gt; [2,] 6 3\na[0, -2]\n\n     A C\n\n#&gt;      A C\n\nBy default, [ simplifies to the lowest possible dimensionality.\n\na[1, ]\n\nA B C \n1 4 7 \n\n#&gt; A B C \n#&gt; 1 4 7\na[1, 1]\n\nA \n1 \n\n#&gt; A \n#&gt; 1\n\nmatrices are just vectors with special attributes, and so can be subset with a single vector\n\nvals &lt;- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n\n     [,1]  [,2]  [,3]  [,4]  [,5] \n[1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n[2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n[3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n[4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n[5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\n#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] \n#&gt; [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#&gt; [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#&gt; [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#&gt; [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#&gt; [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n\n[1] \"4,1\" \"5,3\"\n\n#&gt; [1] \"4,1\" \"5,3\"\n\nYou can also subset higher dimensional structures with an integer matrix\n\nselect &lt;- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nvals[select]\n\n[1] \"1,1\" \"3,1\" \"2,4\"\n\n#&gt; [1] \"1,1\" \"3,1\" \"2,4\"\n\nData frames and tibbles\nSubsetting with one index indexes the columns; with two you are indexing rows and then columns.\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n\n  x y z\n2 2 2 b\n\n#&gt;   x y z\n#&gt; 2 2 2 b\ndf[c(1, 3), ]\n\n  x y z\n1 1 3 a\n3 3 1 c\n\n#&gt;   x y z\n#&gt; 1 1 3 a\n#&gt; 3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n\n'data.frame':   3 obs. of  1 variable:\n $ x: int  1 2 3\n\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\nstr(df[, \"x\"])\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\n\nSubsetting a tibble with [ always returns a tibble.\n\ndf &lt;- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(df[\"x\"])\n\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\nstr(df[, \"x\"])\n\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n\nYou can use the drop argument when subsetting to preserve dimensionality\n\na &lt;- matrix(1:4, nrow = 2)\nstr(a[1, ])\n\n int [1:2] 1 3\n\n#&gt;  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n\n int [1, 1:2] 1 3\n\n#&gt;  int [1, 1:2] 1 3\n\nPreserving dimensionality for data frames\n\ndf &lt;- data.frame(a = 1:2, b = 1:2)\nstr(df[, \"a\"])\n\n int [1:2] 1 2\n\n#&gt;  int [1:2] 1 2\n\nstr(df[, \"a\", drop = FALSE])\n\n'data.frame':   2 obs. of  1 variable:\n $ a: int  1 2\n\n#&gt; 'data.frame':    2 obs. of  1 variable:\n#&gt;  $ a: int  1 2\n\nTibbles default to drop = FALSE.\nFactors also have drop = FALSE as a default.\n\nz &lt;- factor(c(\"a\", \"b\"))\nz[1]\n\n[1] a\nLevels: a b\n\n#&gt; [1] a\n#&gt; Levels: a b\nz[1, drop = TRUE]\n\n[1] a\nLevels: a\n\n#&gt; [1] a\n#&gt; Levels: a\n\n\n\n\n\nmtcars[mtcars$cyl == 4, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[-c(1:4), ]\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl &lt;= 5,]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\n\n\nSection 4.3 expands your knowledge of subsetting operators to include [[ and $ and focuses on the important principles of simplifying versus preserving.\n[[ is for extracting single items, while x$y is useful shorthand for x[[\"y\"]].\nNote that [ on a list always returns a list. Using [[ to return an item within a list. Note that [[ cannot be used with more than two items, unless you are subsetting within a single item within a list. This is best avoided in favor of purrr:pluck().\n\nx &lt;- list(1:3, \"a\", 4:6)\n\nNote the main difference between $ and [[ is that $ does partial matching.\n\nx &lt;- list(abc = 1)\nx$a\n\n[1] 1\n\n#&gt; [1] 1\nx[[\"a\"]]\n\nNULL\n\n#&gt; NULL\n\nMissing and out-of-bounds indices. These are well handled by pluck and chuck from purrr.\n\nx &lt;- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n\n[1] 1\n\n#&gt; [1] 1\n\npurrr::pluck(x, \"c\", 1)\n\nNULL\n\n#&gt; NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n\n[1] NA\n\n#&gt; [1] NA\n\n\n\n\nIn Section 4.4 you’ll learn the art of subassignment, which combines subsetting and assignment to modify parts of an object.\n\nx &lt;- 1:5\nx[c(1, 2)] &lt;- c(101, 102)\nx\n\n[1] 101 102   3   4   5\n\n#&gt; [1] 101 102   3   4   5\n\nYou can use NULL to remove a component from a list or set the value to NULL.\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- NULL\nstr(x)\n\nList of 1\n $ a: num 1\n\n#&gt; List of 1\n#&gt;  $ a: num 1\n\ny &lt;- list(a = 1, b = 2)\ny[\"b\"] &lt;- list(NULL)\nstr(y)\n\nList of 2\n $ a: num 1\n $ b: NULL\n\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: NULL\n\nChanging contents vs changing bound objects\n\n# mtcars[] &lt;- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n# #&gt; [1] TRUE\n\n# mtcars &lt;- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n#&gt; [1] FALSE\n\n\n\n\nSection 4.5 leads you through eight important, but not obvious, applications of subsetting to solve problems that you often encounter in data analysis.\n\n\nConvert abbreviations\n\nx &lt;- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup &lt;- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n\n       m        f        u        f        f        m        m \n  \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\" \n\n#&gt;        m        f        u        f        f        m        m \n#&gt;   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\n\nunname(lookup[x])\n\n[1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\"  \n\n\n\n\n\n\ngrades &lt;- c(1, 2, 2, 3, 1)\n\ninfo &lt;- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\n\nid &lt;- match(grades, info$grade)\nid\n\n[1] 3 2 2 1 3\n\n#&gt; [1] 3 2 2 1 3\ninfo[id, ]\n\n    grade      desc  fail\n3       1      Poor  TRUE\n2       2      Good FALSE\n2.1     2      Good FALSE\n1       3 Excellent FALSE\n3.1     1      Poor  TRUE\n\n#&gt;     grade      desc  fail\n#&gt; 3       1      Poor  TRUE\n#&gt; 2       2      Good FALSE\n#&gt; 2.1     2      Good FALSE\n#&gt; 1       3 Excellent FALSE\n#&gt; 3.1     1      Poor  TRUE\n\n\n\n\n\ndf &lt;- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Randomly reorder\ndf[sample(nrow(df)), ]\n\n  x y z\n4 1 2 d\n1 1 5 a\n3 3 3 c\n5 2 1 e\n2 2 4 b\n\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 3 3 3 c\n#&gt; 4 1 2 d\n#&gt; 1 1 5 a\n#&gt; 2 2 4 b\n\n# Select 3 random rows\ndf[sample(nrow(df), 3), ]\n\n  x y z\n5 2 1 e\n1 1 5 a\n3 3 3 c\n\n#&gt;   x y z\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 1 1 5 a\n\n# Select 6 bootstrap replicates\ndf[sample(nrow(df), 6, replace = TRUE), ]\n\n    x y z\n3   3 3 c\n5   2 1 e\n5.1 2 1 e\n2   2 4 b\n5.2 2 1 e\n1   1 5 a\n\n#&gt;     x y z\n#&gt; 5   2 1 e\n#&gt; 5.1 2 1 e\n#&gt; 5.2 2 1 e\n#&gt; 2   2 4 b\n#&gt; 3   3 3 c\n#&gt; 3.1 3 3 c\n\n\n\n\n\nx &lt;- c(\"b\", \"c\", \"a\")\norder(x)\n\n[1] 3 1 2\n\n#&gt; [1] 3 1 2\nx[order(x)]\n\n[1] \"a\" \"b\" \"c\"\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nUsing order with two dimensions.\n\n# Randomly reorder df\ndf2 &lt;- df[sample(nrow(df)), 3:1]\ndf2\n\n  z y x\n4 d 2 1\n5 e 1 2\n2 b 4 2\n3 c 3 3\n1 a 5 1\n\n#&gt;   z y x\n#&gt; 5 e 1 2\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\n\ndf2[order(df2$x), ]\n\n  z y x\n4 d 2 1\n1 a 5 1\n5 e 1 2\n2 b 4 2\n3 c 3 3\n\n#&gt;   z y x\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 5 e 1 2\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\ndf2[, order(names(df2))]\n\n  x y z\n4 1 2 d\n5 2 1 e\n2 2 4 b\n3 3 3 c\n1 1 5 a\n\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 1 1 5 a\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n\n\n\n\nwhen you get identical rows collapsed into one, with a column for count n.\n\ndf &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n\n[1] 1 1 1 2 2 2 2 2 3\n\n#&gt; [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n\n    x  y n\n1   2  9 3\n1.1 2  9 3\n1.2 2  9 3\n2   4 11 5\n2.1 4 11 5\n2.2 4 11 5\n2.3 4 11 5\n2.4 4 11 5\n3   1  6 1\n\n#&gt;     x  y n\n#&gt; 1   2  9 3\n#&gt; 1.1 2  9 3\n#&gt; 1.2 2  9 3\n#&gt; 2   4 11 5\n#&gt; 2.1 4 11 5\n#&gt; 2.2 4 11 5\n#&gt; 2.3 4 11 5\n#&gt; 2.4 4 11 5\n#&gt; 3   1  6 1\n\n\n\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z &lt;- NULL\ndf\n\n  x y\n1 1 3\n2 2 2\n3 3 1\n\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n\n  x y\n1 1 3\n2 2 2\n3 3 1\n\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\n\n\n\n\nmtcars[mtcars$gear == 5, ]\n\n                mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\nMaserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\n\n#&gt;                 mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6\n#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n\n               mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa  30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n\n#&gt;                mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n\n\n\n\n\nx &lt;- sample(10) &lt; 4\nwhich(x)\n\n[1]  4  8 10\n\n#&gt; [1] 2 3 4\n\nunwhich &lt;- function(x, n) {\n  out &lt;- rep_len(FALSE, n)\n  out[x] &lt;- TRUE\n  out\n}\nunwhich(which(x), 10)\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n(x1 &lt;- 1:10 %% 2 == 0)\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n\n[1]  2  4  6  8 10\n\n#&gt; [1]  2  4  6  8 10\n(y1 &lt;- 1:10 %% 5 == 0)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n\n#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n\n[1]  5 10\n\n#&gt; [1]  5 10\n\n# X & Y &lt;-&gt; intersect(x, y)\nx1 & y1\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n\n#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n\n[1] 10\n\n#&gt; [1] 10\n\n# X | Y &lt;-&gt; union(x, y)\nx1 | y1\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n\n[1]  2  4  6  8 10  5\n\n#&gt; [1]  2  4  6  8 10  5\n\n# X & !Y &lt;-&gt; setdiff(x, y)\nx1 & !y1\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n\n[1] 2 4 6 8\n\n#&gt; [1] 2 4 6 8\n\n# xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n\n[1] 2 4 6 8 5\n\n#&gt; [1] 2 4 6 8 5"
  },
  {
    "objectID": "chapter_04_notes.html#selecting-multiple-elements",
    "href": "chapter_04_notes.html#selecting-multiple-elements",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "Section 4.2 starts by teaching you about [. You’ll learn the six ways to subset atomic vectors. You’ll then learn how those six ways act when used to subset lists, matrices, and data frames.\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\nSubset with positive integers\n\nx[c(3, 1)]\n\n[1] 3.3 2.1\n\n#&gt; [1] 3.3 2.1\nx[order(x)]\n\n[1] 2.1 3.3 4.2 5.4\n\n#&gt; [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n\n[1] 2.1 2.1\n\n#&gt; [1] 2.1 2.1\n\n# Real numbers are silently truncated to integers - \n# rounding down and then giving the second integer\nx[c(2.1, 2.9)]\n\n[1] 4.2 4.2\n\n#&gt; [1] 4.2 4.2\n\nNegative integers exclude elements at specific positions\n\nx[-c(3, 1)]\n\n[1] 4.2 5.4\n\n#&gt; [1] 4.2 5.4\n\n# removes elements 3 and 1\n\nYou cannot mix positive and negative integers in a single subset.\nLogical vectors subset where the condition is met\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n\n[1] 2.1 4.2\n\n#&gt; [1] 2.1 4.2\nx[x &gt; 3]\n\n[1] 4.2 3.3 5.4\n\n#&gt; [1] 4.2 3.3 5.4\n\nNothing returns the original vector.\n\nx[]\n\n[1] 2.1 4.2 3.3 5.4\n\n#&gt; [1] 2.1 4.2 3.3 5.4\n\nNamed vectors can be subset with character vectors that match the names.\n\n(y &lt;- setNames(x, letters[1:4]))\n\n  a   b   c   d \n2.1 4.2 3.3 5.4 \n\n#&gt;   a   b   c   d \n#&gt; 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n\n  d   c   a \n5.4 3.3 2.1 \n\n#&gt;   d   c   a \n#&gt; 5.4 3.3 2.1\n\n# Like integer indices, you can repeat indices\ny[c(\"a\", \"a\", \"a\")]\n\n  a   a   a \n2.1 2.1 2.1 \n\n#&gt;   a   a   a \n#&gt; 2.1 2.1 2.1\n\n# When subsetting with [, names are always matched exactly\nz &lt;- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n\n&lt;NA&gt; &lt;NA&gt; \n  NA   NA \n\n#&gt; &lt;NA&gt; &lt;NA&gt; \n#&gt;   NA   NA\n\nAvoid subsetting with factors, as they use the underlying integer vector, not the character levels.\n\ny[factor(\"b\")]\n\n  a \n2.1 \n\n#&gt;   a \n#&gt; 2.1\n\n# Here the `factor(b)` call is return an integer of value 1, so it's returning the first element in the vector being subset, not the element with a name equivalent to \"b\".\n\nLists - Using [ always returns a list; [[ and $ let you pull out elements of a list.\nMatrices and arrays\nSubset higher dimensional structures in three ways 1. multiple vectors 2. single vector 3. a matrix\nblank subsetting retains all rows or columns.\n\na &lt;- matrix(1:9, nrow = 3)\ncolnames(a) &lt;- c(\"A\", \"B\", \"C\")\na[1:2, ]\n\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n\n#&gt;      A B C\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n\n     B A\n[1,] 4 1\n[2,] 6 3\n\n#&gt;      B A\n#&gt; [1,] 4 1\n#&gt; [2,] 6 3\na[0, -2]\n\n     A C\n\n#&gt;      A C\n\nBy default, [ simplifies to the lowest possible dimensionality.\n\na[1, ]\n\nA B C \n1 4 7 \n\n#&gt; A B C \n#&gt; 1 4 7\na[1, 1]\n\nA \n1 \n\n#&gt; A \n#&gt; 1\n\nmatrices are just vectors with special attributes, and so can be subset with a single vector\n\nvals &lt;- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n\n     [,1]  [,2]  [,3]  [,4]  [,5] \n[1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n[2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n[3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n[4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n[5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\n#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] \n#&gt; [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#&gt; [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#&gt; [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#&gt; [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#&gt; [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n\n[1] \"4,1\" \"5,3\"\n\n#&gt; [1] \"4,1\" \"5,3\"\n\nYou can also subset higher dimensional structures with an integer matrix\n\nselect &lt;- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nvals[select]\n\n[1] \"1,1\" \"3,1\" \"2,4\"\n\n#&gt; [1] \"1,1\" \"3,1\" \"2,4\"\n\nData frames and tibbles\nSubsetting with one index indexes the columns; with two you are indexing rows and then columns.\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n\n  x y z\n2 2 2 b\n\n#&gt;   x y z\n#&gt; 2 2 2 b\ndf[c(1, 3), ]\n\n  x y z\n1 1 3 a\n3 3 1 c\n\n#&gt;   x y z\n#&gt; 1 1 3 a\n#&gt; 3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n\n'data.frame':   3 obs. of  1 variable:\n $ x: int  1 2 3\n\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\nstr(df[, \"x\"])\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\n\nSubsetting a tibble with [ always returns a tibble.\n\ndf &lt;- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(df[\"x\"])\n\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\nstr(df[, \"x\"])\n\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n\nYou can use the drop argument when subsetting to preserve dimensionality\n\na &lt;- matrix(1:4, nrow = 2)\nstr(a[1, ])\n\n int [1:2] 1 3\n\n#&gt;  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n\n int [1, 1:2] 1 3\n\n#&gt;  int [1, 1:2] 1 3\n\nPreserving dimensionality for data frames\n\ndf &lt;- data.frame(a = 1:2, b = 1:2)\nstr(df[, \"a\"])\n\n int [1:2] 1 2\n\n#&gt;  int [1:2] 1 2\n\nstr(df[, \"a\", drop = FALSE])\n\n'data.frame':   2 obs. of  1 variable:\n $ a: int  1 2\n\n#&gt; 'data.frame':    2 obs. of  1 variable:\n#&gt;  $ a: int  1 2\n\nTibbles default to drop = FALSE.\nFactors also have drop = FALSE as a default.\n\nz &lt;- factor(c(\"a\", \"b\"))\nz[1]\n\n[1] a\nLevels: a b\n\n#&gt; [1] a\n#&gt; Levels: a b\nz[1, drop = TRUE]\n\n[1] a\nLevels: a\n\n#&gt; [1] a\n#&gt; Levels: a"
  },
  {
    "objectID": "chapter_04_notes.html#exercises",
    "href": "chapter_04_notes.html#exercises",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "mtcars[mtcars$cyl == 4, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[-c(1:4), ]\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl &lt;= 5,]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"
  },
  {
    "objectID": "chapter_04_notes.html#selecting-a-single-element",
    "href": "chapter_04_notes.html#selecting-a-single-element",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "Section 4.3 expands your knowledge of subsetting operators to include [[ and $ and focuses on the important principles of simplifying versus preserving.\n[[ is for extracting single items, while x$y is useful shorthand for x[[\"y\"]].\nNote that [ on a list always returns a list. Using [[ to return an item within a list. Note that [[ cannot be used with more than two items, unless you are subsetting within a single item within a list. This is best avoided in favor of purrr:pluck().\n\nx &lt;- list(1:3, \"a\", 4:6)\n\nNote the main difference between $ and [[ is that $ does partial matching.\n\nx &lt;- list(abc = 1)\nx$a\n\n[1] 1\n\n#&gt; [1] 1\nx[[\"a\"]]\n\nNULL\n\n#&gt; NULL\n\nMissing and out-of-bounds indices. These are well handled by pluck and chuck from purrr.\n\nx &lt;- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n\n[1] 1\n\n#&gt; [1] 1\n\npurrr::pluck(x, \"c\", 1)\n\nNULL\n\n#&gt; NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n\n[1] NA\n\n#&gt; [1] NA"
  },
  {
    "objectID": "chapter_04_notes.html#subsetting-and-assignment",
    "href": "chapter_04_notes.html#subsetting-and-assignment",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "In Section 4.4 you’ll learn the art of subassignment, which combines subsetting and assignment to modify parts of an object.\n\nx &lt;- 1:5\nx[c(1, 2)] &lt;- c(101, 102)\nx\n\n[1] 101 102   3   4   5\n\n#&gt; [1] 101 102   3   4   5\n\nYou can use NULL to remove a component from a list or set the value to NULL.\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- NULL\nstr(x)\n\nList of 1\n $ a: num 1\n\n#&gt; List of 1\n#&gt;  $ a: num 1\n\ny &lt;- list(a = 1, b = 2)\ny[\"b\"] &lt;- list(NULL)\nstr(y)\n\nList of 2\n $ a: num 1\n $ b: NULL\n\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: NULL\n\nChanging contents vs changing bound objects\n\n# mtcars[] &lt;- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n# #&gt; [1] TRUE\n\n# mtcars &lt;- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n#&gt; [1] FALSE"
  },
  {
    "objectID": "chapter_04_notes.html#applications",
    "href": "chapter_04_notes.html#applications",
    "title": "Advanced R - Chapter 4 Notes",
    "section": "",
    "text": "Section 4.5 leads you through eight important, but not obvious, applications of subsetting to solve problems that you often encounter in data analysis.\n\n\nConvert abbreviations\n\nx &lt;- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup &lt;- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n\n       m        f        u        f        f        m        m \n  \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\" \n\n#&gt;        m        f        u        f        f        m        m \n#&gt;   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\n\nunname(lookup[x])\n\n[1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\"  \n\n\n\n\n\n\ngrades &lt;- c(1, 2, 2, 3, 1)\n\ninfo &lt;- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\n\nid &lt;- match(grades, info$grade)\nid\n\n[1] 3 2 2 1 3\n\n#&gt; [1] 3 2 2 1 3\ninfo[id, ]\n\n    grade      desc  fail\n3       1      Poor  TRUE\n2       2      Good FALSE\n2.1     2      Good FALSE\n1       3 Excellent FALSE\n3.1     1      Poor  TRUE\n\n#&gt;     grade      desc  fail\n#&gt; 3       1      Poor  TRUE\n#&gt; 2       2      Good FALSE\n#&gt; 2.1     2      Good FALSE\n#&gt; 1       3 Excellent FALSE\n#&gt; 3.1     1      Poor  TRUE\n\n\n\n\n\ndf &lt;- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Randomly reorder\ndf[sample(nrow(df)), ]\n\n  x y z\n4 1 2 d\n1 1 5 a\n3 3 3 c\n5 2 1 e\n2 2 4 b\n\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 3 3 3 c\n#&gt; 4 1 2 d\n#&gt; 1 1 5 a\n#&gt; 2 2 4 b\n\n# Select 3 random rows\ndf[sample(nrow(df), 3), ]\n\n  x y z\n5 2 1 e\n1 1 5 a\n3 3 3 c\n\n#&gt;   x y z\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 1 1 5 a\n\n# Select 6 bootstrap replicates\ndf[sample(nrow(df), 6, replace = TRUE), ]\n\n    x y z\n3   3 3 c\n5   2 1 e\n5.1 2 1 e\n2   2 4 b\n5.2 2 1 e\n1   1 5 a\n\n#&gt;     x y z\n#&gt; 5   2 1 e\n#&gt; 5.1 2 1 e\n#&gt; 5.2 2 1 e\n#&gt; 2   2 4 b\n#&gt; 3   3 3 c\n#&gt; 3.1 3 3 c\n\n\n\n\n\nx &lt;- c(\"b\", \"c\", \"a\")\norder(x)\n\n[1] 3 1 2\n\n#&gt; [1] 3 1 2\nx[order(x)]\n\n[1] \"a\" \"b\" \"c\"\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nUsing order with two dimensions.\n\n# Randomly reorder df\ndf2 &lt;- df[sample(nrow(df)), 3:1]\ndf2\n\n  z y x\n4 d 2 1\n5 e 1 2\n2 b 4 2\n3 c 3 3\n1 a 5 1\n\n#&gt;   z y x\n#&gt; 5 e 1 2\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\n\ndf2[order(df2$x), ]\n\n  z y x\n4 d 2 1\n1 a 5 1\n5 e 1 2\n2 b 4 2\n3 c 3 3\n\n#&gt;   z y x\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 5 e 1 2\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\ndf2[, order(names(df2))]\n\n  x y z\n4 1 2 d\n5 2 1 e\n2 2 4 b\n3 3 3 c\n1 1 5 a\n\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 1 1 5 a\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n\n\n\n\nwhen you get identical rows collapsed into one, with a column for count n.\n\ndf &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n\n[1] 1 1 1 2 2 2 2 2 3\n\n#&gt; [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n\n    x  y n\n1   2  9 3\n1.1 2  9 3\n1.2 2  9 3\n2   4 11 5\n2.1 4 11 5\n2.2 4 11 5\n2.3 4 11 5\n2.4 4 11 5\n3   1  6 1\n\n#&gt;     x  y n\n#&gt; 1   2  9 3\n#&gt; 1.1 2  9 3\n#&gt; 1.2 2  9 3\n#&gt; 2   4 11 5\n#&gt; 2.1 4 11 5\n#&gt; 2.2 4 11 5\n#&gt; 2.3 4 11 5\n#&gt; 2.4 4 11 5\n#&gt; 3   1  6 1\n\n\n\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z &lt;- NULL\ndf\n\n  x y\n1 1 3\n2 2 2\n3 3 1\n\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n\n  x y\n1 1 3\n2 2 2\n3 3 1\n\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\n\n\n\n\nmtcars[mtcars$gear == 5, ]\n\n                mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\nMaserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\n\n#&gt;                 mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6\n#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n\n               mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa  30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n\n#&gt;                mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n\n\n\n\n\nx &lt;- sample(10) &lt; 4\nwhich(x)\n\n[1]  4  8 10\n\n#&gt; [1] 2 3 4\n\nunwhich &lt;- function(x, n) {\n  out &lt;- rep_len(FALSE, n)\n  out[x] &lt;- TRUE\n  out\n}\nunwhich(which(x), 10)\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n(x1 &lt;- 1:10 %% 2 == 0)\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n\n[1]  2  4  6  8 10\n\n#&gt; [1]  2  4  6  8 10\n(y1 &lt;- 1:10 %% 5 == 0)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n\n#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n\n[1]  5 10\n\n#&gt; [1]  5 10\n\n# X & Y &lt;-&gt; intersect(x, y)\nx1 & y1\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n\n#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n\n[1] 10\n\n#&gt; [1] 10\n\n# X | Y &lt;-&gt; union(x, y)\nx1 | y1\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n\n[1]  2  4  6  8 10  5\n\n#&gt; [1]  2  4  6  8 10  5\n\n# X & !Y &lt;-&gt; setdiff(x, y)\nx1 & !y1\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n\n[1] 2 4 6 8\n\n#&gt; [1] 2 4 6 8\n\n# xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n\n[1] 2 4 6 8 5\n\n#&gt; [1] 2 4 6 8 5"
  },
  {
    "objectID": "chapter_02_notes.html",
    "href": "chapter_02_notes.html",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The distinction here allows prediction of when R will copy and object, with implications for performance and memory usage.\n\n\nlibrary(lobstr)\n\n\n\nThe assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x209008119f8\"\n\nobj_addr(y)\n\n[1] \"0x209008119f8\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c.\n\n\n\nWhen does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000020900791BD8&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x0000020900791bd8 -&gt; 0x000002090079d408]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000020900821408&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x20900833368] &lt;list&gt; \n├─[2:0x2090090be38] &lt;dbl&gt; \n├─[3:0x2090090bc78] &lt;dbl&gt; \n└─[4:0x2090090bab8] &lt;dbl&gt; \n \n█ [5:0x2090045c778] &lt;list&gt; \n├─[2:0x2090090be38] \n├─[3:0x2090090bc78] \n└─[6:0x208fd147dd0] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” and then edited.\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x2090095cea8] &lt;chr&gt; \n├─[2:0x208f4da70e0] &lt;string: \"a\"&gt; \n├─[2:0x208f4da70e0] \n├─[3:0x208fcc32a88] &lt;string: \"abc\"&gt; \n└─[4:0x208f93327e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;0000020900015988&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x0000020900015988 -&gt; 0x0000020900145f08]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020900145f08 -&gt; 0x000002090057a228]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x209004258c8] &lt;list&gt; \n├─[2:0x208fd69eb30] &lt;int&gt; \n└─[2:0x208fd69eb30] \n \n█ [3:0x20900640dc8] &lt;list&gt; \n├─[1:0x209004258c8] \n├─[2:0x208fd69eb30] \n└─[4:0x208fd74f0b0] &lt;int&gt; \n\n\n\n\n\n\nHow much memory does an object occupy? Use lobstr::obj_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\nAlternative representation means sequences of numbers are all the same size. Only the first and last numbers are stored.\n\nobj_size(1:5)\n\n680 B\n\nobj_size(1:1e6)\n\n680 B\n\n\n\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\n#&gt; 8005648 bytes\nobj_size(y)\n\n80.90 kB\n\n#&gt; 80.90 kB\n\n# obj_size account for alternative representation of sequences.\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n#&gt; 18.76 kB\n\n# The size is \"somewhat misleading\" because the size of lists refers to their names, not their objects?\n\n\na &lt;- runif(1e6)\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\nobj_size(b)\n\n8.00 MB\n\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n24.00 MB\n\n# alt rep sequences are aking up 8 MB, and here we copy-on-modify twice, \n# creating three 8 MB sequences for a total of 24 MB by the last line of code.\n\n\n\n\n\nThere are exceptions to copy-on-modify: single-named environments and objects. Objects with a single binding are performance optimized and environments are always modified in place.\n\nv &lt;- c(1, 2, 3)\nv[[3]] &lt;- 4 # modified in place\n\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nA slow for loop. Slow because the dataframe is being copied 15 times - 3 times per iteration.\n\ncat(tracemem(x), \"\\n\")\n\n&lt;0000020900679238&gt; \n\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\ntracemem[0x0000020900679238 -&gt; 0x0000020904e74c78]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74c78 -&gt; 0x0000020904e74c08]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74c08 -&gt; 0x0000020904e74b98]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74b98 -&gt; 0x0000020904e74b28]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74b28 -&gt; 0x0000020904e74ab8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74ab8 -&gt; 0x0000020904e74a48]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74a48 -&gt; 0x0000020904e749d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e749d8 -&gt; 0x0000020904e74968]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74968 -&gt; 0x0000020904e748f8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e748f8 -&gt; 0x0000020904e74888]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nUsing a list reduces the number of copies being made\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n\n&lt;00000209056B8AF8&gt; \n\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\ntracemem[0x00000209056b8af8 -&gt; 0x000002090599a4d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nEnvironments are always modified in place. This is referred to as reference semantics. Modifying an environment does not change the existing bindings within an environment.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nChanging a binding means the environment is modified in place. That is, after e1$c is modified, e2$c now points to the same object.\n\ne1$c &lt;- 4\ne2$c\n\n[1] 4\n\n#&gt; [1] 4\n\nEnvironments can contain themselves\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n\n█ [1:0x20903349b30] &lt;env&gt; \n└─self = [1:0x20903349b30] \n\n#&gt; █ [1:0x557140f86b08] &lt;env&gt; \n#&gt; └─self = [1:0x557140f86b08]\n\n\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n# Doesn't create a circular list because x is modified in place due to single binding?\n\n\n\n\n\nThe garbage collector frees memory from objects without a referenced name.\n\nx &lt;- 1:3\nx &lt;- 2:4\nrm(x)\n\nThe objects that x was bound to still exist. Use the garbage collector to get rid of them. This actually runs automatically when you need more memory, so you never need to run it yourself.\n\ngc() # it does tell you the memory being used, which can be useful\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1264174 67.6    2640178 141.1  2640178 141.1\nVcells 5825149 44.5   10146329  77.5  8258784  63.1\n\nmem_used()\n\n117.40 MB"
  },
  {
    "objectID": "chapter_02_notes.html#binding-basics",
    "href": "chapter_02_notes.html#binding-basics",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x209008119f8\"\n\nobj_addr(y)\n\n[1] \"0x209008119f8\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c."
  },
  {
    "objectID": "chapter_02_notes.html#copy-on-modify",
    "href": "chapter_02_notes.html#copy-on-modify",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "When does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000020900791BD8&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x0000020900791bd8 -&gt; 0x000002090079d408]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000020900821408&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x20900833368] &lt;list&gt; \n├─[2:0x2090090be38] &lt;dbl&gt; \n├─[3:0x2090090bc78] &lt;dbl&gt; \n└─[4:0x2090090bab8] &lt;dbl&gt; \n \n█ [5:0x2090045c778] &lt;list&gt; \n├─[2:0x2090090be38] \n├─[3:0x2090090bc78] \n└─[6:0x208fd147dd0] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” and then edited.\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x2090095cea8] &lt;chr&gt; \n├─[2:0x208f4da70e0] &lt;string: \"a\"&gt; \n├─[2:0x208f4da70e0] \n├─[3:0x208fcc32a88] &lt;string: \"abc\"&gt; \n└─[4:0x208f93327e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;0000020900015988&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x0000020900015988 -&gt; 0x0000020900145f08]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020900145f08 -&gt; 0x000002090057a228]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x209004258c8] &lt;list&gt; \n├─[2:0x208fd69eb30] &lt;int&gt; \n└─[2:0x208fd69eb30] \n \n█ [3:0x20900640dc8] &lt;list&gt; \n├─[1:0x209004258c8] \n├─[2:0x208fd69eb30] \n└─[4:0x208fd74f0b0] &lt;int&gt;"
  },
  {
    "objectID": "chapter_02_notes.html#object-size",
    "href": "chapter_02_notes.html#object-size",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "How much memory does an object occupy? Use lobstr::obj_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\nAlternative representation means sequences of numbers are all the same size. Only the first and last numbers are stored.\n\nobj_size(1:5)\n\n680 B\n\nobj_size(1:1e6)\n\n680 B\n\n\n\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\n#&gt; 8005648 bytes\nobj_size(y)\n\n80.90 kB\n\n#&gt; 80.90 kB\n\n# obj_size account for alternative representation of sequences.\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n#&gt; 18.76 kB\n\n# The size is \"somewhat misleading\" because the size of lists refers to their names, not their objects?\n\n\na &lt;- runif(1e6)\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\nobj_size(b)\n\n8.00 MB\n\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n24.00 MB\n\n# alt rep sequences are aking up 8 MB, and here we copy-on-modify twice, \n# creating three 8 MB sequences for a total of 24 MB by the last line of code."
  },
  {
    "objectID": "chapter_02_notes.html#modify-in-place",
    "href": "chapter_02_notes.html#modify-in-place",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "There are exceptions to copy-on-modify: single-named environments and objects. Objects with a single binding are performance optimized and environments are always modified in place.\n\nv &lt;- c(1, 2, 3)\nv[[3]] &lt;- 4 # modified in place\n\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nA slow for loop. Slow because the dataframe is being copied 15 times - 3 times per iteration.\n\ncat(tracemem(x), \"\\n\")\n\n&lt;0000020900679238&gt; \n\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\ntracemem[0x0000020900679238 -&gt; 0x0000020904e74c78]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74c78 -&gt; 0x0000020904e74c08]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74c08 -&gt; 0x0000020904e74b98]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74b98 -&gt; 0x0000020904e74b28]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74b28 -&gt; 0x0000020904e74ab8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74ab8 -&gt; 0x0000020904e74a48]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74a48 -&gt; 0x0000020904e749d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e749d8 -&gt; 0x0000020904e74968]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e74968 -&gt; 0x0000020904e748f8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000020904e748f8 -&gt; 0x0000020904e74888]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nUsing a list reduces the number of copies being made\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n\n&lt;00000209056B8AF8&gt; \n\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\ntracemem[0x00000209056b8af8 -&gt; 0x000002090599a4d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nEnvironments are always modified in place. This is referred to as reference semantics. Modifying an environment does not change the existing bindings within an environment.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nChanging a binding means the environment is modified in place. That is, after e1$c is modified, e2$c now points to the same object.\n\ne1$c &lt;- 4\ne2$c\n\n[1] 4\n\n#&gt; [1] 4\n\nEnvironments can contain themselves\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n\n█ [1:0x20903349b30] &lt;env&gt; \n└─self = [1:0x20903349b30] \n\n#&gt; █ [1:0x557140f86b08] &lt;env&gt; \n#&gt; └─self = [1:0x557140f86b08]\n\n\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n# Doesn't create a circular list because x is modified in place due to single binding?"
  },
  {
    "objectID": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "href": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The garbage collector frees memory from objects without a referenced name.\n\nx &lt;- 1:3\nx &lt;- 2:4\nrm(x)\n\nThe objects that x was bound to still exist. Use the garbage collector to get rid of them. This actually runs automatically when you need more memory, so you never need to run it yourself.\n\ngc() # it does tell you the memory being used, which can be useful\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1264174 67.6    2640178 141.1  2640178 141.1\nVcells 5825149 44.5   10146329  77.5  8258784  63.1\n\nmem_used()\n\n117.40 MB"
  },
  {
    "objectID": "chapter_01_notes.html",
    "href": "chapter_01_notes.html",
    "title": "Advanced R - Chapter 1 Notes",
    "section": "",
    "text": "R Pros and Cons\n\nPros\n\nfree, latest statistical techniques, purpose-built packages, community support\n\nCons\n\nslow, inconsistency in packages, focus on results instead of software engineering processes\n\n\n\n\nWhat You Will Learn\n\nUnderstand data types, functions, environments and how to use the condition system\nUnderstand what functional programming means\nKnow about object-oriented systems in R\nUnderstand metaprogramming\nUnderstand what slows R down or uses a lot of memory"
  },
  {
    "objectID": "chapter_03_notes.html",
    "href": "chapter_03_notes.html",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "atomic vectors. elements are all the same type.\nlists (sometimes called generic vectors). elements can vary by type.\n\nAttributes - named list of metadata - dimension turns vectors into matrices and arrays - class powers the S3 object system\n\n\nSection 3.2 introduces you to the atomic vectors: logical, integer, double, and character. These are R’s simplest data structures.\nInteger and double are inconsistently referred to as numeric. There are also two rare types: complex and raw.\nEach of the four primary types has a special syntax to create an individual value (a scalar).\n\n# Logicals\nTRUE\n\n[1] TRUE\n\nT\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nF\n\n[1] FALSE\n\n# Doubles\n0.1234\n\n[1] 0.1234\n\n1.234e-1\n\n[1] 0.1234\n\n## special values unique to double\nInf\n\n[1] Inf\n\n-Inf\n\n[1] -Inf\n\nNaN\n\n[1] NaN\n\n# Integers\n## can be written like a double, but must use L, which represents a long integer in C\n1234L\n\n[1] 1234\n\n1e4L\n\n[1] 10000\n\n# Strings\n## require single or double quotes. special characters escaped with \\\n\"hi there\"\n\n[1] \"hi there\"\n\n\ncombine vectors with c()\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\nc(c(1, 2), c(3, 4))\n\n[1] 1 2 3 4\n\n#&gt; [1] 1 2 3 4\n\n\ntypeof(lgl_var)\n\n[1] \"logical\"\n\n#&gt; [1] \"logical\"\ntypeof(int_var)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\ntypeof(chr_var)\n\n[1] \"character\"\n\n#&gt; [1] \"character\"\n\nmissing values are represented with a sentinal value NA, which are infectious unless some identity holds for all possible inputs\n\nNA &gt; 5\n\n[1] NA\n\n#&gt; [1] NA\n10 * NA\n\n[1] NA\n\n#&gt; [1] NA\n!NA\n\n[1] NA\n\n#&gt; [1] NA\n\nNA ^ 0\n\n[1] 1\n\n#&gt; [1] 1\nNA | TRUE\n\n[1] TRUE\n\n#&gt; [1] TRUE\nNA & FALSE\n\n[1] FALSE\n\n#&gt; [1] FALSE\n\n\n# which values are missing? use is.na()\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n\n[1] NA NA NA NA\n\n#&gt; [1] NA NA NA NA\n\nis.na(x)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n# There are four missing values, one for each atomic vector type\n\nvectors always have one type and will be coerced in a standard order to a single type if you combine multiple vectors of different types: character → double → integer → logical.\n\nstr(c(\"a\", 1))\n\n chr [1:2] \"a\" \"1\"\n\n#&gt;  chr [1:2] \"a\" \"1\"\n\nmathematical functions coerce logicals into 0 and 1\n\nx &lt;- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n\n[1] 0 0 1\n\n#&gt; [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n\n[1] 1\n\n#&gt; [1] 1\n\n# Proportion that are TRUE\nmean(x)\n\n[1] 0.3333333\n\n#&gt; [1] 0.333\n\nForce coercion with the corresponding as.* function\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  1 NA\n\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\n\nc(1, FALSE)\n\n[1] 1 0\n\nc(\"a\", 1)\n\n[1] \"a\" \"1\"\n\nc(TRUE, 1L)\n\n[1] 1 1\n\n\n\n\n\n\nSection 3.3 takes a small detour to discuss attributes, R’s flexible metadata specification. The most important attributes are names, dimensions, and class.\nHow does the dim attribute make matrices and arrays?\nAttributes can be though of as name-value pairs. Retrieved with attr(), en masse with attributes(), and set en masse with structure().\n\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n\n[1] \"abcdef\"\n\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na &lt;- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\nAttributes are generally ephemeral.\n\nattributes(a[1])\n\nNULL\n\n#&gt; NULL\nattributes(sum(a))\n\nNULL\n\n#&gt; NULL\n\nThere are two exceptions: - names, a character vector giving each element a name - dim, short for dimensions, an integer vector, used to turn vectors into matrices or arrays.\nName a vector in three ways:\n\n# When creating it: \nx &lt;- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\nAdding a dim attribute allows a vector to behave like a 2-d matrix or a multidimensional array.\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\n\nstr(1:3)                   # 1d vector\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n\n int [1:3, 1] 1 2 3\n\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n\n int [1, 1:3] 1 2 3\n\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n\n int [1:3(1d)] 1 2 3\n\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\n\n# What are these and how do they differ from 1:5?\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))\n\n\n\n\n\nSection 3.4 discusses the important vector types that are built by combining atomic vectors with special attributes. These include factors, dates, date-times, and durations.\nAn important vector attribute is class. Having a class attribute turns an object into an S3 object, which means will behave differently than a normal vector when passed to a generic function.\nNote that factors are built on Integer vectors, and POSIXct and Date vectors are built on Double vectors.\nFactors are vectors with only pre-defined values, defined by the attributes class and levels.\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n[1] a b b a\nLevels: a b\n\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\nattributes(x)\n\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\nFactors will give counts of unobserved levels in functions like table(), unlike character vectors.\n\nsex_char &lt;- c(\"m\", \"m\", \"m\")\nsex_factor &lt;- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\n#&gt; sex_char\n#&gt; m \n#&gt; 3\ntable(sex_factor)\n\nsex_factor\nm f \n3 0 \n\n#&gt; sex_factor\n#&gt; m f \n#&gt; 3 0\n\nOrdered factors for when order of the levels is meaningful\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n\n[1] b b a c\nLevels: c &lt; b &lt; a\n\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nFactors are coerced in different ways by different functions - sometimes to strings, and sometimes the underlying integer values are used.\nDates are built on top of double vectors and have class “Date” and no other attributes.\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(today)\n\n$class\n[1] \"Date\"\n\n#&gt; $class\n#&gt; [1] \"Date\"\n\nYou can see the value of the double by stripping the class\n\ndate &lt;- as.Date(\"1970-02-01\")\nunclass(date)\n\n[1] 31\n\n#&gt; [1] 31\n\nDate-Times in base R are built on top of Double vectors. One type is POSIXct.\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n\n[1] \"2018-08-01 22:00:00 UTC\"\n\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(now_ct)\n\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntime zones change printing, not the instant of time represented\n\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n\n[1] \"2018-08-02 07:00:00 JST\"\n\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n\n[1] \"2018-08-01 18:00:00 EDT\"\n\n#&gt; [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n\n[1] \"2018-08-02 08:30:00 +1030\"\n\n#&gt; [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n\n[1] \"2018-08-02 CEST\"\n\n#&gt; [1] \"2018-08-02 CEST\"\n\nDurations are stored in difftimes, which are built on top of doubles and have a units attribute that determines how differences should be interpreted.\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n\nTime difference of 1 weeks\n\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_1)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"weeks\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n\nTime difference of 7 days\n\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_2)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"days\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\ntable(letters)\n\nletters\na b c d e f g h i j k l m n o p q r s t u v w x y z \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n\ntypeof(table(letters))\n\n[1] \"integer\"\n\nattributes((table(letters)))\n\n$dim\n[1] 26\n\n$dimnames\n$dimnames$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n$class\n[1] \"table\"\n\n\n\n# what happens to a factor when you modify levels?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\n# How do these differ from f1?\n\nf2 &lt;- rev(factor(letters))\n\nf3 &lt;- factor(letters, levels = rev(letters))\n\n\n\n\n\nSection 3.5 dives into lists. Lists are very similar to atomic vectors, but have one key difference: an element of a list can be any data type, including another list. This makes them suitable for representing hierarchical data.\nConstruct a list with list():\n\nl1 &lt;- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nstr(l1)\n\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\nElements of a list are references and therefore do not take up as much space as you might imagine:\n\nlobstr::obj_size(mtcars)\n\n7.21 kB\n\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n\n7.29 kB\n\n#&gt; 7.29 kB\n\nLists are sometimes called recursive vectors because they can contain other lists.\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\nc() coerces the vectors to a list, and then flattens everything into one list\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\nTesting and coercion - test with is.list() and coerce with as.list().\n\nlist(1:3)\n\n[[1]]\n[1] 1 2 3\n\n#&gt; [[1]]\n#&gt; [1] 1 2 3\nas.list(1:3)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\nMatrices and arrays\nThe dimension attribute can be used to create list-matrices or list-arrays:\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n\n     [,1]      [,2]\n[1,] integer,3 TRUE\n[2,] \"a\"       1   \n\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\n\n\n\nSection 3.6 teaches you about data frames and tibbles, which are used to represent rectangular data. They combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.\nData frames and tibbles are built on top of lists.\nA data frame is a named list of vectors with attributes for (column) names, row.names, and its class, “data.frame”:\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df1)\n\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nA data frame has rownames() and colnames(). The names() of a data frame are the column names.\nA data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns.\nTibbles are lazy and the class vector is longer, and includes tbl_df.\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df2)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\nCreate a data frame with name-vector pairs:\n\ndf &lt;- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n\n'data.frame':   3 obs. of  2 variables:\n $ x: int  1 2 3\n $ y: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\nCreate a tibble in the same way.\n\ndf2 &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n\ntibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\nTibbles don’t change non-syntactic names. Data frames do.\n\nnames(data.frame(`1` = 1))\n\n[1] \"X1\"\n\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n\n[1] \"1\"\n\n#&gt; [1] \"1\"\n\nTibbles will only recycle vectors of length 1\n\ndata.frame(x = 1:4, y = 1:2)\n\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\n\n#data.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of\n#&gt; rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n\n# A tibble: 4 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     1\n2     2     1\n3     3     1\n4     4     1\n\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\n\n\n# tibble(x = 1:4, y = 1:2)\n#&gt; Error in tibble(x = 1:4, y = 1:2): Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\nA tibble can refer to variables created during construction. Data frames cannot.\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n\n# A tibble: 3 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     2\n2     2     4\n3     3     6\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\nData frames allow row names. This is a character vector with unique values.\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\n\nrownames(df3)\n\n[1] \"Bob\"   \"Susan\" \"Sam\"  \n\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n\n    age  hair\nBob  35 blond\n\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\nTibbles do not support rownames, but can easily convert them to a column in the tibble:\n\nas_tibble(df3, rownames = \"name\")\n\n# A tibble: 3 × 3\n  name    age hair \n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n\n#&gt; # A tibble: 3 × 3\n#&gt;   name    age hair \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Bob      35 blond\n#&gt; 2 Susan    27 brown\n#&gt; 3 Sam      18 black\n\nSubsetting differs by data frames and tibbles. Tibbles always return a tibble when subsetting, and no partial matching is allowed with column names.\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n\n chr \"a\"\n\n#&gt;  chr \"a\"\nstr(df2$x)\n\nWarning: Unknown or uninitialised column: `x`.\n\n\n NULL\n\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt;  NULL\n\nExtract single columns with df[[\"col\"]].\n\nis.data.frame(df1)\n\n[1] TRUE\n\n#&gt; [1] TRUE\nis.data.frame(df2) # this is a tibble and it passes this test.\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nIf you want to distinguish:\n\nis_tibble(df1)\n\n[1] FALSE\n\n#&gt; [1] FALSE\nis_tibble(df2)\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nList Columns - since a data frame or a tibble is a list, it can contain other lists.\n\n# extra work is required to add a list to a data frame - either after creation or using I()\n\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\nList columns are easier to use in a tibble.\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n\n# A tibble: 3 × 2\n      x y        \n  &lt;int&gt; &lt;list&gt;   \n1     1 &lt;int [2]&gt;\n2     2 &lt;int [3]&gt;\n3     3 &lt;int [4]&gt;\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\nMatrix and data frame columns are possible, but not advised. The NROW() og the matrix must match the data frame number of rows.\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n\n'data.frame':   3 obs. of  3 variables:\n $ x: num  10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':  3 obs. of  2 variables:\n  ..$ a: int  3 2 1\n  ..$ b: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\"\n\n\n\n\nAlways length zero, and cannot have attributes. A unique type.\n\ntypeof(NULL)\n\n[1] \"NULL\"\n\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n\n[1] 0\n\n#&gt; [1] 0\n\nx &lt;- NULL\n# attr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL\n\nNULL represents an absent vector, whereas NA represents an absent element. NULL can be useful in default function arguments."
  },
  {
    "objectID": "chapter_03_notes.html#atomic-vectors",
    "href": "chapter_03_notes.html#atomic-vectors",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.2 introduces you to the atomic vectors: logical, integer, double, and character. These are R’s simplest data structures.\nInteger and double are inconsistently referred to as numeric. There are also two rare types: complex and raw.\nEach of the four primary types has a special syntax to create an individual value (a scalar).\n\n# Logicals\nTRUE\n\n[1] TRUE\n\nT\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nF\n\n[1] FALSE\n\n# Doubles\n0.1234\n\n[1] 0.1234\n\n1.234e-1\n\n[1] 0.1234\n\n## special values unique to double\nInf\n\n[1] Inf\n\n-Inf\n\n[1] -Inf\n\nNaN\n\n[1] NaN\n\n# Integers\n## can be written like a double, but must use L, which represents a long integer in C\n1234L\n\n[1] 1234\n\n1e4L\n\n[1] 10000\n\n# Strings\n## require single or double quotes. special characters escaped with \\\n\"hi there\"\n\n[1] \"hi there\"\n\n\ncombine vectors with c()\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\nc(c(1, 2), c(3, 4))\n\n[1] 1 2 3 4\n\n#&gt; [1] 1 2 3 4\n\n\ntypeof(lgl_var)\n\n[1] \"logical\"\n\n#&gt; [1] \"logical\"\ntypeof(int_var)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\ntypeof(chr_var)\n\n[1] \"character\"\n\n#&gt; [1] \"character\"\n\nmissing values are represented with a sentinal value NA, which are infectious unless some identity holds for all possible inputs\n\nNA &gt; 5\n\n[1] NA\n\n#&gt; [1] NA\n10 * NA\n\n[1] NA\n\n#&gt; [1] NA\n!NA\n\n[1] NA\n\n#&gt; [1] NA\n\nNA ^ 0\n\n[1] 1\n\n#&gt; [1] 1\nNA | TRUE\n\n[1] TRUE\n\n#&gt; [1] TRUE\nNA & FALSE\n\n[1] FALSE\n\n#&gt; [1] FALSE\n\n\n# which values are missing? use is.na()\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n\n[1] NA NA NA NA\n\n#&gt; [1] NA NA NA NA\n\nis.na(x)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n# There are four missing values, one for each atomic vector type\n\nvectors always have one type and will be coerced in a standard order to a single type if you combine multiple vectors of different types: character → double → integer → logical.\n\nstr(c(\"a\", 1))\n\n chr [1:2] \"a\" \"1\"\n\n#&gt;  chr [1:2] \"a\" \"1\"\n\nmathematical functions coerce logicals into 0 and 1\n\nx &lt;- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n\n[1] 0 0 1\n\n#&gt; [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n\n[1] 1\n\n#&gt; [1] 1\n\n# Proportion that are TRUE\nmean(x)\n\n[1] 0.3333333\n\n#&gt; [1] 0.333\n\nForce coercion with the corresponding as.* function\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  1 NA\n\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\n\nc(1, FALSE)\n\n[1] 1 0\n\nc(\"a\", 1)\n\n[1] \"a\" \"1\"\n\nc(TRUE, 1L)\n\n[1] 1 1"
  },
  {
    "objectID": "chapter_03_notes.html#attributes",
    "href": "chapter_03_notes.html#attributes",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.3 takes a small detour to discuss attributes, R’s flexible metadata specification. The most important attributes are names, dimensions, and class.\nHow does the dim attribute make matrices and arrays?\nAttributes can be though of as name-value pairs. Retrieved with attr(), en masse with attributes(), and set en masse with structure().\n\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n\n[1] \"abcdef\"\n\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na &lt;- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\nAttributes are generally ephemeral.\n\nattributes(a[1])\n\nNULL\n\n#&gt; NULL\nattributes(sum(a))\n\nNULL\n\n#&gt; NULL\n\nThere are two exceptions: - names, a character vector giving each element a name - dim, short for dimensions, an integer vector, used to turn vectors into matrices or arrays.\nName a vector in three ways:\n\n# When creating it: \nx &lt;- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\nAdding a dim attribute allows a vector to behave like a 2-d matrix or a multidimensional array.\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\n\nstr(1:3)                   # 1d vector\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n\n int [1:3, 1] 1 2 3\n\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n\n int [1, 1:3] 1 2 3\n\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n\n int [1:3(1d)] 1 2 3\n\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\n\n# What are these and how do they differ from 1:5?\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))"
  },
  {
    "objectID": "chapter_03_notes.html#s3-atomic-vectors",
    "href": "chapter_03_notes.html#s3-atomic-vectors",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.4 discusses the important vector types that are built by combining atomic vectors with special attributes. These include factors, dates, date-times, and durations.\nAn important vector attribute is class. Having a class attribute turns an object into an S3 object, which means will behave differently than a normal vector when passed to a generic function.\nNote that factors are built on Integer vectors, and POSIXct and Date vectors are built on Double vectors.\nFactors are vectors with only pre-defined values, defined by the attributes class and levels.\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n[1] a b b a\nLevels: a b\n\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\nattributes(x)\n\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\nFactors will give counts of unobserved levels in functions like table(), unlike character vectors.\n\nsex_char &lt;- c(\"m\", \"m\", \"m\")\nsex_factor &lt;- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\n#&gt; sex_char\n#&gt; m \n#&gt; 3\ntable(sex_factor)\n\nsex_factor\nm f \n3 0 \n\n#&gt; sex_factor\n#&gt; m f \n#&gt; 3 0\n\nOrdered factors for when order of the levels is meaningful\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n\n[1] b b a c\nLevels: c &lt; b &lt; a\n\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nFactors are coerced in different ways by different functions - sometimes to strings, and sometimes the underlying integer values are used.\nDates are built on top of double vectors and have class “Date” and no other attributes.\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(today)\n\n$class\n[1] \"Date\"\n\n#&gt; $class\n#&gt; [1] \"Date\"\n\nYou can see the value of the double by stripping the class\n\ndate &lt;- as.Date(\"1970-02-01\")\nunclass(date)\n\n[1] 31\n\n#&gt; [1] 31\n\nDate-Times in base R are built on top of Double vectors. One type is POSIXct.\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n\n[1] \"2018-08-01 22:00:00 UTC\"\n\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(now_ct)\n\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntime zones change printing, not the instant of time represented\n\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n\n[1] \"2018-08-02 07:00:00 JST\"\n\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n\n[1] \"2018-08-01 18:00:00 EDT\"\n\n#&gt; [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n\n[1] \"2018-08-02 08:30:00 +1030\"\n\n#&gt; [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n\n[1] \"2018-08-02 CEST\"\n\n#&gt; [1] \"2018-08-02 CEST\"\n\nDurations are stored in difftimes, which are built on top of doubles and have a units attribute that determines how differences should be interpreted.\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n\nTime difference of 1 weeks\n\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_1)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"weeks\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n\nTime difference of 7 days\n\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_2)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"days\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\ntable(letters)\n\nletters\na b c d e f g h i j k l m n o p q r s t u v w x y z \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n\ntypeof(table(letters))\n\n[1] \"integer\"\n\nattributes((table(letters)))\n\n$dim\n[1] 26\n\n$dimnames\n$dimnames$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n$class\n[1] \"table\"\n\n\n\n# what happens to a factor when you modify levels?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\n# How do these differ from f1?\n\nf2 &lt;- rev(factor(letters))\n\nf3 &lt;- factor(letters, levels = rev(letters))"
  },
  {
    "objectID": "chapter_03_notes.html#lists",
    "href": "chapter_03_notes.html#lists",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.5 dives into lists. Lists are very similar to atomic vectors, but have one key difference: an element of a list can be any data type, including another list. This makes them suitable for representing hierarchical data.\nConstruct a list with list():\n\nl1 &lt;- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nstr(l1)\n\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\nElements of a list are references and therefore do not take up as much space as you might imagine:\n\nlobstr::obj_size(mtcars)\n\n7.21 kB\n\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n\n7.29 kB\n\n#&gt; 7.29 kB\n\nLists are sometimes called recursive vectors because they can contain other lists.\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\nc() coerces the vectors to a list, and then flattens everything into one list\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\nTesting and coercion - test with is.list() and coerce with as.list().\n\nlist(1:3)\n\n[[1]]\n[1] 1 2 3\n\n#&gt; [[1]]\n#&gt; [1] 1 2 3\nas.list(1:3)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\nMatrices and arrays\nThe dimension attribute can be used to create list-matrices or list-arrays:\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n\n     [,1]      [,2]\n[1,] integer,3 TRUE\n[2,] \"a\"       1   \n\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3"
  },
  {
    "objectID": "chapter_03_notes.html#data-frames-and-tibbles",
    "href": "chapter_03_notes.html#data-frames-and-tibbles",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.6 teaches you about data frames and tibbles, which are used to represent rectangular data. They combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.\nData frames and tibbles are built on top of lists.\nA data frame is a named list of vectors with attributes for (column) names, row.names, and its class, “data.frame”:\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df1)\n\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nA data frame has rownames() and colnames(). The names() of a data frame are the column names.\nA data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns.\nTibbles are lazy and the class vector is longer, and includes tbl_df.\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df2)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\nCreate a data frame with name-vector pairs:\n\ndf &lt;- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n\n'data.frame':   3 obs. of  2 variables:\n $ x: int  1 2 3\n $ y: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\nCreate a tibble in the same way.\n\ndf2 &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n\ntibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\nTibbles don’t change non-syntactic names. Data frames do.\n\nnames(data.frame(`1` = 1))\n\n[1] \"X1\"\n\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n\n[1] \"1\"\n\n#&gt; [1] \"1\"\n\nTibbles will only recycle vectors of length 1\n\ndata.frame(x = 1:4, y = 1:2)\n\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\n\n#data.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of\n#&gt; rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n\n# A tibble: 4 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     1\n2     2     1\n3     3     1\n4     4     1\n\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\n\n\n# tibble(x = 1:4, y = 1:2)\n#&gt; Error in tibble(x = 1:4, y = 1:2): Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\nA tibble can refer to variables created during construction. Data frames cannot.\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n\n# A tibble: 3 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     2\n2     2     4\n3     3     6\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\nData frames allow row names. This is a character vector with unique values.\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\n\nrownames(df3)\n\n[1] \"Bob\"   \"Susan\" \"Sam\"  \n\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n\n    age  hair\nBob  35 blond\n\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\nTibbles do not support rownames, but can easily convert them to a column in the tibble:\n\nas_tibble(df3, rownames = \"name\")\n\n# A tibble: 3 × 3\n  name    age hair \n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n\n#&gt; # A tibble: 3 × 3\n#&gt;   name    age hair \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Bob      35 blond\n#&gt; 2 Susan    27 brown\n#&gt; 3 Sam      18 black\n\nSubsetting differs by data frames and tibbles. Tibbles always return a tibble when subsetting, and no partial matching is allowed with column names.\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n\n chr \"a\"\n\n#&gt;  chr \"a\"\nstr(df2$x)\n\nWarning: Unknown or uninitialised column: `x`.\n\n\n NULL\n\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt;  NULL\n\nExtract single columns with df[[\"col\"]].\n\nis.data.frame(df1)\n\n[1] TRUE\n\n#&gt; [1] TRUE\nis.data.frame(df2) # this is a tibble and it passes this test.\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nIf you want to distinguish:\n\nis_tibble(df1)\n\n[1] FALSE\n\n#&gt; [1] FALSE\nis_tibble(df2)\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nList Columns - since a data frame or a tibble is a list, it can contain other lists.\n\n# extra work is required to add a list to a data frame - either after creation or using I()\n\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\nList columns are easier to use in a tibble.\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n\n# A tibble: 3 × 2\n      x y        \n  &lt;int&gt; &lt;list&gt;   \n1     1 &lt;int [2]&gt;\n2     2 &lt;int [3]&gt;\n3     3 &lt;int [4]&gt;\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\nMatrix and data frame columns are possible, but not advised. The NROW() og the matrix must match the data frame number of rows.\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n\n'data.frame':   3 obs. of  3 variables:\n $ x: num  10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':  3 obs. of  2 variables:\n  ..$ a: int  3 2 1\n  ..$ b: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\""
  },
  {
    "objectID": "chapter_03_notes.html#null",
    "href": "chapter_03_notes.html#null",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Always length zero, and cannot have attributes. A unique type.\n\ntypeof(NULL)\n\n[1] \"NULL\"\n\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n\n[1] 0\n\n#&gt; [1] 0\n\nx &lt;- NULL\n# attr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL\n\nNULL represents an absent vector, whereas NA represents an absent element. NULL can be useful in default function arguments."
  },
  {
    "objectID": "chapter_05_notes.html",
    "href": "chapter_05_notes.html",
    "title": "Advanced R - Chapter 5 Notes",
    "section": "",
    "text": "Choices. Run different code depending on input.\nLoops. Repeatedly run code, typically with changing options.\n\n\n\nSection 5.2 dives into the details of if, then discusses the close relatives ifelse() and switch().\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\n\ngrade &lt;- function(x) {\n  if (x &gt; 90) {\n    \"A\"\n  } else if (x &gt; 80) {\n    \"B\"\n  } else if (x &gt; 50) {\n    \"C\"\n  } else {\n    \"F\"\n  }\n}\n\n\nx1 &lt;- if (TRUE) 1 else 2\nx2 &lt;- if (FALSE) 1 else 2\n\nc(x1, x2)\n\n[1] 1 2\n\n#&gt; [1] 1 2\n\n\ngreet &lt;- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n\n[1] \"Hi Maria\"\n\n#&gt; [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n\n[1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\n#&gt; [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\nThe condition should evaluate to a single TRUE or FALSE\n\n# if (\"x\") 1\n# #&gt; Error in if (\"x\") 1: argument is not interpretable as logical\n# if (logical()) 1\n# #&gt; Error in if (logical()) 1: argument is of length zero\n# if (NA) 1\n# #&gt; Error in if (NA) 1: missing value where TRUE/FALSE needed\n# if (c(TRUE, FALSE)) 1\n# #&gt; Error in if (c(TRUE, FALSE)) 1: the condition has length &gt; 1\n\nVectorized if\nWhat if you have more than one TRUE or FALSE value?\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\n#&gt;  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n#&gt;  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\ndplyr::case_when is another vectorized if\n\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n\n [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\n#&gt;  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\nif() statements can be made more compact with switch()\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    # The last component of a switch() should always throw \n    # an error, otherwise unmatched inputs will invisibly return NULL\n    stop(\"Invalid `x` value\") \n  )\n}\n\nIf multiple inputs have the same output, you can leave the RHS of = empty until the last input with the same output\n\nlegs &lt;- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n\n[1] 4\n\n#&gt; [1] 4\nlegs(\"dog\")\n\n[1] 4\n\n#&gt; [1] 4\n\n\n\n\nSection 5.3 starts off by reminding you of the basic structure of the for loop in R, discusses some common pitfalls, and then talks about the related while and repeat statements.\nBasic structure: for (item in vector) perform_action\n\nfor (i in 1:3) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n\nN.B.: for assigns the item to the current environment, overwriting any existing variable with the same name:\n\ni &lt;- 100\nfor (i in 1:3) {}\ni\n\n[1] 3\n\n#&gt; [1] 3\n\nYou can use next to exit the current iteration and break to exit the entire for loop.\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\nCommon Pitfalls when using for loops\n\nIf you are generating data, pre-allocate the output container. This improves speed.\n\n\nmeans &lt;- c(1, 50, 20)\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n\nBeware of iterating over 1:length(x), which will fail in unhelpful ways if x has length 0.\n\n\n# means &lt;- c()\n# out &lt;- vector(\"list\", length(means))\n# for (i in 1:length(means)) {\n#   out[[i]] &lt;- rnorm(10, means[[i]])\n# }\n# #&gt; Error in rnorm(10, means[[i]]): invalid arguments\n\nUse seq_along() instead.\n\nseq_along(means)\n\n[1] 1 2 3\n\n#&gt; integer(0)\n\nout &lt;- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n\nCall [[ yourself when iterating over S3 vectors, as loops typically strip the attributes\n\n\nxs &lt;- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n\n[1] 18262\n[1] 14610\n\n#&gt; [1] 18262\n#&gt; [1] 14610\n\nHere’s the fix:\n\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n\n[1] \"2020-01-01\"\n[1] \"2010-01-01\"\n\n#&gt; [1] \"2020-01-01\"\n#&gt; [1] \"2010-01-01\""
  },
  {
    "objectID": "chapter_05_notes.html#choices",
    "href": "chapter_05_notes.html#choices",
    "title": "Advanced R - Chapter 5 Notes",
    "section": "",
    "text": "Section 5.2 dives into the details of if, then discusses the close relatives ifelse() and switch().\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\n\ngrade &lt;- function(x) {\n  if (x &gt; 90) {\n    \"A\"\n  } else if (x &gt; 80) {\n    \"B\"\n  } else if (x &gt; 50) {\n    \"C\"\n  } else {\n    \"F\"\n  }\n}\n\n\nx1 &lt;- if (TRUE) 1 else 2\nx2 &lt;- if (FALSE) 1 else 2\n\nc(x1, x2)\n\n[1] 1 2\n\n#&gt; [1] 1 2\n\n\ngreet &lt;- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n\n[1] \"Hi Maria\"\n\n#&gt; [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n\n[1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\n#&gt; [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\nThe condition should evaluate to a single TRUE or FALSE\n\n# if (\"x\") 1\n# #&gt; Error in if (\"x\") 1: argument is not interpretable as logical\n# if (logical()) 1\n# #&gt; Error in if (logical()) 1: argument is of length zero\n# if (NA) 1\n# #&gt; Error in if (NA) 1: missing value where TRUE/FALSE needed\n# if (c(TRUE, FALSE)) 1\n# #&gt; Error in if (c(TRUE, FALSE)) 1: the condition has length &gt; 1\n\nVectorized if\nWhat if you have more than one TRUE or FALSE value?\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\n#&gt;  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n#&gt;  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\ndplyr::case_when is another vectorized if\n\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n\n [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\n#&gt;  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\nif() statements can be made more compact with switch()\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    # The last component of a switch() should always throw \n    # an error, otherwise unmatched inputs will invisibly return NULL\n    stop(\"Invalid `x` value\") \n  )\n}\n\nIf multiple inputs have the same output, you can leave the RHS of = empty until the last input with the same output\n\nlegs &lt;- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n\n[1] 4\n\n#&gt; [1] 4\nlegs(\"dog\")\n\n[1] 4\n\n#&gt; [1] 4"
  },
  {
    "objectID": "chapter_05_notes.html#loops",
    "href": "chapter_05_notes.html#loops",
    "title": "Advanced R - Chapter 5 Notes",
    "section": "",
    "text": "Section 5.3 starts off by reminding you of the basic structure of the for loop in R, discusses some common pitfalls, and then talks about the related while and repeat statements.\nBasic structure: for (item in vector) perform_action\n\nfor (i in 1:3) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n\nN.B.: for assigns the item to the current environment, overwriting any existing variable with the same name:\n\ni &lt;- 100\nfor (i in 1:3) {}\ni\n\n[1] 3\n\n#&gt; [1] 3\n\nYou can use next to exit the current iteration and break to exit the entire for loop.\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\nCommon Pitfalls when using for loops\n\nIf you are generating data, pre-allocate the output container. This improves speed.\n\n\nmeans &lt;- c(1, 50, 20)\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n\nBeware of iterating over 1:length(x), which will fail in unhelpful ways if x has length 0.\n\n\n# means &lt;- c()\n# out &lt;- vector(\"list\", length(means))\n# for (i in 1:length(means)) {\n#   out[[i]] &lt;- rnorm(10, means[[i]])\n# }\n# #&gt; Error in rnorm(10, means[[i]]): invalid arguments\n\nUse seq_along() instead.\n\nseq_along(means)\n\n[1] 1 2 3\n\n#&gt; integer(0)\n\nout &lt;- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n\nCall [[ yourself when iterating over S3 vectors, as loops typically strip the attributes\n\n\nxs &lt;- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n\n[1] 18262\n[1] 14610\n\n#&gt; [1] 18262\n#&gt; [1] 14610\n\nHere’s the fix:\n\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n\n[1] \"2020-01-01\"\n[1] \"2010-01-01\"\n\n#&gt; [1] \"2020-01-01\"\n#&gt; [1] \"2010-01-01\""
  },
  {
    "objectID": "chapter_07_notes.html",
    "href": "chapter_07_notes.html",
    "title": "Advanced R - Chapter 7 Notes",
    "section": "",
    "text": "Section 7.2 introduces you to the basic properties of an environment and shows you how to create your own.\nAn environment is similar to a named list, with four exceptions: 1. every name must be unique 2. the names in an environment are not ordered. 3. An enviornment has a parent. 4. Environments are not copied when modified\nTo create an environment, use rlang::env().\n\nlibrary(rlang)\n\ne1 &lt;- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n\nThe job of an environment is to bind a set of names to a set of values.\nEnvironments can contain themselves:\n\ne1$d &lt;- e1\n\nenv_print(e1) # note the env in d\n\n&lt;environment: 0x000002eb1ac5a7e0&gt;\nParent: &lt;environment: global&gt;\nBindings:\n• a: &lt;lgl&gt;\n• b: &lt;chr&gt;\n• c: &lt;dbl&gt;\n• d: &lt;env&gt;\n\n\n\n# get the names of an environment\nenv_names(e1)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\n# find out what the current environment is\ncurrent_env()\n\n&lt;environment: R_GlobalEnv&gt;\n\n# or use environment()\nenvironment()\n\n&lt;environment: R_GlobalEnv&gt;\n\n# compare environments with identical()\nidentical(global_env(), current_env())\n\n[1] TRUE\n\n\nEvery environment has a parent. Set the parent by supplying an unnamed argument to env(). The parent is what’s used to implement lexical scoping.\n\ne2a &lt;- env(d = 4, e = 5)\ne2b &lt;- env(e2a, a = 1, b = 2, c = 3)\n\nenv_parent(e2a)\n\n&lt;environment: R_GlobalEnv&gt;\n\nenv_parent(e2b)\n\n&lt;environment: 0x000002eb17d965f0&gt;\n\n\nOnly the empty environment doesn’t have a parent\n\ne2c &lt;- env(empty_env(), d = 4, e = 5)\ne2d &lt;- env(e2c, a = 1, b = 2, c = 3)\n\ne2c &lt;- env(empty_env(), d = 4, e = 5)\ne2d &lt;- env(e2c, a = 1, b = 2, c = 3)\n\nenv_parents(e2b)\n\n[[1]]   &lt;env: 0x000002eb17d965f0&gt;\n[[2]] $ &lt;env: global&gt;\n\n#&gt; [[1]]   &lt;env: 0x559735c4a248&gt;\n#&gt; [[2]] $ &lt;env: global&gt;\nenv_parents(e2d)\n\n[[1]]   &lt;env: 0x000002eb19536660&gt;\n[[2]] $ &lt;env: empty&gt;\n\n#&gt; [[1]]   &lt;env: 0x5597366d1bf8&gt;\n#&gt; [[2]] $ &lt;env: empty&gt;\n\nenv_parents() stops when it gets to the global environment.\nSuper assignment\n&lt;&lt;- never creates a variable in the current environment, but instead modifies an existing variable found in a parent environment.\n\nx &lt;- 0\nf &lt;- function() {\n  x &lt;&lt;- 1\n}\nf()\nx\n\n[1] 1\n\n#&gt; [1] 1\n\nGetting and setting elements of an environment\n\ne3 &lt;- env(x = 1, y = 2)\ne3$x\n\n[1] 1\n\n#&gt; [1] 1\ne3$z &lt;- 3\ne3[[\"z\"]]\n\n[1] 3\n\n#&gt; [1] 3\n\nYou can’t subset with numeric indices and you can’t use [\n\n# e3[[1]]\n# #&gt; Error in e3[[1]]: wrong arguments for subsetting an environment\n\n# e3[c(\"x\", \"y\")]\n# #&gt; Error in e3[c(\"x\", \"y\")]: object of type 'environment' is not subsettable\n\nOther ways to add bindings to an environment:\n\nenv_poke(e3, \"a\", 100)\ne3$a\n\n[1] 100\n\n#&gt; [1] 100\n\nenv_bind() allows binding of multiple values\n\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n\n[1] \"x\" \"y\" \"z\" \"a\" \"b\"\n\n#&gt; [1] \"x\" \"y\" \"z\" \"a\" \"b\"\n\n\nenv_has(e3, \"a\")\n\n   a \nTRUE \n\n#&gt;    a \n#&gt; TRUE\n\n# To unbind:\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n\n    a \nFALSE \n\n\nAdvanced bindings\n`env_bind_lazy() creates delayed bindings, which are evaluated the first time they are acessed. Delayed bindings create promises. See how the value is computed once, the first time it is accessed, then it is cached and returned immediately upon later calls.\n\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n\n[1] 1\n\n\n   user  system elapsed \n   0.00    0.00    1.01 \n\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;       0       0       1\nsystem.time(print(b))\n\n[1] 1\n\n\n   user  system elapsed \n      0       0       0 \n\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;       0       0       0\n\nThe primary use for delayed bindings is in autoload(), which allows R packages to provide datasets that behave like they are loaded in memory, even though they’re only loaded from disk when needed.\nenv_bind_active() creates active bindings, which are recomputed every time they’re accessed:\n\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n\n[1] 0.3944286\n\n#&gt; [1] 0.0808\nz1\n\n[1] 0.4796495\n\n#&gt; [1] 0.834\n\n\n\n\nSection 7.3 provides a function template for computing with environments, illustrating the idea with a useful function.\nFor example, you could search for the name of function and start the search at a child environment.\n\nwhere &lt;- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n\nIllustrate the cases where a name can’t be found, where it is found, and then where it is recursively searched for:\n\n# where(\"yyy\")\n# #&gt; Error: Can't find yyy\n\nx &lt;- 5\nwhere(\"x\")\n\n&lt;environment: R_GlobalEnv&gt;\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nwhere(\"mean\")\n\n&lt;environment: base&gt;\n\n#&gt; &lt;environment: base&gt;\n\nYou could rewrite where() as a for loop instead of a recursive function:\n\nf2 &lt;- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # success case\n      return()\n    }\n    # inspect parent\n    env &lt;- env_parent(env)\n  }\n\n  # base case\n}\n\n\n\n\nSection 7.4 describes environments used for special purposes: for packages, within functions, for namespaces, and for function execution.\nEach package attached by library() or require() becomes one of the parents of the global environment. Packages loaded (not attached) with :: do not become parents. The immediate parent of the global environment is the last package you attached., the parent of that package is the second to last package you attached.\nFollow all the packages back in the order in which they were attached - this gives the search path.\n\n# You can see the names of these environments with:\n\nbase::search()\n\n [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n [4] \"package:graphics\"  \"package:grDevices\" \"package:datasets\" \n [7] \"renv:shims\"        \"package:utils\"     \"package:methods\"  \n[10] \"Autoloads\"         \"package:base\"     \n\nrlang::search_envs()\n\n [[1]] $ &lt;env: global&gt;\n [[2]] $ &lt;env: package:rlang&gt;\n [[3]] $ &lt;env: package:stats&gt;\n [[4]] $ &lt;env: package:graphics&gt;\n [[5]] $ &lt;env: package:grDevices&gt;\n [[6]] $ &lt;env: package:datasets&gt;\n [[7]] $ &lt;env: renv:shims&gt;\n [[8]] $ &lt;env: package:utils&gt;\n [[9]] $ &lt;env: package:methods&gt;\n[[10]] $ &lt;env: Autoloads&gt;\n[[11]] $ &lt;env: package:base&gt;\n\n\nThe last two environments on the search path are always the same: 1. The Autoloads() environment uses delayed bindings to save memory by only loading package objects (like big datasets) when needed. 2. The base environment. It is special because it has to be able to bootstrap the loading of all other packages. You can access it directly with base_env().\nThe function environment\nA function binds the current environment. Functions that capture their environments are called closures. Sometimes the word function and closure are used interchangeably in R documentation.\nGet the function environment:\n\ny &lt;- 1\nf &lt;- function(x) x + y\nfn_env(f)\n\n&lt;environment: R_GlobalEnv&gt;\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nf() binds the environment that binds the name f to the function. Not always the case. In the code below, g() binds the global environment, but g is bound in a new environment e().\n\ne &lt;- env()\ne$g &lt;- function() 1\n\nNamespaces ensure that you don’t find different functions based on the order in which pacakges were loaded. Every function is associated with a package enviornment and the namespace environment.\n\nThe package environment is the external interface to the package. It’s how you, the R user, find a function in ana attached package or with ::. Its parent is determined by search path, i.e. the order in whic packages have been attached.\nThe namespace environment is the internal interface to the package. The package environment controls how we find the function; the namespace controls how the functions finds its variables.\n\nEvery binding in the package environment is also found in the namespace environment; this ensures every function can use every other function in the package. Not all bindings in the namespace are in the package environment - this allows one to hide internals of a package from the user.\nEvery namespace environment has the same set of ancestors:\nEach namespace has an imports environment that contains bindings to all the functions used by the package. The imports environment is controlled by the package developer with the NAMESPACE file.\nExplicitly importing every base function would be tiresome, so the parent of the imports environment is the base namespace. The base namespace contains the same bindings as the base environment, but it has a different parent.\nThe parent of the base namespace is the global environment. This means that if a binding isn’t defined in the imports environment the package will look for it in the usual way. This is usually a bad idea (because it makes code depend on other loaded packages), so R CMD check automatically warns about such code. It is needed primarily for historical reasons, particularly due to how S3 method dispatch works.\nExecution Environments\n\ng &lt;- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\ng(10)\n\nDefining a\n\n\n[1] 1\n\n#&gt; Defining a\n#&gt; [1] 1\ng(10)\n\nDefining a\n\n\n[1] 1\n\n#&gt; Defining a\n#&gt; [1] 1\n\nThis function returns the same value each time because of the fresh start principle. Each time a function is called, a new enrionment is created to host execution. This is called the execution environment, and its parent is the function environment.\n\nh &lt;- function(x) {\n  # 1. The function called with x = 1\n  a &lt;- 2 # 2. a is bound to value 2\n  x + a\n}\ny &lt;- h(1) # 3. Functio completes returning value 3. Execution environment goes away.\n\nExecution environments are usually ephemeral and garbage collected, but you can make it stay around.\n\nh2 &lt;- function(x) {\n  a &lt;- x * 2\n  current_env()\n}\n\ne &lt;- h2(x = 10)\nenv_print(e)\n\n&lt;environment: 0x000002eb1df8fbd0&gt;\nParent: &lt;environment: global&gt;\nBindings:\n• a: &lt;dbl&gt;\n• x: &lt;dbl&gt;\n\n#&gt; &lt;environment: 0x559733944920&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;dbl&gt;\n#&gt; • x: &lt;dbl&gt;\nfn_env(h2)\n\n&lt;environment: R_GlobalEnv&gt;\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nYou can also return an object with a binding to that environment.\n\nplus &lt;- function(x) {\n  function(y) x + y\n}\n\nplus_one &lt;- plus(1)\nplus_one\n\nfunction (y) \nx + y\n&lt;environment: 0x000002eb1bc9f850&gt;\n\n#&gt; function (y) \n#&gt; x + y\n#&gt; &lt;environment: 0x559737ab06b8&gt;\n\n\n\n\nSection 7.5 explains the last important environment: the caller environment. This requires you to learn about the call stack, that describes how a function was called. You’ll have seen the call stack if you’ve ever called traceback() to aid debugging.\nCaller environment is accessed with rlang::caller_env(). This provides the environment from which the function was called. parent.frame() is equivalent to caller_env(), but it returns an environment, not a frame.\nTo understand the caller environment, we need to understand: 1. the call stack 2. frames\nExecuting a function creates two types of context: 1. the execution environment, which is a child of the function environment, which is determined by where the function was created. 2. the call stack, which is created by where the function is called.\n\nf &lt;- function(x) {\n  g(x = 2)\n}\ng &lt;- function(x) {\n  h(x = 3)\n}\nh &lt;- function(x) {\n  stop()\n}\n\n\n# f(x = 1)\n# #&gt; Error:\n# traceback()\n# #&gt; 4: stop()\n# #&gt; 3: h(x = 3) \n# #&gt; 2: g(x = 2)\n# #&gt; 1: f(x = 1)\n\nUse lobstr::cst() to print out the call stack tree.\n\nh &lt;- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n\n    ▆\n 1. └─global f(x = 1)\n 2.   └─global g(x = 2)\n 3.     └─global h(x = 3)\n 4.       └─lobstr::cst()\n\n#&gt; █\n#&gt; └─f(x = 1)\n#&gt;   └─g(x = 2)\n#&gt;     └─h(x = 3)\n#&gt;       └─lobstr::cst()\n\nThings get more complicated with lazy evaluation.\n\n# a &lt;- function(x) b(x)\n# b &lt;- function(x) c(x)\n# c &lt;- function(x) x\n\n# a(f())\n#&gt; █\n#&gt; ├─a(f())\n#&gt; │ └─b(x)\n#&gt; │   └─c(x)\n#&gt; └─f()\n#&gt;   └─g(x = 2)\n#&gt;     └─h(x = 3)\n#&gt;       └─lobstr::cst()\n\nc() is evaluated in the global environment, not the function environment. This results in two branches in the call stack tree.\nEach element of the call stack is a frame, also known as an evaluation context. A frame has three key components: 1. An expression (labelled with expr) giving the function call. This is what traceback() prints out. 2. An environment (labelled with env), which is typically the execution environment of a function. There are two main exceptions: the environment of the glbal frame is the global environment, and calling eval() also generates frames, where the environment can be anything. 3. A parent, the previous call in the call stack.\n\n\n\nSection 7.6 briefly discusses three places where environments are useful data structures for solving other problems.\nEnvironment power scoping, and they are useful because they have reference semantics. Three problems they help solve:\n\nAvoiding copies of large data\nManaging state within a package\nAs a hashmap"
  },
  {
    "objectID": "chapter_07_notes.html#environment-basics",
    "href": "chapter_07_notes.html#environment-basics",
    "title": "Advanced R - Chapter 7 Notes",
    "section": "",
    "text": "Section 7.2 introduces you to the basic properties of an environment and shows you how to create your own.\nAn environment is similar to a named list, with four exceptions: 1. every name must be unique 2. the names in an environment are not ordered. 3. An enviornment has a parent. 4. Environments are not copied when modified\nTo create an environment, use rlang::env().\n\nlibrary(rlang)\n\ne1 &lt;- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n\nThe job of an environment is to bind a set of names to a set of values.\nEnvironments can contain themselves:\n\ne1$d &lt;- e1\n\nenv_print(e1) # note the env in d\n\n&lt;environment: 0x000002eb1ac5a7e0&gt;\nParent: &lt;environment: global&gt;\nBindings:\n• a: &lt;lgl&gt;\n• b: &lt;chr&gt;\n• c: &lt;dbl&gt;\n• d: &lt;env&gt;\n\n\n\n# get the names of an environment\nenv_names(e1)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\n# find out what the current environment is\ncurrent_env()\n\n&lt;environment: R_GlobalEnv&gt;\n\n# or use environment()\nenvironment()\n\n&lt;environment: R_GlobalEnv&gt;\n\n# compare environments with identical()\nidentical(global_env(), current_env())\n\n[1] TRUE\n\n\nEvery environment has a parent. Set the parent by supplying an unnamed argument to env(). The parent is what’s used to implement lexical scoping.\n\ne2a &lt;- env(d = 4, e = 5)\ne2b &lt;- env(e2a, a = 1, b = 2, c = 3)\n\nenv_parent(e2a)\n\n&lt;environment: R_GlobalEnv&gt;\n\nenv_parent(e2b)\n\n&lt;environment: 0x000002eb17d965f0&gt;\n\n\nOnly the empty environment doesn’t have a parent\n\ne2c &lt;- env(empty_env(), d = 4, e = 5)\ne2d &lt;- env(e2c, a = 1, b = 2, c = 3)\n\ne2c &lt;- env(empty_env(), d = 4, e = 5)\ne2d &lt;- env(e2c, a = 1, b = 2, c = 3)\n\nenv_parents(e2b)\n\n[[1]]   &lt;env: 0x000002eb17d965f0&gt;\n[[2]] $ &lt;env: global&gt;\n\n#&gt; [[1]]   &lt;env: 0x559735c4a248&gt;\n#&gt; [[2]] $ &lt;env: global&gt;\nenv_parents(e2d)\n\n[[1]]   &lt;env: 0x000002eb19536660&gt;\n[[2]] $ &lt;env: empty&gt;\n\n#&gt; [[1]]   &lt;env: 0x5597366d1bf8&gt;\n#&gt; [[2]] $ &lt;env: empty&gt;\n\nenv_parents() stops when it gets to the global environment.\nSuper assignment\n&lt;&lt;- never creates a variable in the current environment, but instead modifies an existing variable found in a parent environment.\n\nx &lt;- 0\nf &lt;- function() {\n  x &lt;&lt;- 1\n}\nf()\nx\n\n[1] 1\n\n#&gt; [1] 1\n\nGetting and setting elements of an environment\n\ne3 &lt;- env(x = 1, y = 2)\ne3$x\n\n[1] 1\n\n#&gt; [1] 1\ne3$z &lt;- 3\ne3[[\"z\"]]\n\n[1] 3\n\n#&gt; [1] 3\n\nYou can’t subset with numeric indices and you can’t use [\n\n# e3[[1]]\n# #&gt; Error in e3[[1]]: wrong arguments for subsetting an environment\n\n# e3[c(\"x\", \"y\")]\n# #&gt; Error in e3[c(\"x\", \"y\")]: object of type 'environment' is not subsettable\n\nOther ways to add bindings to an environment:\n\nenv_poke(e3, \"a\", 100)\ne3$a\n\n[1] 100\n\n#&gt; [1] 100\n\nenv_bind() allows binding of multiple values\n\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n\n[1] \"x\" \"y\" \"z\" \"a\" \"b\"\n\n#&gt; [1] \"x\" \"y\" \"z\" \"a\" \"b\"\n\n\nenv_has(e3, \"a\")\n\n   a \nTRUE \n\n#&gt;    a \n#&gt; TRUE\n\n# To unbind:\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n\n    a \nFALSE \n\n\nAdvanced bindings\n`env_bind_lazy() creates delayed bindings, which are evaluated the first time they are acessed. Delayed bindings create promises. See how the value is computed once, the first time it is accessed, then it is cached and returned immediately upon later calls.\n\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n\n[1] 1\n\n\n   user  system elapsed \n   0.00    0.00    1.01 \n\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;       0       0       1\nsystem.time(print(b))\n\n[1] 1\n\n\n   user  system elapsed \n      0       0       0 \n\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;       0       0       0\n\nThe primary use for delayed bindings is in autoload(), which allows R packages to provide datasets that behave like they are loaded in memory, even though they’re only loaded from disk when needed.\nenv_bind_active() creates active bindings, which are recomputed every time they’re accessed:\n\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n\n[1] 0.3944286\n\n#&gt; [1] 0.0808\nz1\n\n[1] 0.4796495\n\n#&gt; [1] 0.834"
  },
  {
    "objectID": "chapter_07_notes.html#recursing-over-environments",
    "href": "chapter_07_notes.html#recursing-over-environments",
    "title": "Advanced R - Chapter 7 Notes",
    "section": "",
    "text": "Section 7.3 provides a function template for computing with environments, illustrating the idea with a useful function.\nFor example, you could search for the name of function and start the search at a child environment.\n\nwhere &lt;- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n\nIllustrate the cases where a name can’t be found, where it is found, and then where it is recursively searched for:\n\n# where(\"yyy\")\n# #&gt; Error: Can't find yyy\n\nx &lt;- 5\nwhere(\"x\")\n\n&lt;environment: R_GlobalEnv&gt;\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nwhere(\"mean\")\n\n&lt;environment: base&gt;\n\n#&gt; &lt;environment: base&gt;\n\nYou could rewrite where() as a for loop instead of a recursive function:\n\nf2 &lt;- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # success case\n      return()\n    }\n    # inspect parent\n    env &lt;- env_parent(env)\n  }\n\n  # base case\n}"
  },
  {
    "objectID": "chapter_07_notes.html#special-environments",
    "href": "chapter_07_notes.html#special-environments",
    "title": "Advanced R - Chapter 7 Notes",
    "section": "",
    "text": "Section 7.4 describes environments used for special purposes: for packages, within functions, for namespaces, and for function execution.\nEach package attached by library() or require() becomes one of the parents of the global environment. Packages loaded (not attached) with :: do not become parents. The immediate parent of the global environment is the last package you attached., the parent of that package is the second to last package you attached.\nFollow all the packages back in the order in which they were attached - this gives the search path.\n\n# You can see the names of these environments with:\n\nbase::search()\n\n [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n [4] \"package:graphics\"  \"package:grDevices\" \"package:datasets\" \n [7] \"renv:shims\"        \"package:utils\"     \"package:methods\"  \n[10] \"Autoloads\"         \"package:base\"     \n\nrlang::search_envs()\n\n [[1]] $ &lt;env: global&gt;\n [[2]] $ &lt;env: package:rlang&gt;\n [[3]] $ &lt;env: package:stats&gt;\n [[4]] $ &lt;env: package:graphics&gt;\n [[5]] $ &lt;env: package:grDevices&gt;\n [[6]] $ &lt;env: package:datasets&gt;\n [[7]] $ &lt;env: renv:shims&gt;\n [[8]] $ &lt;env: package:utils&gt;\n [[9]] $ &lt;env: package:methods&gt;\n[[10]] $ &lt;env: Autoloads&gt;\n[[11]] $ &lt;env: package:base&gt;\n\n\nThe last two environments on the search path are always the same: 1. The Autoloads() environment uses delayed bindings to save memory by only loading package objects (like big datasets) when needed. 2. The base environment. It is special because it has to be able to bootstrap the loading of all other packages. You can access it directly with base_env().\nThe function environment\nA function binds the current environment. Functions that capture their environments are called closures. Sometimes the word function and closure are used interchangeably in R documentation.\nGet the function environment:\n\ny &lt;- 1\nf &lt;- function(x) x + y\nfn_env(f)\n\n&lt;environment: R_GlobalEnv&gt;\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nf() binds the environment that binds the name f to the function. Not always the case. In the code below, g() binds the global environment, but g is bound in a new environment e().\n\ne &lt;- env()\ne$g &lt;- function() 1\n\nNamespaces ensure that you don’t find different functions based on the order in which pacakges were loaded. Every function is associated with a package enviornment and the namespace environment.\n\nThe package environment is the external interface to the package. It’s how you, the R user, find a function in ana attached package or with ::. Its parent is determined by search path, i.e. the order in whic packages have been attached.\nThe namespace environment is the internal interface to the package. The package environment controls how we find the function; the namespace controls how the functions finds its variables.\n\nEvery binding in the package environment is also found in the namespace environment; this ensures every function can use every other function in the package. Not all bindings in the namespace are in the package environment - this allows one to hide internals of a package from the user.\nEvery namespace environment has the same set of ancestors:\nEach namespace has an imports environment that contains bindings to all the functions used by the package. The imports environment is controlled by the package developer with the NAMESPACE file.\nExplicitly importing every base function would be tiresome, so the parent of the imports environment is the base namespace. The base namespace contains the same bindings as the base environment, but it has a different parent.\nThe parent of the base namespace is the global environment. This means that if a binding isn’t defined in the imports environment the package will look for it in the usual way. This is usually a bad idea (because it makes code depend on other loaded packages), so R CMD check automatically warns about such code. It is needed primarily for historical reasons, particularly due to how S3 method dispatch works.\nExecution Environments\n\ng &lt;- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\ng(10)\n\nDefining a\n\n\n[1] 1\n\n#&gt; Defining a\n#&gt; [1] 1\ng(10)\n\nDefining a\n\n\n[1] 1\n\n#&gt; Defining a\n#&gt; [1] 1\n\nThis function returns the same value each time because of the fresh start principle. Each time a function is called, a new enrionment is created to host execution. This is called the execution environment, and its parent is the function environment.\n\nh &lt;- function(x) {\n  # 1. The function called with x = 1\n  a &lt;- 2 # 2. a is bound to value 2\n  x + a\n}\ny &lt;- h(1) # 3. Functio completes returning value 3. Execution environment goes away.\n\nExecution environments are usually ephemeral and garbage collected, but you can make it stay around.\n\nh2 &lt;- function(x) {\n  a &lt;- x * 2\n  current_env()\n}\n\ne &lt;- h2(x = 10)\nenv_print(e)\n\n&lt;environment: 0x000002eb1df8fbd0&gt;\nParent: &lt;environment: global&gt;\nBindings:\n• a: &lt;dbl&gt;\n• x: &lt;dbl&gt;\n\n#&gt; &lt;environment: 0x559733944920&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;dbl&gt;\n#&gt; • x: &lt;dbl&gt;\nfn_env(h2)\n\n&lt;environment: R_GlobalEnv&gt;\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nYou can also return an object with a binding to that environment.\n\nplus &lt;- function(x) {\n  function(y) x + y\n}\n\nplus_one &lt;- plus(1)\nplus_one\n\nfunction (y) \nx + y\n&lt;environment: 0x000002eb1bc9f850&gt;\n\n#&gt; function (y) \n#&gt; x + y\n#&gt; &lt;environment: 0x559737ab06b8&gt;"
  },
  {
    "objectID": "chapter_07_notes.html#call-stacks",
    "href": "chapter_07_notes.html#call-stacks",
    "title": "Advanced R - Chapter 7 Notes",
    "section": "",
    "text": "Section 7.5 explains the last important environment: the caller environment. This requires you to learn about the call stack, that describes how a function was called. You’ll have seen the call stack if you’ve ever called traceback() to aid debugging.\nCaller environment is accessed with rlang::caller_env(). This provides the environment from which the function was called. parent.frame() is equivalent to caller_env(), but it returns an environment, not a frame.\nTo understand the caller environment, we need to understand: 1. the call stack 2. frames\nExecuting a function creates two types of context: 1. the execution environment, which is a child of the function environment, which is determined by where the function was created. 2. the call stack, which is created by where the function is called.\n\nf &lt;- function(x) {\n  g(x = 2)\n}\ng &lt;- function(x) {\n  h(x = 3)\n}\nh &lt;- function(x) {\n  stop()\n}\n\n\n# f(x = 1)\n# #&gt; Error:\n# traceback()\n# #&gt; 4: stop()\n# #&gt; 3: h(x = 3) \n# #&gt; 2: g(x = 2)\n# #&gt; 1: f(x = 1)\n\nUse lobstr::cst() to print out the call stack tree.\n\nh &lt;- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n\n    ▆\n 1. └─global f(x = 1)\n 2.   └─global g(x = 2)\n 3.     └─global h(x = 3)\n 4.       └─lobstr::cst()\n\n#&gt; █\n#&gt; └─f(x = 1)\n#&gt;   └─g(x = 2)\n#&gt;     └─h(x = 3)\n#&gt;       └─lobstr::cst()\n\nThings get more complicated with lazy evaluation.\n\n# a &lt;- function(x) b(x)\n# b &lt;- function(x) c(x)\n# c &lt;- function(x) x\n\n# a(f())\n#&gt; █\n#&gt; ├─a(f())\n#&gt; │ └─b(x)\n#&gt; │   └─c(x)\n#&gt; └─f()\n#&gt;   └─g(x = 2)\n#&gt;     └─h(x = 3)\n#&gt;       └─lobstr::cst()\n\nc() is evaluated in the global environment, not the function environment. This results in two branches in the call stack tree.\nEach element of the call stack is a frame, also known as an evaluation context. A frame has three key components: 1. An expression (labelled with expr) giving the function call. This is what traceback() prints out. 2. An environment (labelled with env), which is typically the execution environment of a function. There are two main exceptions: the environment of the glbal frame is the global environment, and calling eval() also generates frames, where the environment can be anything. 3. A parent, the previous call in the call stack."
  },
  {
    "objectID": "chapter_07_notes.html#as-data-structures",
    "href": "chapter_07_notes.html#as-data-structures",
    "title": "Advanced R - Chapter 7 Notes",
    "section": "",
    "text": "Section 7.6 briefly discusses three places where environments are useful data structures for solving other problems.\nEnvironment power scoping, and they are useful because they have reference semantics. Three problems they help solve:\n\nAvoiding copies of large data\nManaging state within a package\nAs a hashmap"
  },
  {
    "objectID": "chapter_09_notes.html",
    "href": "chapter_09_notes.html",
    "title": "Advanced R - Chapter 9 Notes",
    "section": "",
    "text": "A functional is a function that takes a function as an input and returns a vector as output. Here is an example of a functional:\n\nrandomise &lt;- function(f) f(runif(1e3))\nrandomise(mean)\n\n[1] 0.5136555\n\n#&gt; [1] 0.506\nrandomise(mean)\n\n[1] 0.5243264\n\n#&gt; [1] 0.501\nrandomise(sum)\n\n[1] 516.544\n\n#&gt; [1] 489\n\nA common use for functionals is as an alternative to for loops. It’s better to use functionals because each functional is tailored for a specific task, so when you recognize a functional you immediately know why it’s being used.\n\n\nSection 9.2 introduces your first functional: purrr::map(). map() takes a vector and a function, calls the function once for each element of the vector, and returns the results in a list.\n\nlibrary(purrr)\n\ntriple &lt;- function(x) x * 3\nmap(1:3, triple)\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 6\n\n[[3]]\n[1] 9\n\n#&gt; [[1]]\n#&gt; [1] 3\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 6\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 9\n\nAnd here is the implementation - allocate a list, and then fill in the list with a for loop. The base equivalent to map() is lapply().\n\nsimple_map &lt;- function(x, f, ...) {\n  out &lt;- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] &lt;- f(x[[i]], ...)\n  }\n  out\n}\n\nProducing atomic vectors. You can do this with map_lgl(), map_int(), map_dbl(), and map_chr() when you don’t want to return a list and want an atomic vector.\n\n# map_chr() always returns a character vector\nmap_chr(mtcars, typeof)\n\n     mpg      cyl     disp       hp     drat       wt     qsec       vs \n\"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n      am     gear     carb \n\"double\" \"double\" \"double\" \n\n#&gt;      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#&gt; \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#&gt;       am     gear     carb \n#&gt; \"double\" \"double\" \"double\"\n\n# map_lgl() always returns a logical vector\nmap_lgl(mtcars, is.double)\n\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \nTRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE \n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt; TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# map_int() always returns a integer vector\nn_unique &lt;- function(x) length(unique(x))\nmap_int(mtcars, n_unique)\n\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n  25    3   27   22   22   29   30    2    2    3    6 \n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\n# map_dbl() always returns a double vector\nmap_dbl(mtcars, mean)\n\n       mpg        cyl       disp         hp       drat         wt       qsec \n 20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 \n        vs         am       gear       carb \n  0.437500   0.406250   3.687500   2.812500 \n\n#&gt;     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n#&gt;  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 \n#&gt;    carb \n#&gt;   2.812\n\nYou can feed these functions any type of vector as input.\nAnonymous functions and shortcuts. You can use map() with an inline anonymous function.\n\nmap_dbl(mtcars, function(x) length(unique(x)))\n\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n  25    3   27   22   22   29   30    2    2    3    6 \n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nThis is verbose, so purrr supports a different syntax for anonymous functions:\n\nmap_dbl(mtcars, ~ length(unique(.x)))\n\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n  25    3   27   22   22   29   30    2    2    3    6 \n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\n# refer to .x and .y for two argument functions, and ..1, ..2, etc. for arbitrary numbers of functions.\n\n\nx &lt;- map(1:3, ~ runif(2))\nstr(x)\n\nList of 3\n $ : num [1:2] 0.254 0.449\n $ : num [1:2] 0.5 0.101\n $ : num [1:2] 0.273 0.914\n\n#&gt; List of 3\n#&gt;  $ : num [1:2] 0.281 0.53\n#&gt;  $ : num [1:2] 0.433 0.917\n#&gt;  $ : num [1:2] 0.0275 0.8249\n\nIf your function spans lines or uses {}, give it a name.\nExtracting elements from a vector is powered by purrr::pluck(). You can use a character vector, an integer vector, or a list to select elements using both name and position.\n\nx &lt;- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Select by name\nmap_dbl(x, \"x\")\n\n[1] 1 4 8\n\n#&gt; [1] 1 4 8\n\n# Or by position\nmap_dbl(x, 1)\n\n[1] -1 -2 -3\n\n#&gt; [1] -1 -2 -3\n\n# Or by both\nmap_dbl(x, list(\"y\", 1))\n\n[1] 2 5 9\n\n#&gt; [1] 2 5 9\n\n# You'll get an error if a component doesn't exist:\n# map_chr(x, \"z\")\n#&gt; Error in map_chr(x, \"z\"): ℹ In index: 3.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 0.\n\n# Unless you supply a .default value\nmap_chr(x, \"z\", .default = NA)\n\n[1] \"a\" \"b\" NA \n\n#&gt; [1] \"a\" \"b\" NA\n\nPassing arguments with …. Sometimes you need to pass on additional arguments to a function, such as na.rm = TRUE when using mean(). This can be done in two ways:\n\n# anonymous function\nx &lt;- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n\n[1] 3.0 5.5\n\n#&gt; [1] 3.0 5.5\n\nSince map functions pass ... along, there’s a simpler form available:\n\nmap_dbl(x, mean, na.rm = TRUE)\n\n[1] 3.0 5.5\n\n#&gt; [1] 3.0 5.5\n\nArguments that come after the function you use in the call to map() are passed to the function as additional arguments after the data. So the data are the first argument, and then come you ... arguments.\nAlso, extra argument inside an anonymous function are evaluated each time f() is executed, not just once as in the case of map().\n\nplus &lt;- function(x, y) x + y\n\nx &lt;- c(0, 0, 0, 0)\nmap_dbl(x, plus, runif(1))\n\n[1] 0.5096762 0.5096762 0.5096762 0.5096762\n\n#&gt; [1] 0.0625 0.0625 0.0625 0.0625\nmap_dbl(x, ~ plus(.x, runif(1)))\n\n[1] 0.5987147 0.5713833 0.1329296 0.5487360\n\n#&gt; [1] 0.903 0.132 0.629 0.945\n\nArgument names. Use them. Note that named matching beats positional matching in function calls. Remember that purrr uses .x and .f in function calls.\nVarying another argument. What if you want the first argument (the .x) to stay constant and you want to vary the function that is applied to it? There’s no direct way.\n\ntrims &lt;- c(0, 0.1, 0.2, 0.5)\nx &lt;- rcauchy(1000)\n\nmap_dbl(trims, ~ mean(x, trim = .x))\n\n[1] 1.17933063 0.04148201 0.03141918 0.03827854\n\n#&gt; [1] -0.3500  0.0434  0.0354  0.0502\n\n# or without using an anonymous function:\n\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n\n[1] 1.17933063 0.04148201 0.03141918 0.03827854\n\n#&gt; [1] -0.3500  0.0434  0.0354  0.0502\n\n\n\n\nSection 9.3 demonstrates how you can combine multiple simple functionals to solve a more complex problem and discusses how purrr style differs from other approaches.\nSolving a realistic problemw with multiple purrr functions: fitting a model to each subgroup and extracting a coefficient of the model\n\nby_cyl &lt;- split(mtcars, mtcars$cyl)\n\n# fit a model extract the slope coefficient\nby_cyl %&gt;% \n  map(~ lm(mpg ~ wt, data = .x)) %&gt;% \n  map(coef) %&gt;% \n  map_dbl(2)\n\n        4         6         8 \n-5.647025 -2.780106 -2.192438 \n\n#&gt;     4     6     8 \n#&gt; -5.65 -2.78 -2.19\n\nOther approaches to do the same thing are more verbose, more complex.\nBase R with the pipe:\n\nby_cyl %&gt;% \n  lapply(function(data) lm(mpg ~ wt, data = data)) %&gt;% \n  lapply(coef) %&gt;% \n  vapply(function(x) x[[2]], double(1))\n\n        4         6         8 \n-5.647025 -2.780106 -2.192438 \n\n#&gt;     4     6     8 \n#&gt; -5.65 -2.78 -2.19\n\nBase R without the pipe:\n\nmodels &lt;- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))\nvapply(models, function(x) coef(x)[[2]], double(1))\n\n        4         6         8 \n-5.647025 -2.780106 -2.192438 \n\n#&gt;     4     6     8 \n#&gt; -5.65 -2.78 -2.19\n\na for loop:\n\nslopes &lt;- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model &lt;- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] &lt;- coef(model)[[2]]\n}\nslopes\n\n[1] -5.647025 -2.780106 -2.192438\n\n#&gt; [1] -5.65 -2.78 -2.19\n\n\n\n\nSection 9.4 teaches you about 18 (!!) important variants of purrr::map(). Fortunately, their orthogonal design makes them easy to learn, remember, and master.\n\n\n\nSection 9.5 introduces a new style of functional: purrr::reduce(). reduce() systematically reduces a vector to a single result by applying a function that takes two inputs.\n\n\n\nSection 9.6 teaches you about predicates: functions that return a single TRUE or FALSE, and the family of functionals that use them to solve common problems.\n\n\n\nSection 9.7 reviews some functionals in base R that are not members of the map, reduce, or predicate families."
  },
  {
    "objectID": "chapter_09_notes.html#my-first-functional-map",
    "href": "chapter_09_notes.html#my-first-functional-map",
    "title": "Advanced R - Chapter 9 Notes",
    "section": "",
    "text": "Section 9.2 introduces your first functional: purrr::map(). map() takes a vector and a function, calls the function once for each element of the vector, and returns the results in a list.\n\nlibrary(purrr)\n\ntriple &lt;- function(x) x * 3\nmap(1:3, triple)\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 6\n\n[[3]]\n[1] 9\n\n#&gt; [[1]]\n#&gt; [1] 3\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 6\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 9\n\nAnd here is the implementation - allocate a list, and then fill in the list with a for loop. The base equivalent to map() is lapply().\n\nsimple_map &lt;- function(x, f, ...) {\n  out &lt;- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] &lt;- f(x[[i]], ...)\n  }\n  out\n}\n\nProducing atomic vectors. You can do this with map_lgl(), map_int(), map_dbl(), and map_chr() when you don’t want to return a list and want an atomic vector.\n\n# map_chr() always returns a character vector\nmap_chr(mtcars, typeof)\n\n     mpg      cyl     disp       hp     drat       wt     qsec       vs \n\"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n      am     gear     carb \n\"double\" \"double\" \"double\" \n\n#&gt;      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#&gt; \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#&gt;       am     gear     carb \n#&gt; \"double\" \"double\" \"double\"\n\n# map_lgl() always returns a logical vector\nmap_lgl(mtcars, is.double)\n\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \nTRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE \n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt; TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# map_int() always returns a integer vector\nn_unique &lt;- function(x) length(unique(x))\nmap_int(mtcars, n_unique)\n\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n  25    3   27   22   22   29   30    2    2    3    6 \n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\n# map_dbl() always returns a double vector\nmap_dbl(mtcars, mean)\n\n       mpg        cyl       disp         hp       drat         wt       qsec \n 20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 \n        vs         am       gear       carb \n  0.437500   0.406250   3.687500   2.812500 \n\n#&gt;     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n#&gt;  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 \n#&gt;    carb \n#&gt;   2.812\n\nYou can feed these functions any type of vector as input.\nAnonymous functions and shortcuts. You can use map() with an inline anonymous function.\n\nmap_dbl(mtcars, function(x) length(unique(x)))\n\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n  25    3   27   22   22   29   30    2    2    3    6 \n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nThis is verbose, so purrr supports a different syntax for anonymous functions:\n\nmap_dbl(mtcars, ~ length(unique(.x)))\n\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n  25    3   27   22   22   29   30    2    2    3    6 \n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\n# refer to .x and .y for two argument functions, and ..1, ..2, etc. for arbitrary numbers of functions.\n\n\nx &lt;- map(1:3, ~ runif(2))\nstr(x)\n\nList of 3\n $ : num [1:2] 0.254 0.449\n $ : num [1:2] 0.5 0.101\n $ : num [1:2] 0.273 0.914\n\n#&gt; List of 3\n#&gt;  $ : num [1:2] 0.281 0.53\n#&gt;  $ : num [1:2] 0.433 0.917\n#&gt;  $ : num [1:2] 0.0275 0.8249\n\nIf your function spans lines or uses {}, give it a name.\nExtracting elements from a vector is powered by purrr::pluck(). You can use a character vector, an integer vector, or a list to select elements using both name and position.\n\nx &lt;- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Select by name\nmap_dbl(x, \"x\")\n\n[1] 1 4 8\n\n#&gt; [1] 1 4 8\n\n# Or by position\nmap_dbl(x, 1)\n\n[1] -1 -2 -3\n\n#&gt; [1] -1 -2 -3\n\n# Or by both\nmap_dbl(x, list(\"y\", 1))\n\n[1] 2 5 9\n\n#&gt; [1] 2 5 9\n\n# You'll get an error if a component doesn't exist:\n# map_chr(x, \"z\")\n#&gt; Error in map_chr(x, \"z\"): ℹ In index: 3.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 0.\n\n# Unless you supply a .default value\nmap_chr(x, \"z\", .default = NA)\n\n[1] \"a\" \"b\" NA \n\n#&gt; [1] \"a\" \"b\" NA\n\nPassing arguments with …. Sometimes you need to pass on additional arguments to a function, such as na.rm = TRUE when using mean(). This can be done in two ways:\n\n# anonymous function\nx &lt;- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n\n[1] 3.0 5.5\n\n#&gt; [1] 3.0 5.5\n\nSince map functions pass ... along, there’s a simpler form available:\n\nmap_dbl(x, mean, na.rm = TRUE)\n\n[1] 3.0 5.5\n\n#&gt; [1] 3.0 5.5\n\nArguments that come after the function you use in the call to map() are passed to the function as additional arguments after the data. So the data are the first argument, and then come you ... arguments.\nAlso, extra argument inside an anonymous function are evaluated each time f() is executed, not just once as in the case of map().\n\nplus &lt;- function(x, y) x + y\n\nx &lt;- c(0, 0, 0, 0)\nmap_dbl(x, plus, runif(1))\n\n[1] 0.5096762 0.5096762 0.5096762 0.5096762\n\n#&gt; [1] 0.0625 0.0625 0.0625 0.0625\nmap_dbl(x, ~ plus(.x, runif(1)))\n\n[1] 0.5987147 0.5713833 0.1329296 0.5487360\n\n#&gt; [1] 0.903 0.132 0.629 0.945\n\nArgument names. Use them. Note that named matching beats positional matching in function calls. Remember that purrr uses .x and .f in function calls.\nVarying another argument. What if you want the first argument (the .x) to stay constant and you want to vary the function that is applied to it? There’s no direct way.\n\ntrims &lt;- c(0, 0.1, 0.2, 0.5)\nx &lt;- rcauchy(1000)\n\nmap_dbl(trims, ~ mean(x, trim = .x))\n\n[1] 1.17933063 0.04148201 0.03141918 0.03827854\n\n#&gt; [1] -0.3500  0.0434  0.0354  0.0502\n\n# or without using an anonymous function:\n\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n\n[1] 1.17933063 0.04148201 0.03141918 0.03827854\n\n#&gt; [1] -0.3500  0.0434  0.0354  0.0502"
  },
  {
    "objectID": "chapter_09_notes.html#purrr-style",
    "href": "chapter_09_notes.html#purrr-style",
    "title": "Advanced R - Chapter 9 Notes",
    "section": "",
    "text": "Section 9.3 demonstrates how you can combine multiple simple functionals to solve a more complex problem and discusses how purrr style differs from other approaches.\nSolving a realistic problemw with multiple purrr functions: fitting a model to each subgroup and extracting a coefficient of the model\n\nby_cyl &lt;- split(mtcars, mtcars$cyl)\n\n# fit a model extract the slope coefficient\nby_cyl %&gt;% \n  map(~ lm(mpg ~ wt, data = .x)) %&gt;% \n  map(coef) %&gt;% \n  map_dbl(2)\n\n        4         6         8 \n-5.647025 -2.780106 -2.192438 \n\n#&gt;     4     6     8 \n#&gt; -5.65 -2.78 -2.19\n\nOther approaches to do the same thing are more verbose, more complex.\nBase R with the pipe:\n\nby_cyl %&gt;% \n  lapply(function(data) lm(mpg ~ wt, data = data)) %&gt;% \n  lapply(coef) %&gt;% \n  vapply(function(x) x[[2]], double(1))\n\n        4         6         8 \n-5.647025 -2.780106 -2.192438 \n\n#&gt;     4     6     8 \n#&gt; -5.65 -2.78 -2.19\n\nBase R without the pipe:\n\nmodels &lt;- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))\nvapply(models, function(x) coef(x)[[2]], double(1))\n\n        4         6         8 \n-5.647025 -2.780106 -2.192438 \n\n#&gt;     4     6     8 \n#&gt; -5.65 -2.78 -2.19\n\na for loop:\n\nslopes &lt;- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model &lt;- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] &lt;- coef(model)[[2]]\n}\nslopes\n\n[1] -5.647025 -2.780106 -2.192438\n\n#&gt; [1] -5.65 -2.78 -2.19"
  },
  {
    "objectID": "chapter_09_notes.html#map-variants",
    "href": "chapter_09_notes.html#map-variants",
    "title": "Advanced R - Chapter 9 Notes",
    "section": "",
    "text": "Section 9.4 teaches you about 18 (!!) important variants of purrr::map(). Fortunately, their orthogonal design makes them easy to learn, remember, and master."
  },
  {
    "objectID": "chapter_09_notes.html#reduce-family",
    "href": "chapter_09_notes.html#reduce-family",
    "title": "Advanced R - Chapter 9 Notes",
    "section": "",
    "text": "Section 9.5 introduces a new style of functional: purrr::reduce(). reduce() systematically reduces a vector to a single result by applying a function that takes two inputs."
  },
  {
    "objectID": "chapter_09_notes.html#predicate-functionals",
    "href": "chapter_09_notes.html#predicate-functionals",
    "title": "Advanced R - Chapter 9 Notes",
    "section": "",
    "text": "Section 9.6 teaches you about predicates: functions that return a single TRUE or FALSE, and the family of functionals that use them to solve common problems."
  },
  {
    "objectID": "chapter_09_notes.html#base-functionals",
    "href": "chapter_09_notes.html#base-functionals",
    "title": "Advanced R - Chapter 9 Notes",
    "section": "",
    "text": "Section 9.7 reviews some functionals in base R that are not members of the map, reduce, or predicate families."
  }
]