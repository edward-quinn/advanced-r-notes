[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Notebook",
    "section": "",
    "text": "Wickham (2019) Book Notes\nWickham’s book can be found here\n\nChapter 1 Notes\nChapter 2 Notes\nChapter 3 Notes\nChapter 4 Notes\n\n\n\n\n\n\nReferences\n\nWickham, Hadley. 2019. Advanced R. 2nd Edition. New York: Chapman; Hall/CRC."
  },
  {
    "objectID": "chapter_03_notes.html",
    "href": "chapter_03_notes.html",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "atomic vectors. elements are all the same type.\nlists (sometimes called generic vectors). elements can vary by type.\n\nAttributes - named list of metadata - dimension turns vectors into matrices and arrays - class powers the S3 object system\n\n\nSection 3.2 introduces you to the atomic vectors: logical, integer, double, and character. These are R’s simplest data structures.\nInteger and double are inconsistently referred to as numeric. There are also two rare types: complex and raw.\nEach of the four primary types has a special syntax to create an individual value (a scalar).\n\n# Logicals\nTRUE\n\n[1] TRUE\n\nT\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nF\n\n[1] FALSE\n\n# Doubles\n0.1234\n\n[1] 0.1234\n\n1.234e-1\n\n[1] 0.1234\n\n## special values unique to double\nInf\n\n[1] Inf\n\n-Inf\n\n[1] -Inf\n\nNaN\n\n[1] NaN\n\n# Integers\n## can be written like a double, but must use L, which represents a long integer in C\n1234L\n\n[1] 1234\n\n1e4L\n\n[1] 10000\n\n# Strings\n## require single or double quotes. special characters escaped with \\\n\"hi there\"\n\n[1] \"hi there\"\n\n\ncombine vectors with c()\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\nc(c(1, 2), c(3, 4))\n\n[1] 1 2 3 4\n\n#&gt; [1] 1 2 3 4\n\n\ntypeof(lgl_var)\n\n[1] \"logical\"\n\n#&gt; [1] \"logical\"\ntypeof(int_var)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\ntypeof(chr_var)\n\n[1] \"character\"\n\n#&gt; [1] \"character\"\n\nmissing values are represented with a sentinal value NA, which are infectious unless some identity holds for all possible inputs\n\nNA &gt; 5\n\n[1] NA\n\n#&gt; [1] NA\n10 * NA\n\n[1] NA\n\n#&gt; [1] NA\n!NA\n\n[1] NA\n\n#&gt; [1] NA\n\nNA ^ 0\n\n[1] 1\n\n#&gt; [1] 1\nNA | TRUE\n\n[1] TRUE\n\n#&gt; [1] TRUE\nNA & FALSE\n\n[1] FALSE\n\n#&gt; [1] FALSE\n\n\n# which values are missing? use is.na()\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n\n[1] NA NA NA NA\n\n#&gt; [1] NA NA NA NA\n\nis.na(x)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n# There are four missing values, one for each atomic vector type\n\nvectors always have one type and will be coerced in a standard order to a single type if you combine multiple vectors of different types: character → double → integer → logical.\n\nstr(c(\"a\", 1))\n\n chr [1:2] \"a\" \"1\"\n\n#&gt;  chr [1:2] \"a\" \"1\"\n\nmathematical functions coerce logicals into 0 and 1\n\nx &lt;- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n\n[1] 0 0 1\n\n#&gt; [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n\n[1] 1\n\n#&gt; [1] 1\n\n# Proportion that are TRUE\nmean(x)\n\n[1] 0.3333333\n\n#&gt; [1] 0.333\n\nForce coercion with the corresponding as.* function\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  1 NA\n\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\n\nc(1, FALSE)\n\n[1] 1 0\n\nc(\"a\", 1)\n\n[1] \"a\" \"1\"\n\nc(TRUE, 1L)\n\n[1] 1 1\n\n\n\n\n\n\nSection 3.3 takes a small detour to discuss attributes, R’s flexible metadata specification. The most important attributes are names, dimensions, and class.\nHow does the dim attribute make matrices and arrays?\nAttributes can be though of as name-value pairs. Retrieved with attr(), en masse with attributes(), and set en masse with structure().\n\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n\n[1] \"abcdef\"\n\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na &lt;- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\nAttributes are generally ephemeral.\n\nattributes(a[1])\n\nNULL\n\n#&gt; NULL\nattributes(sum(a))\n\nNULL\n\n#&gt; NULL\n\nThere are two exceptions: - names, a character vector giving each element a name - dim, short for dimensions, an integer vector, used to turn vectors into matrices or arrays.\nName a vector in three ways:\n\n# When creating it: \nx &lt;- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\nAdding a dim attribute allows a vector to behave like a 2-d matrix or a multidimensional array.\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\n\nstr(1:3)                   # 1d vector\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n\n int [1:3, 1] 1 2 3\n\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n\n int [1, 1:3] 1 2 3\n\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n\n int [1:3(1d)] 1 2 3\n\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\n\n# What are these and how do they differ from 1:5?\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))\n\n\n\n\n\nSection 3.4 discusses the important vector types that are built by combining atomic vectors with special attributes. These include factors, dates, date-times, and durations.\nAn important vector attribute is class. Having a class attribute turns an object into an S3 object, which means will behave differently than a normal vector when passed to a generic function.\nNote that factors are built on Integer vectors, and POSIXct and Date vectors are built on Double vectors.\nFactors are vectors with only pre-defined values, defined by the attributes class and levels.\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n[1] a b b a\nLevels: a b\n\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\nattributes(x)\n\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\nFactors will give counts of unobserved levels in functions like table(), unlike character vectors.\n\nsex_char &lt;- c(\"m\", \"m\", \"m\")\nsex_factor &lt;- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\n#&gt; sex_char\n#&gt; m \n#&gt; 3\ntable(sex_factor)\n\nsex_factor\nm f \n3 0 \n\n#&gt; sex_factor\n#&gt; m f \n#&gt; 3 0\n\nOrdered factors for when order of the levels is meaningful\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n\n[1] b b a c\nLevels: c &lt; b &lt; a\n\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nFactors are coerced in different ways by different functions - sometimes to strings, and sometimes the underlying integer values are used.\nDates are built on top of double vectors and have class “Date” and no other attributes.\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(today)\n\n$class\n[1] \"Date\"\n\n#&gt; $class\n#&gt; [1] \"Date\"\n\nYou can see the value of the double by stripping the class\n\ndate &lt;- as.Date(\"1970-02-01\")\nunclass(date)\n\n[1] 31\n\n#&gt; [1] 31\n\nDate-Times in base R are built on top of Double vectors. One type is POSIXct.\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n\n[1] \"2018-08-01 22:00:00 UTC\"\n\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(now_ct)\n\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntime zones change printing, not the instant of time represented\n\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n\n[1] \"2018-08-02 07:00:00 JST\"\n\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n\n[1] \"2018-08-01 18:00:00 EDT\"\n\n#&gt; [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n\n[1] \"2018-08-02 08:30:00 +1030\"\n\n#&gt; [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n\n[1] \"2018-08-02 CEST\"\n\n#&gt; [1] \"2018-08-02 CEST\"\n\nDurations are stored in difftimes, which are built on top of doubles and have a units attribute that determines how differences should be interpreted.\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n\nTime difference of 1 weeks\n\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_1)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"weeks\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n\nTime difference of 7 days\n\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_2)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"days\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\ntable(letters)\n\nletters\na b c d e f g h i j k l m n o p q r s t u v w x y z \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n\ntypeof(table(letters))\n\n[1] \"integer\"\n\nattributes((table(letters)))\n\n$dim\n[1] 26\n\n$dimnames\n$dimnames$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n$class\n[1] \"table\"\n\n\n\n# what happens to a factor when you modify levels?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\n# How do these differ from f1?\n\nf2 &lt;- rev(factor(letters))\n\nf3 &lt;- factor(letters, levels = rev(letters))\n\n\n\n\n\nSection 3.5 dives into lists. Lists are very similar to atomic vectors, but have one key difference: an element of a list can be any data type, including another list. This makes them suitable for representing hierarchical data.\nConstruct a list with list():\n\nl1 &lt;- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nstr(l1)\n\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\nElements of a list are references and therefore do not take up as much space as you might imagine:\n\nlobstr::obj_size(mtcars)\n\n7.21 kB\n\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n\n7.29 kB\n\n#&gt; 7.29 kB\n\nLists are sometimes called recursive vectors because they can contain other lists.\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\nc() coerces the vectors to a list, and then flattens everything into one list\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\nTesting and coercion - test with is.list() and coerce with as.list().\n\nlist(1:3)\n\n[[1]]\n[1] 1 2 3\n\n#&gt; [[1]]\n#&gt; [1] 1 2 3\nas.list(1:3)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\nMatrices and arrays\nThe dimension attribute can be used to create list-matrices or list-arrays:\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n\n     [,1]      [,2]\n[1,] integer,3 TRUE\n[2,] \"a\"       1   \n\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\n\n\n\nSection 3.6 teaches you about data frames and tibbles, which are used to represent rectangular data. They combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.\nData frames and tibbles are built on top of lists.\nA data frame is a named list of vectors with attributes for (column) names, row.names, and its class, “data.frame”:\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df1)\n\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nA data frame has rownames() and colnames(). The names() of a data frame are the column names.\nA data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns.\nTibbles are lazy and the class vector is longer, and includes tbl_df.\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df2)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\nCreate a data frame with name-vector pairs:\n\ndf &lt;- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n\n'data.frame':   3 obs. of  2 variables:\n $ x: int  1 2 3\n $ y: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\nCreate a tibble in the same way.\n\ndf2 &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n\ntibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\nTibbles don’t change non-syntactic names. Data frames do.\n\nnames(data.frame(`1` = 1))\n\n[1] \"X1\"\n\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n\n[1] \"1\"\n\n#&gt; [1] \"1\"\n\nTibbles will only recycle vectors of length 1\n\ndata.frame(x = 1:4, y = 1:2)\n\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\n\n#data.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of\n#&gt; rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n\n# A tibble: 4 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     1\n2     2     1\n3     3     1\n4     4     1\n\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\n\n\n# tibble(x = 1:4, y = 1:2)\n#&gt; Error in tibble(x = 1:4, y = 1:2): Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\nA tibble can refer to variables created during construction. Data frames cannot.\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n\n# A tibble: 3 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     2\n2     2     4\n3     3     6\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\nData frames allow row names. This is a character vector with unique values.\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\n\nrownames(df3)\n\n[1] \"Bob\"   \"Susan\" \"Sam\"  \n\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n\n    age  hair\nBob  35 blond\n\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\nTibbles do not support rownames, but can easily convert them to a column in the tibble:\n\nas_tibble(df3, rownames = \"name\")\n\n# A tibble: 3 × 3\n  name    age hair \n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n\n#&gt; # A tibble: 3 × 3\n#&gt;   name    age hair \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Bob      35 blond\n#&gt; 2 Susan    27 brown\n#&gt; 3 Sam      18 black\n\nSubsetting differs by data frames and tibbles. Tibbles always return a tibble when subsetting, and no partial matching is allowed with column names.\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n\n chr \"a\"\n\n#&gt;  chr \"a\"\nstr(df2$x)\n\nWarning: Unknown or uninitialised column: `x`.\n\n\n NULL\n\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt;  NULL\n\nExtract single columns with df[[\"col\"]].\n\nis.data.frame(df1)\n\n[1] TRUE\n\n#&gt; [1] TRUE\nis.data.frame(df2) # this is a tibble and it passes this test.\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nIf you want to distinguish:\n\nis_tibble(df1)\n\n[1] FALSE\n\n#&gt; [1] FALSE\nis_tibble(df2)\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nList Columns - since a data frame or a tibble is a list, it can contain other lists.\n\n# extra work is required to add a list to a data frame - either after creation or using I()\n\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\nList columns are easier to use in a tibble.\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n\n# A tibble: 3 × 2\n      x y        \n  &lt;int&gt; &lt;list&gt;   \n1     1 &lt;int [2]&gt;\n2     2 &lt;int [3]&gt;\n3     3 &lt;int [4]&gt;\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\nMatrix and data frame columns are possible, but not advised. The NROW() og the matrix must match the data frame number of rows.\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n\n'data.frame':   3 obs. of  3 variables:\n $ x: num  10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':  3 obs. of  2 variables:\n  ..$ a: int  3 2 1\n  ..$ b: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\"\n\n\n\n\nAlways length zero, and cannot have attributes. A unique type.\n\ntypeof(NULL)\n\n[1] \"NULL\"\n\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n\n[1] 0\n\n#&gt; [1] 0\n\nx &lt;- NULL\n# attr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL\n\nNULL represents an absent vector, whereas NA represents an absent element. NULL can be useful in default function arguments."
  },
  {
    "objectID": "chapter_03_notes.html#atomic-vectors",
    "href": "chapter_03_notes.html#atomic-vectors",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.2 introduces you to the atomic vectors: logical, integer, double, and character. These are R’s simplest data structures.\nInteger and double are inconsistently referred to as numeric. There are also two rare types: complex and raw.\nEach of the four primary types has a special syntax to create an individual value (a scalar).\n\n# Logicals\nTRUE\n\n[1] TRUE\n\nT\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nF\n\n[1] FALSE\n\n# Doubles\n0.1234\n\n[1] 0.1234\n\n1.234e-1\n\n[1] 0.1234\n\n## special values unique to double\nInf\n\n[1] Inf\n\n-Inf\n\n[1] -Inf\n\nNaN\n\n[1] NaN\n\n# Integers\n## can be written like a double, but must use L, which represents a long integer in C\n1234L\n\n[1] 1234\n\n1e4L\n\n[1] 10000\n\n# Strings\n## require single or double quotes. special characters escaped with \\\n\"hi there\"\n\n[1] \"hi there\"\n\n\ncombine vectors with c()\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\nc(c(1, 2), c(3, 4))\n\n[1] 1 2 3 4\n\n#&gt; [1] 1 2 3 4\n\n\ntypeof(lgl_var)\n\n[1] \"logical\"\n\n#&gt; [1] \"logical\"\ntypeof(int_var)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\ntypeof(chr_var)\n\n[1] \"character\"\n\n#&gt; [1] \"character\"\n\nmissing values are represented with a sentinal value NA, which are infectious unless some identity holds for all possible inputs\n\nNA &gt; 5\n\n[1] NA\n\n#&gt; [1] NA\n10 * NA\n\n[1] NA\n\n#&gt; [1] NA\n!NA\n\n[1] NA\n\n#&gt; [1] NA\n\nNA ^ 0\n\n[1] 1\n\n#&gt; [1] 1\nNA | TRUE\n\n[1] TRUE\n\n#&gt; [1] TRUE\nNA & FALSE\n\n[1] FALSE\n\n#&gt; [1] FALSE\n\n\n# which values are missing? use is.na()\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n\n[1] NA NA NA NA\n\n#&gt; [1] NA NA NA NA\n\nis.na(x)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n# There are four missing values, one for each atomic vector type\n\nvectors always have one type and will be coerced in a standard order to a single type if you combine multiple vectors of different types: character → double → integer → logical.\n\nstr(c(\"a\", 1))\n\n chr [1:2] \"a\" \"1\"\n\n#&gt;  chr [1:2] \"a\" \"1\"\n\nmathematical functions coerce logicals into 0 and 1\n\nx &lt;- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n\n[1] 0 0 1\n\n#&gt; [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n\n[1] 1\n\n#&gt; [1] 1\n\n# Proportion that are TRUE\nmean(x)\n\n[1] 0.3333333\n\n#&gt; [1] 0.333\n\nForce coercion with the corresponding as.* function\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  1 NA\n\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\n\nc(1, FALSE)\n\n[1] 1 0\n\nc(\"a\", 1)\n\n[1] \"a\" \"1\"\n\nc(TRUE, 1L)\n\n[1] 1 1"
  },
  {
    "objectID": "chapter_03_notes.html#attributes",
    "href": "chapter_03_notes.html#attributes",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.3 takes a small detour to discuss attributes, R’s flexible metadata specification. The most important attributes are names, dimensions, and class.\nHow does the dim attribute make matrices and arrays?\nAttributes can be though of as name-value pairs. Retrieved with attr(), en masse with attributes(), and set en masse with structure().\n\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n\n[1] \"abcdef\"\n\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na &lt;- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\nAttributes are generally ephemeral.\n\nattributes(a[1])\n\nNULL\n\n#&gt; NULL\nattributes(sum(a))\n\nNULL\n\n#&gt; NULL\n\nThere are two exceptions: - names, a character vector giving each element a name - dim, short for dimensions, an integer vector, used to turn vectors into matrices or arrays.\nName a vector in three ways:\n\n# When creating it: \nx &lt;- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\nAdding a dim attribute allows a vector to behave like a 2-d matrix or a multidimensional array.\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\n\nstr(1:3)                   # 1d vector\n\n int [1:3] 1 2 3\n\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n\n int [1:3, 1] 1 2 3\n\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n\n int [1, 1:3] 1 2 3\n\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n\n int [1:3(1d)] 1 2 3\n\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\n\n# What are these and how do they differ from 1:5?\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))"
  },
  {
    "objectID": "chapter_03_notes.html#s3-atomic-vectors",
    "href": "chapter_03_notes.html#s3-atomic-vectors",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.4 discusses the important vector types that are built by combining atomic vectors with special attributes. These include factors, dates, date-times, and durations.\nAn important vector attribute is class. Having a class attribute turns an object into an S3 object, which means will behave differently than a normal vector when passed to a generic function.\nNote that factors are built on Integer vectors, and POSIXct and Date vectors are built on Double vectors.\nFactors are vectors with only pre-defined values, defined by the attributes class and levels.\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n[1] a b b a\nLevels: a b\n\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\nattributes(x)\n\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\nFactors will give counts of unobserved levels in functions like table(), unlike character vectors.\n\nsex_char &lt;- c(\"m\", \"m\", \"m\")\nsex_factor &lt;- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\n#&gt; sex_char\n#&gt; m \n#&gt; 3\ntable(sex_factor)\n\nsex_factor\nm f \n3 0 \n\n#&gt; sex_factor\n#&gt; m f \n#&gt; 3 0\n\nOrdered factors for when order of the levels is meaningful\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n\n[1] b b a c\nLevels: c &lt; b &lt; a\n\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nFactors are coerced in different ways by different functions - sometimes to strings, and sometimes the underlying integer values are used.\nDates are built on top of double vectors and have class “Date” and no other attributes.\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(today)\n\n$class\n[1] \"Date\"\n\n#&gt; $class\n#&gt; [1] \"Date\"\n\nYou can see the value of the double by stripping the class\n\ndate &lt;- as.Date(\"1970-02-01\")\nunclass(date)\n\n[1] 31\n\n#&gt; [1] 31\n\nDate-Times in base R are built on top of Double vectors. One type is POSIXct.\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n\n[1] \"2018-08-01 22:00:00 UTC\"\n\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(now_ct)\n\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntime zones change printing, not the instant of time represented\n\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n\n[1] \"2018-08-02 07:00:00 JST\"\n\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n\n[1] \"2018-08-01 18:00:00 EDT\"\n\n#&gt; [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n\n[1] \"2018-08-02 08:30:00 +1030\"\n\n#&gt; [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n\n[1] \"2018-08-02 CEST\"\n\n#&gt; [1] \"2018-08-02 CEST\"\n\nDurations are stored in difftimes, which are built on top of doubles and have a units attribute that determines how differences should be interpreted.\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n\nTime difference of 1 weeks\n\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_1)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"weeks\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n\nTime difference of 7 days\n\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n\n[1] \"double\"\n\n#&gt; [1] \"double\"\nattributes(one_week_2)\n\n$class\n[1] \"difftime\"\n\n$units\n[1] \"days\"\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\ntable(letters)\n\nletters\na b c d e f g h i j k l m n o p q r s t u v w x y z \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n\ntypeof(table(letters))\n\n[1] \"integer\"\n\nattributes((table(letters)))\n\n$dim\n[1] 26\n\n$dimnames\n$dimnames$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n$class\n[1] \"table\"\n\n\n\n# what happens to a factor when you modify levels?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\n# How do these differ from f1?\n\nf2 &lt;- rev(factor(letters))\n\nf3 &lt;- factor(letters, levels = rev(letters))"
  },
  {
    "objectID": "chapter_03_notes.html#lists",
    "href": "chapter_03_notes.html#lists",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.5 dives into lists. Lists are very similar to atomic vectors, but have one key difference: an element of a list can be any data type, including another list. This makes them suitable for representing hierarchical data.\nConstruct a list with list():\n\nl1 &lt;- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nstr(l1)\n\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\nElements of a list are references and therefore do not take up as much space as you might imagine:\n\nlobstr::obj_size(mtcars)\n\n7.21 kB\n\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n\n7.29 kB\n\n#&gt; 7.29 kB\n\nLists are sometimes called recursive vectors because they can contain other lists.\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\nc() coerces the vectors to a list, and then flattens everything into one list\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\nTesting and coercion - test with is.list() and coerce with as.list().\n\nlist(1:3)\n\n[[1]]\n[1] 1 2 3\n\n#&gt; [[1]]\n#&gt; [1] 1 2 3\nas.list(1:3)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\nMatrices and arrays\nThe dimension attribute can be used to create list-matrices or list-arrays:\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n\n     [,1]      [,2]\n[1,] integer,3 TRUE\n[2,] \"a\"       1   \n\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3"
  },
  {
    "objectID": "chapter_03_notes.html#data-frames-and-tibbles",
    "href": "chapter_03_notes.html#data-frames-and-tibbles",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Section 3.6 teaches you about data frames and tibbles, which are used to represent rectangular data. They combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.\nData frames and tibbles are built on top of lists.\nA data frame is a named list of vectors with attributes for (column) names, row.names, and its class, “data.frame”:\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df1)\n\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nA data frame has rownames() and colnames(). The names() of a data frame are the column names.\nA data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns.\nTibbles are lazy and the class vector is longer, and includes tbl_df.\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n\n[1] \"list\"\n\n#&gt; [1] \"list\"\n\nattributes(df2)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\nCreate a data frame with name-vector pairs:\n\ndf &lt;- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n\n'data.frame':   3 obs. of  2 variables:\n $ x: int  1 2 3\n $ y: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\nCreate a tibble in the same way.\n\ndf2 &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n\ntibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\nTibbles don’t change non-syntactic names. Data frames do.\n\nnames(data.frame(`1` = 1))\n\n[1] \"X1\"\n\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n\n[1] \"1\"\n\n#&gt; [1] \"1\"\n\nTibbles will only recycle vectors of length 1\n\ndata.frame(x = 1:4, y = 1:2)\n\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\n\n#data.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of\n#&gt; rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n\n# A tibble: 4 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     1\n2     2     1\n3     3     1\n4     4     1\n\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\n\n\n# tibble(x = 1:4, y = 1:2)\n#&gt; Error in tibble(x = 1:4, y = 1:2): Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\nA tibble can refer to variables created during construction. Data frames cannot.\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n\n# A tibble: 3 × 2\n      x     y\n  &lt;int&gt; &lt;dbl&gt;\n1     1     2\n2     2     4\n3     3     6\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\nData frames allow row names. This is a character vector with unique values.\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\n\nrownames(df3)\n\n[1] \"Bob\"   \"Susan\" \"Sam\"  \n\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n\n    age  hair\nBob  35 blond\n\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\nTibbles do not support rownames, but can easily convert them to a column in the tibble:\n\nas_tibble(df3, rownames = \"name\")\n\n# A tibble: 3 × 3\n  name    age hair \n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n\n#&gt; # A tibble: 3 × 3\n#&gt;   name    age hair \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Bob      35 blond\n#&gt; 2 Susan    27 brown\n#&gt; 3 Sam      18 black\n\nSubsetting differs by data frames and tibbles. Tibbles always return a tibble when subsetting, and no partial matching is allowed with column names.\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n\n chr \"a\"\n\n#&gt;  chr \"a\"\nstr(df2$x)\n\nWarning: Unknown or uninitialised column: `x`.\n\n\n NULL\n\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt;  NULL\n\nExtract single columns with df[[\"col\"]].\n\nis.data.frame(df1)\n\n[1] TRUE\n\n#&gt; [1] TRUE\nis.data.frame(df2) # this is a tibble and it passes this test.\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nIf you want to distinguish:\n\nis_tibble(df1)\n\n[1] FALSE\n\n#&gt; [1] FALSE\nis_tibble(df2)\n\n[1] TRUE\n\n#&gt; [1] TRUE\n\nList Columns - since a data frame or a tibble is a list, it can contain other lists.\n\n# extra work is required to add a list to a data frame - either after creation or using I()\n\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\nList columns are easier to use in a tibble.\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n\n# A tibble: 3 × 2\n      x y        \n  &lt;int&gt; &lt;list&gt;   \n1     1 &lt;int [2]&gt;\n2     2 &lt;int [3]&gt;\n3     3 &lt;int [4]&gt;\n\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\nMatrix and data frame columns are possible, but not advised. The NROW() og the matrix must match the data frame number of rows.\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n\n'data.frame':   3 obs. of  3 variables:\n $ x: num  10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':  3 obs. of  2 variables:\n  ..$ a: int  3 2 1\n  ..$ b: chr  \"a\" \"b\" \"c\"\n\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\""
  },
  {
    "objectID": "chapter_03_notes.html#null",
    "href": "chapter_03_notes.html#null",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "Always length zero, and cannot have attributes. A unique type.\n\ntypeof(NULL)\n\n[1] \"NULL\"\n\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n\n[1] 0\n\n#&gt; [1] 0\n\nx &lt;- NULL\n# attr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL\n\nNULL represents an absent vector, whereas NA represents an absent element. NULL can be useful in default function arguments."
  },
  {
    "objectID": "chapter_01_notes.html",
    "href": "chapter_01_notes.html",
    "title": "Advanced R - Chapter 1 Notes",
    "section": "",
    "text": "R Pros and Cons\n\nPros\n\nfree, latest statistical techniques, purpose-built packages, community support\n\nCons\n\nslow, inconsistency in packages, focus on results instead of software engineering processes\n\n\n\n\nWhat You Will Learn\n\nUnderstand data types, functions, environments and how to use the condition system\nUnderstand what functional programming means\nKnow about object-oriented systems in R\nUnderstand metaprogramming\nUnderstand what slows R down or uses a lot of memory"
  },
  {
    "objectID": "chapter_02_notes.html",
    "href": "chapter_02_notes.html",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The distinction here allows prediction of when R will copy and object, with implications for performance and memory usage.\n\n\nlibrary(lobstr)\n\n\n\nThe assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x1857411c288\"\n\nobj_addr(y)\n\n[1] \"0x1857411c288\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c.\n\n\n\nWhen does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;000001856C4B0958&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x000001856c4b0958 -&gt; 0x000001857409f9a8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;000001857422A3C8&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x185742bf048] &lt;list&gt; \n├─[2:0x18571b07700] &lt;dbl&gt; \n├─[3:0x18571b07540] &lt;dbl&gt; \n└─[4:0x18571b07380] &lt;dbl&gt; \n \n█ [5:0x1857447c958] &lt;list&gt; \n├─[2:0x18571b07700] \n├─[3:0x18571b07540] \n└─[6:0x185723945f0] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” and then edited.\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x1857131f688] &lt;chr&gt; \n├─[2:0x18567d970e0] &lt;string: \"a\"&gt; \n├─[2:0x18567d970e0] \n├─[3:0x1857225b820] &lt;string: \"abc\"&gt; \n└─[4:0x1856c31e7e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;0000018574263C48&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x0000018574263c48 -&gt; 0x00000185742594c8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000185742594c8 -&gt; 0x00000185712be4b8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x1856ed97e48] &lt;list&gt; \n├─[2:0x1856f9d2dd0] &lt;int&gt; \n└─[2:0x1856f9d2dd0] \n \n█ [3:0x1856fb8aa08] &lt;list&gt; \n├─[1:0x1856ed97e48] \n├─[2:0x1856f9d2dd0] \n└─[4:0x1856f8c1858] &lt;int&gt; \n\n\n\n\n\n\nHow much memory does an object occupy? Use lobstr::obj_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\nAlternative representation means sequences of numbers are all the same size. Only the first and last numbers are stored.\n\nobj_size(1:5)\n\n680 B\n\nobj_size(1:1e6)\n\n680 B\n\n\n\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\n#&gt; 8005648 bytes\nobj_size(y)\n\n80.90 kB\n\n#&gt; 80.90 kB\n\n# obj_size account for alternative representation of sequences.\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n#&gt; 18.76 kB\n\n# The size is \"somewhat misleading\" because the size of lists refers to their names, not their objects?\n\n\na &lt;- runif(1e6)\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\nobj_size(b)\n\n8.00 MB\n\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n24.00 MB\n\n# alt rep sequences are aking up 8 MB, and here we copy-on-modify twice, \n# creating three 8 MB sequences for a total of 24 MB by the last line of code.\n\n\n\n\n\nThere are exceptions to copy-on-modify: single-named environments and objects. Objects with a single binding are performance optimized and environments are always modified in place.\n\nv &lt;- c(1, 2, 3)\nv[[3]] &lt;- 4 # modified in place\n\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nA slow for loop. Slow because the dataframe is being copied 15 times - 3 times per iteration.\n\ncat(tracemem(x), \"\\n\")\n\n&lt;0000018579177158&gt; \n\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\ntracemem[0x0000018579177158 -&gt; 0x000001857988af58]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988af58 -&gt; 0x000001857988aee8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988aee8 -&gt; 0x000001857988ae78]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ae78 -&gt; 0x000001857988ae08]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ae08 -&gt; 0x000001857988ad98]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ad98 -&gt; 0x000001857988ad28]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ad28 -&gt; 0x000001857988acb8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988acb8 -&gt; 0x000001857988ac48]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ac48 -&gt; 0x000001857988abd8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988abd8 -&gt; 0x000001857988ab68]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nUsing a list reduces the number of copies being made\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n\n&lt;0000018579F9FDC8&gt; \n\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\ntracemem[0x0000018579f9fdc8 -&gt; 0x000001857b2317a8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nEnvironments are always modified in place. This is referred to as reference semantics. Modifying an environment does not change the existing bindings within an environment.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nChanging a binding means the environment is modified in place. That is, after e1$c is modified, e2$c now points to the same object.\n\ne1$c &lt;- 4\ne2$c\n\n[1] 4\n\n#&gt; [1] 4\n\nEnvironments can contain themselves\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n\n█ [1:0x18576f1aeb0] &lt;env&gt; \n└─self = [1:0x18576f1aeb0] \n\n#&gt; █ [1:0x557140f86b08] &lt;env&gt; \n#&gt; └─self = [1:0x557140f86b08]\n\n\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n# Doesn't create a circular list because x is modified in place due to single binding?\n\n\n\n\n\nThe garbage collector frees memory from objects without a referenced name.\n\nx &lt;- 1:3\nx &lt;- 2:4\nrm(x)\n\nThe objects that x was bound to still exist. Use the garbage collector to get rid of them. This actually runs automatically when you need more memory, so you never need to run it yourself.\n\ngc() # it does tell you the memory being used, which can be useful\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1263366 67.5    2650288 141.6  2650288 141.6\nVcells 5823233 44.5   10146329  77.5  8384611  64.0\n\nmem_used()\n\n117.34 MB"
  },
  {
    "objectID": "chapter_02_notes.html#binding-basics",
    "href": "chapter_02_notes.html#binding-basics",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x1857411c288\"\n\nobj_addr(y)\n\n[1] \"0x1857411c288\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c."
  },
  {
    "objectID": "chapter_02_notes.html#copy-on-modify",
    "href": "chapter_02_notes.html#copy-on-modify",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "When does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;000001856C4B0958&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x000001856c4b0958 -&gt; 0x000001857409f9a8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;000001857422A3C8&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x185742bf048] &lt;list&gt; \n├─[2:0x18571b07700] &lt;dbl&gt; \n├─[3:0x18571b07540] &lt;dbl&gt; \n└─[4:0x18571b07380] &lt;dbl&gt; \n \n█ [5:0x1857447c958] &lt;list&gt; \n├─[2:0x18571b07700] \n├─[3:0x18571b07540] \n└─[6:0x185723945f0] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” and then edited.\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x1857131f688] &lt;chr&gt; \n├─[2:0x18567d970e0] &lt;string: \"a\"&gt; \n├─[2:0x18567d970e0] \n├─[3:0x1857225b820] &lt;string: \"abc\"&gt; \n└─[4:0x1856c31e7e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;0000018574263C48&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x0000018574263c48 -&gt; 0x00000185742594c8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000185742594c8 -&gt; 0x00000185712be4b8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x1856ed97e48] &lt;list&gt; \n├─[2:0x1856f9d2dd0] &lt;int&gt; \n└─[2:0x1856f9d2dd0] \n \n█ [3:0x1856fb8aa08] &lt;list&gt; \n├─[1:0x1856ed97e48] \n├─[2:0x1856f9d2dd0] \n└─[4:0x1856f8c1858] &lt;int&gt;"
  },
  {
    "objectID": "chapter_02_notes.html#object-size",
    "href": "chapter_02_notes.html#object-size",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "How much memory does an object occupy? Use lobstr::obj_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\nAlternative representation means sequences of numbers are all the same size. Only the first and last numbers are stored.\n\nobj_size(1:5)\n\n680 B\n\nobj_size(1:1e6)\n\n680 B\n\n\n\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\n#&gt; 8005648 bytes\nobj_size(y)\n\n80.90 kB\n\n#&gt; 80.90 kB\n\n# obj_size account for alternative representation of sequences.\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n#&gt; 18.76 kB\n\n# The size is \"somewhat misleading\" because the size of lists refers to their names, not their objects?\n\n\na &lt;- runif(1e6)\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\nobj_size(b)\n\n8.00 MB\n\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n24.00 MB\n\n# alt rep sequences are aking up 8 MB, and here we copy-on-modify twice, \n# creating three 8 MB sequences for a total of 24 MB by the last line of code."
  },
  {
    "objectID": "chapter_02_notes.html#modify-in-place",
    "href": "chapter_02_notes.html#modify-in-place",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "There are exceptions to copy-on-modify: single-named environments and objects. Objects with a single binding are performance optimized and environments are always modified in place.\n\nv &lt;- c(1, 2, 3)\nv[[3]] &lt;- 4 # modified in place\n\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nA slow for loop. Slow because the dataframe is being copied 15 times - 3 times per iteration.\n\ncat(tracemem(x), \"\\n\")\n\n&lt;0000018579177158&gt; \n\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\ntracemem[0x0000018579177158 -&gt; 0x000001857988af58]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988af58 -&gt; 0x000001857988aee8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988aee8 -&gt; 0x000001857988ae78]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ae78 -&gt; 0x000001857988ae08]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ae08 -&gt; 0x000001857988ad98]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ad98 -&gt; 0x000001857988ad28]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ad28 -&gt; 0x000001857988acb8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988acb8 -&gt; 0x000001857988ac48]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988ac48 -&gt; 0x000001857988abd8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x000001857988abd8 -&gt; 0x000001857988ab68]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nUsing a list reduces the number of copies being made\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n\n&lt;0000018579F9FDC8&gt; \n\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\ntracemem[0x0000018579f9fdc8 -&gt; 0x000001857b2317a8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nEnvironments are always modified in place. This is referred to as reference semantics. Modifying an environment does not change the existing bindings within an environment.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nChanging a binding means the environment is modified in place. That is, after e1$c is modified, e2$c now points to the same object.\n\ne1$c &lt;- 4\ne2$c\n\n[1] 4\n\n#&gt; [1] 4\n\nEnvironments can contain themselves\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n\n█ [1:0x18576f1aeb0] &lt;env&gt; \n└─self = [1:0x18576f1aeb0] \n\n#&gt; █ [1:0x557140f86b08] &lt;env&gt; \n#&gt; └─self = [1:0x557140f86b08]\n\n\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n# Doesn't create a circular list because x is modified in place due to single binding?"
  },
  {
    "objectID": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "href": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The garbage collector frees memory from objects without a referenced name.\n\nx &lt;- 1:3\nx &lt;- 2:4\nrm(x)\n\nThe objects that x was bound to still exist. Use the garbage collector to get rid of them. This actually runs automatically when you need more memory, so you never need to run it yourself.\n\ngc() # it does tell you the memory being used, which can be useful\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1263366 67.5    2650288 141.6  2650288 141.6\nVcells 5823233 44.5   10146329  77.5  8384611  64.0\n\nmem_used()\n\n117.34 MB"
  }
]