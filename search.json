[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Notebook",
    "section": "",
    "text": "Wickham (2019) Book Notes\nWickham’s book can be found here\n\nChapter 1 Notes\nChapter 2 Notes\nChapter 3 Notes\n\n\n\n\n\n\nReferences\n\nWickham, Hadley. 2019. Advanced R. 2nd Edition. New York: Chapman; Hall/CRC."
  },
  {
    "objectID": "chapter_02_notes.html",
    "href": "chapter_02_notes.html",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The distinction here allows prediction of when R will copy and object, with implications for performance and memory usage.\n\n\nlibrary(lobstr)\n\n\n\nThe assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x201e57bb408\"\n\nobj_addr(y)\n\n[1] \"0x201e57bb408\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c.\n\n\n\nWhen does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;00000201E55901E8&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x00000201e55901e8 -&gt; 0x00000201e5770818]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;00000201E5774868&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x201e579f7c8] &lt;list&gt; \n├─[2:0x201e580c468] &lt;dbl&gt; \n├─[3:0x201e580c2a8] &lt;dbl&gt; \n└─[4:0x201e580c0e8] &lt;dbl&gt; \n \n█ [5:0x201e535abd8] &lt;list&gt; \n├─[2:0x201e580c468] \n├─[3:0x201e580c2a8] \n└─[6:0x201e2235428] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” and then edited.\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x201e58b2468] &lt;chr&gt; \n├─[2:0x201d9dc10e0] &lt;string: \"a\"&gt; \n├─[2:0x201d9dc10e0] \n├─[3:0x201e5815e70] &lt;string: \"abc\"&gt; \n└─[4:0x201de32e7e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;00000201E518E708&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x00000201e518e708 -&gt; 0x00000201e529a3c8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e529a3c8 -&gt; 0x00000201e556b058]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x201e534ff48] &lt;list&gt; \n├─[2:0x201e265fb68] &lt;int&gt; \n└─[2:0x201e265fb68] \n \n█ [3:0x201e55566d8] &lt;list&gt; \n├─[1:0x201e534ff48] \n├─[2:0x201e265fb68] \n└─[4:0x201e2709380] &lt;int&gt; \n\n\n\n\n\n\nHow much memory does an object occupy? Use lobstr::obj_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\nAlternative representation means sequences of numbers are all the same size. Only the first and last numbers are stored.\n\nobj_size(1:5)\n\n680 B\n\nobj_size(1:1e6)\n\n680 B\n\n\n\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\n#&gt; 8005648 bytes\nobj_size(y)\n\n80.90 kB\n\n#&gt; 80.90 kB\n\n# obj_size account for alternative representation of sequences.\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n#&gt; 18.76 kB\n\n# The size is \"somewhat misleading\" because the size of lists refers to their names, not their objects?\n\n\na &lt;- runif(1e6)\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\nobj_size(b)\n\n8.00 MB\n\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n24.00 MB\n\n# alt rep sequences are aking up 8 MB, and here we copy-on-modify twice, \n# creating three 8 MB sequences for a total of 24 MB by the last line of code.\n\n\n\n\n\nThere are exceptions to copy-on-modify: single-named environments and objects. Objects with a single binding are performance optimized and environments are always modified in place.\n\nv &lt;- c(1, 2, 3)\nv[[3]] &lt;- 4 # modified in place\n\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nA slow for loop. Slow because the dataframe is being copied 15 times - 3 times per iteration.\n\ncat(tracemem(x), \"\\n\")\n\n&lt;00000201E5C56188&gt; \n\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\ntracemem[0x00000201e5c56188 -&gt; 0x00000201e9b5f4d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f4d8 -&gt; 0x00000201e9b5f468]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f468 -&gt; 0x00000201e9b5f3f8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f3f8 -&gt; 0x00000201e9b5f388]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f388 -&gt; 0x00000201e9b5f318]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f318 -&gt; 0x00000201e9b5f2a8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f2a8 -&gt; 0x00000201e9b5f238]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f238 -&gt; 0x00000201e9b5f1c8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f1c8 -&gt; 0x00000201e9b5f158]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f158 -&gt; 0x00000201e9b5f0e8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nUsing a list reduces the number of copies being made\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n\n&lt;00000201EA4B90A8&gt; \n\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\ntracemem[0x00000201ea4b90a8 -&gt; 0x00000201ea759bd8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nEnvironments are always modified in place. This is referred to as reference semantics. Modifying an environment does not change the existing bindings within an environment.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nChanging a binding means the environment is modified in place. That is, after e1$c is modified, e2$c now points to the same object.\n\ne1$c &lt;- 4\ne2$c\n\n[1] 4\n\n#&gt; [1] 4\n\nEnvironments can contain themselves\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n\n█ [1:0x201e823ae78] &lt;env&gt; \n└─self = [1:0x201e823ae78] \n\n#&gt; █ [1:0x557140f86b08] &lt;env&gt; \n#&gt; └─self = [1:0x557140f86b08]\n\n\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n# Doesn't create a circular list because x is modified in place due to single binding?\n\n\n\n\n\nThe garbage collector frees memory from objects without a referenced name.\n\nx &lt;- 1:3\nx &lt;- 2:4\nrm(x)\n\nThe objects that x was bound to still exist. Use the garbage collector to get rid of them. This actually runs automatically when you need more memory, so you never need to run it yourself.\n\ngc() # it does tell you the memory being used, which can be useful\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1262889 67.5    2641008 141.1  2641008 141.1\nVcells 5822050 44.5   10146329  77.5  8214326  62.7\n\nmem_used()\n\n117.30 MB"
  },
  {
    "objectID": "chapter_02_notes.html#binding-basics",
    "href": "chapter_02_notes.html#binding-basics",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x201e57bb408\"\n\nobj_addr(y)\n\n[1] \"0x201e57bb408\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c."
  },
  {
    "objectID": "chapter_02_notes.html#copy-on-modify",
    "href": "chapter_02_notes.html#copy-on-modify",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "When does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;00000201E55901E8&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x00000201e55901e8 -&gt; 0x00000201e5770818]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;00000201E5774868&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x201e579f7c8] &lt;list&gt; \n├─[2:0x201e580c468] &lt;dbl&gt; \n├─[3:0x201e580c2a8] &lt;dbl&gt; \n└─[4:0x201e580c0e8] &lt;dbl&gt; \n \n█ [5:0x201e535abd8] &lt;list&gt; \n├─[2:0x201e580c468] \n├─[3:0x201e580c2a8] \n└─[6:0x201e2235428] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” and then edited.\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x201e58b2468] &lt;chr&gt; \n├─[2:0x201d9dc10e0] &lt;string: \"a\"&gt; \n├─[2:0x201d9dc10e0] \n├─[3:0x201e5815e70] &lt;string: \"abc\"&gt; \n└─[4:0x201de32e7e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;00000201E518E708&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x00000201e518e708 -&gt; 0x00000201e529a3c8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e529a3c8 -&gt; 0x00000201e556b058]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x201e534ff48] &lt;list&gt; \n├─[2:0x201e265fb68] &lt;int&gt; \n└─[2:0x201e265fb68] \n \n█ [3:0x201e55566d8] &lt;list&gt; \n├─[1:0x201e534ff48] \n├─[2:0x201e265fb68] \n└─[4:0x201e2709380] &lt;int&gt;"
  },
  {
    "objectID": "chapter_02_notes.html#object-size",
    "href": "chapter_02_notes.html#object-size",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "How much memory does an object occupy? Use lobstr::obj_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\nAlternative representation means sequences of numbers are all the same size. Only the first and last numbers are stored.\n\nobj_size(1:5)\n\n680 B\n\nobj_size(1:1e6)\n\n680 B\n\n\n\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\n#&gt; 8005648 bytes\nobj_size(y)\n\n80.90 kB\n\n#&gt; 80.90 kB\n\n# obj_size account for alternative representation of sequences.\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n#&gt; 18.76 kB\n\n# The size is \"somewhat misleading\" because the size of lists refers to their names, not their objects?\n\n\na &lt;- runif(1e6)\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\nobj_size(b)\n\n8.00 MB\n\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n\n16.00 MB\n\nobj_size(a, b)\n\n24.00 MB\n\n# alt rep sequences are aking up 8 MB, and here we copy-on-modify twice, \n# creating three 8 MB sequences for a total of 24 MB by the last line of code."
  },
  {
    "objectID": "chapter_02_notes.html#modify-in-place",
    "href": "chapter_02_notes.html#modify-in-place",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "There are exceptions to copy-on-modify: single-named environments and objects. Objects with a single binding are performance optimized and environments are always modified in place.\n\nv &lt;- c(1, 2, 3)\nv[[3]] &lt;- 4 # modified in place\n\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nA slow for loop. Slow because the dataframe is being copied 15 times - 3 times per iteration.\n\ncat(tracemem(x), \"\\n\")\n\n&lt;00000201E5C56188&gt; \n\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\ntracemem[0x00000201e5c56188 -&gt; 0x00000201e9b5f4d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f4d8 -&gt; 0x00000201e9b5f468]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f468 -&gt; 0x00000201e9b5f3f8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f3f8 -&gt; 0x00000201e9b5f388]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f388 -&gt; 0x00000201e9b5f318]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f318 -&gt; 0x00000201e9b5f2a8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f2a8 -&gt; 0x00000201e9b5f238]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f238 -&gt; 0x00000201e9b5f1c8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f1c8 -&gt; 0x00000201e9b5f158]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x00000201e9b5f158 -&gt; 0x00000201e9b5f0e8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nUsing a list reduces the number of copies being made\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n\n&lt;00000201EA4B90A8&gt; \n\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\ntracemem[0x00000201ea4b90a8 -&gt; 0x00000201ea759bd8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nEnvironments are always modified in place. This is referred to as reference semantics. Modifying an environment does not change the existing bindings within an environment.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nChanging a binding means the environment is modified in place. That is, after e1$c is modified, e2$c now points to the same object.\n\ne1$c &lt;- 4\ne2$c\n\n[1] 4\n\n#&gt; [1] 4\n\nEnvironments can contain themselves\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n\n█ [1:0x201e823ae78] &lt;env&gt; \n└─self = [1:0x201e823ae78] \n\n#&gt; █ [1:0x557140f86b08] &lt;env&gt; \n#&gt; └─self = [1:0x557140f86b08]\n\n\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n# Doesn't create a circular list because x is modified in place due to single binding?"
  },
  {
    "objectID": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "href": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The garbage collector frees memory from objects without a referenced name.\n\nx &lt;- 1:3\nx &lt;- 2:4\nrm(x)\n\nThe objects that x was bound to still exist. Use the garbage collector to get rid of them. This actually runs automatically when you need more memory, so you never need to run it yourself.\n\ngc() # it does tell you the memory being used, which can be useful\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1262889 67.5    2641008 141.1  2641008 141.1\nVcells 5822050 44.5   10146329  77.5  8214326  62.7\n\nmem_used()\n\n117.30 MB"
  },
  {
    "objectID": "chapter_01_notes.html",
    "href": "chapter_01_notes.html",
    "title": "Advanced R - Chapter 1 Notes",
    "section": "",
    "text": "R Pros and Cons\n\nPros\n\nfree, latest statistical techniques, purpose-built packages, community support\n\nCons\n\nslow, inconsistency in packages, focus on results instead of software engineering processes\n\n\n\n\nWhat You Will Learn\n\nUnderstand data types, functions, environments and how to use the condition system\nUnderstand what functional programming means\nKnow about object-oriented systems in R\nUnderstand metaprogramming\nUnderstand what slows R down or uses a lot of memory"
  },
  {
    "objectID": "chapter_03_notes.html",
    "href": "chapter_03_notes.html",
    "title": "Advanced R - Chapter 3 Notes",
    "section": "",
    "text": "2 Vectors\n\nThe distinction here allows prediction of when R will copy and object, with implications for performance and memory usage."
  }
]