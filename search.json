[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Notebook",
    "section": "",
    "text": "Wickham (2019) Book Notes\nWickham’s book can be found here\n\nChapter 1 Notes\n\n\n\n\n\n\nReferences\n\nWickham, Hadley. 2019. Advanced R. 2nd Edition. New York: Chapman; Hall/CRC."
  },
  {
    "objectID": "chapter_01_notes.html",
    "href": "chapter_01_notes.html",
    "title": "Advanced R - Chapter 1 Notes",
    "section": "",
    "text": "R Pros and Cons\n\nPros\n\nfree, latest statistical techniques, purpose-built packages, community support\n\nCons\n\nslow, inconsistency in packages, focus on results instead of software engineering processes\n\n\n\n\nWhat You Will Learn\n\nUnderstand data types, functions, environments and how to use the condition system\nUnderstand what functional programming means\nKnow about object-oriented systems in R\nUnderstand metaprogramming\nUnderstand what slows R down or uses a lot of memory"
  },
  {
    "objectID": "chapter_02_notes.html",
    "href": "chapter_02_notes.html",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The distinction here allows prediction of when R will copy and object, with implications for performance and memory usage.\n\n\nlibrary(lobstr)\n\n\n\nThe assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x20433604468\"\n\nobj_addr(y)\n\n[1] \"0x20433604468\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c.\n\n\n\nWhen does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;00000204334B6AF8&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x00000204334b6af8 -&gt; 0x000002043350c008]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000020433633C78&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x2043360d2c8] &lt;list&gt; \n├─[2:0x20431c12f58] &lt;dbl&gt; \n├─[3:0x20431c12d60] &lt;dbl&gt; \n└─[4:0x20431c12b68] &lt;dbl&gt; \n \n█ [5:0x20433668408] &lt;list&gt; \n├─[2:0x20431c12f58] \n├─[3:0x20431c12d60] \n└─[6:0x20433771a88] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\n\n\nHow much memory does an object occupy?\n\n\n\nThere are exceptions to copy-on-modify: single-named environments and objects.\n\n\n\nThe garbage collector frees memory from objects without a referenced name."
  },
  {
    "objectID": "chapter_02_notes.html#binding-basics",
    "href": "chapter_02_notes.html#binding-basics",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x20433604468\"\n\nobj_addr(y)\n\n[1] \"0x20433604468\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c."
  },
  {
    "objectID": "chapter_02_notes.html#copy-on-modify",
    "href": "chapter_02_notes.html#copy-on-modify",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "When does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;00000204334B6AF8&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x00000204334b6af8 -&gt; 0x000002043350c008]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000020433633C78&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x2043360d2c8] &lt;list&gt; \n├─[2:0x20431c12f58] &lt;dbl&gt; \n├─[3:0x20431c12d60] &lt;dbl&gt; \n└─[4:0x20431c12b68] &lt;dbl&gt; \n \n█ [5:0x20433668408] &lt;list&gt; \n├─[2:0x20431c12f58] \n├─[3:0x20431c12d60] \n└─[6:0x20433771a88] &lt;dbl&gt; \n\n\nData frames are lists of vectors."
  },
  {
    "objectID": "chapter_02_notes.html#object-size",
    "href": "chapter_02_notes.html#object-size",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "How much memory does an object occupy?"
  },
  {
    "objectID": "chapter_02_notes.html#modify-in-place",
    "href": "chapter_02_notes.html#modify-in-place",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "There are exceptions to copy-on-modify: single-named environments and objects."
  },
  {
    "objectID": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "href": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The garbage collector frees memory from objects without a referenced name."
  }
]