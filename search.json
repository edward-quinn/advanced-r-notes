[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Notebook",
    "section": "",
    "text": "Wickham (2019) Book Notes\nWickham’s book can be found here\n\nChapter 1 Notes\nChapter 2 Notes\n\n\n\n\n\n\nReferences\n\nWickham, Hadley. 2019. Advanced R. 2nd Edition. New York: Chapman; Hall/CRC."
  },
  {
    "objectID": "chapter_01_notes.html",
    "href": "chapter_01_notes.html",
    "title": "Advanced R - Chapter 1 Notes",
    "section": "",
    "text": "R Pros and Cons\n\nPros\n\nfree, latest statistical techniques, purpose-built packages, community support\n\nCons\n\nslow, inconsistency in packages, focus on results instead of software engineering processes\n\n\n\n\nWhat You Will Learn\n\nUnderstand data types, functions, environments and how to use the condition system\nUnderstand what functional programming means\nKnow about object-oriented systems in R\nUnderstand metaprogramming\nUnderstand what slows R down or uses a lot of memory"
  },
  {
    "objectID": "chapter_02_notes.html",
    "href": "chapter_02_notes.html",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The distinction here allows prediction of when R will copy and object, with implications for performance and memory usage.\n\n\nlibrary(lobstr)\n\n\n\nThe assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x14aa6706508\"\n\nobj_addr(y)\n\n[1] \"0x14aa6706508\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c.\n\n\n\nWhen does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000014AA65BD548&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x0000014aa65bd548 -&gt; 0x0000014aa66116d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000014AA67196D8&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x14aa6768228] &lt;list&gt; \n├─[2:0x14aa4f11ea8] &lt;dbl&gt; \n├─[3:0x14aa4f11ce8] &lt;dbl&gt; \n└─[4:0x14aa4f11b28] &lt;dbl&gt; \n \n█ [5:0x14aa67b1368] &lt;list&gt; \n├─[2:0x14aa4f11ea8] \n├─[3:0x14aa4f11ce8] \n└─[6:0x14aa680d428] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” (and then edited?).\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x14aa68134f8] &lt;chr&gt; \n├─[2:0x14a99db90e0] &lt;string: \"a\"&gt; \n├─[2:0x14a99db90e0] \n├─[3:0x14aa4bae318] &lt;string: \"abc\"&gt; \n└─[4:0x14a9e3407e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;0000014AA67668C8&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x0000014aa67668c8 -&gt; 0x0000014aa675e248]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000014aa675e248 -&gt; 0x0000014aa6910328]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x14aa4a8b748] &lt;list&gt; \n├─[2:0x14a9fa6f778] &lt;int&gt; \n└─[2:0x14a9fa6f778] \n \n█ [3:0x14aa650edc8] &lt;list&gt; \n├─[1:0x14aa4a8b748] \n├─[2:0x14a9fa6f778] \n└─[4:0x14a9ec17c40] &lt;int&gt; \n\n\n\n\n\n\nHow much memory does an object occupy? Use lobstr::ojb_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B\n\n\n\n\nThere are exceptions to copy-on-modify: single-named environments and objects.\n\n\n\nThe garbage collector frees memory from objects without a referenced name."
  },
  {
    "objectID": "chapter_02_notes.html#binding-basics",
    "href": "chapter_02_notes.html#binding-basics",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The assignment operator &lt;- creates a reference between names and objects.\n\n# Assigns a name to a value\nx &lt;- c(1, 2, 3)\n\nWe have created an object and given it a name x.\n\n# Assigns another name to the same object/value. Does not create a new value.\ny &lt;- x\n\n\nobj_addr(x)\n\n[1] \"0x14aa6706508\"\n\nobj_addr(y)\n\n[1] \"0x14aa6706508\"\n\nidentical(obj_addr(x), obj_addr(y))\n\n[1] TRUE\n\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\na is name of the value or object 1:10. So are b and c. d is a name of an object different from the object with names a, b, and c."
  },
  {
    "objectID": "chapter_02_notes.html#copy-on-modify",
    "href": "chapter_02_notes.html#copy-on-modify",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "When does R make a copy?\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n\n[1] 1 2 3\n\n#&gt; [1] 1 2 3\n\nGenerally, R objects are immutable. So x wasn’t changed when y was modified. A new object was created and bound to y. This is what is meant by copy-on-modify.\ntracemem() tells you when an object is copied.\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000014AA65BD548&gt; \n\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\ntracemem[0x0000014aa65bd548 -&gt; 0x0000014aa66116d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\nModifying y again does not produce a copy. The object is modified in place.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nFunction calls follow the same copying rules.\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n&lt;0000014AA67196D8&gt; \n\n#&gt; &lt;0x557146b84928&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nWhen the function f() is run, the argument a becomes a binding to the object already bound to x. The name z now points to the same object as x. The object is never copied because it is never modified.\nHere is a list:\n\nl1 &lt;- list(1, 2, 3)\n\nThe list stores references to values. It does not store objects; it stores the names of objects.\n\nl2 &lt;- l1\n\nModifying a list creates a shallow copy. The list and its names are copied, but not the object the names point to.\n\nl2[[3]] &lt;- 4\n\nYou can see values shared across lists like so:\n\nlobstr::ref(l1, l2)\n\n█ [1:0x14aa6768228] &lt;list&gt; \n├─[2:0x14aa4f11ea8] &lt;dbl&gt; \n├─[3:0x14aa4f11ce8] &lt;dbl&gt; \n└─[4:0x14aa4f11b28] &lt;dbl&gt; \n \n█ [5:0x14aa67b1368] &lt;list&gt; \n├─[2:0x14aa4f11ea8] \n├─[3:0x14aa4f11ce8] \n└─[6:0x14aa680d428] &lt;dbl&gt; \n\n\nData frames are lists of vectors.\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\nIn this example, the object that is the first column is pointed to by both d1 and d2. Modifying a row means every column is modified, so each column must be “copied” (and then edited?).\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nR also uses references with character vectors (vectors of strings), which point to a global string pool.\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n\n█ [1:0x14aa68134f8] &lt;chr&gt; \n├─[2:0x14a99db90e0] &lt;string: \"a\"&gt; \n├─[2:0x14a99db90e0] \n├─[3:0x14aa4bae318] &lt;string: \"abc\"&gt; \n└─[4:0x14a9e3407e8] &lt;string: \"d\"&gt; \n\n\nBoth of the first two names point to the same object.\n\n\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;0000014AA67668C8&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x0000014aa67668c8 -&gt; 0x0000014aa675e248]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000014aa675e248 -&gt; 0x0000014aa6910328]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nlobstr::ref(b,c)\n\n█ [1:0x14aa4a8b748] &lt;list&gt; \n├─[2:0x14a9fa6f778] &lt;int&gt; \n└─[2:0x14a9fa6f778] \n \n█ [3:0x14aa650edc8] &lt;list&gt; \n├─[1:0x14aa4a8b748] \n├─[2:0x14a9fa6f778] \n└─[4:0x14a9ec17c40] &lt;int&gt;"
  },
  {
    "objectID": "chapter_02_notes.html#object-size",
    "href": "chapter_02_notes.html#object-size",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "How much memory does an object occupy? Use lobstr::ojb_size.\n\nobj_size(letters)\n\n1.71 kB\n\nobj_size(ggplot2::diamonds)\n\n3.46 MB\n\n\nLists are generally small since they are only references to values, not the values themselves.\n\nx &lt;- runif(1e6)\nobj_size(x)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n\n8.00 MB\n\n#&gt; 8.00 MB\n\nThanks to the global string pool, character vectors take up less memory than you might expect. Also, the size of two objects combined is much easier to figure out if there are no shared values.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n\n136 B\n\n#&gt; 136 B\nobj_size(rep(banana, 100))\n\n928 B\n\n#&gt; 928 B"
  },
  {
    "objectID": "chapter_02_notes.html#modify-in-place",
    "href": "chapter_02_notes.html#modify-in-place",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "There are exceptions to copy-on-modify: single-named environments and objects."
  },
  {
    "objectID": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "href": "chapter_02_notes.html#unbinding-and-the-garbage-collector",
    "title": "Advanced R - Chapter 2 Notes",
    "section": "",
    "text": "The garbage collector frees memory from objects without a referenced name."
  }
]