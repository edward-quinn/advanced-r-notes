---
title: Advanced R - Chapter 5 Notes
format:
  html:
      toc: true
---

# 5 Control Flow

-   Choices. Run different code depending on input.
-   Loops. Repeatedly run code, typically with changing options.

## 5.2 Choices

Section 5.2 dives into the details of if, then discusses the close relatives ifelse() and switch().

If condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.

```{r}

grade <- function(x) {
  if (x > 90) {
    "A"
  } else if (x > 80) {
    "B"
  } else if (x > 50) {
    "C"
  } else {
    "F"
  }
}

```

```{r}

x1 <- if (TRUE) 1 else 2
x2 <- if (FALSE) 1 else 2

c(x1, x2)
#> [1] 1 2

```


```{r}

greet <- function(name, birthday = FALSE) {
  paste0(
    "Hi ", name,
    if (birthday) " and HAPPY BIRTHDAY"
  )
}
greet("Maria", FALSE)
#> [1] "Hi Maria"
greet("Jaime", TRUE)
#> [1] "Hi Jaime and HAPPY BIRTHDAY"

```

The condition should evaluate to a single TRUE or FALSE

```{r}

# if ("x") 1
# #> Error in if ("x") 1: argument is not interpretable as logical
# if (logical()) 1
# #> Error in if (logical()) 1: argument is of length zero
# if (NA) 1
# #> Error in if (NA) 1: missing value where TRUE/FALSE needed
# if (c(TRUE, FALSE)) 1
# #> Error in if (c(TRUE, FALSE)) 1: the condition has length > 1

```


**Vectorized if**

What if you have more than one TRUE or FALSE value?

```{r}

x <- 1:10
ifelse(x %% 5 == 0, "XXX", as.character(x))
#>  [1] "1"   "2"   "3"   "4"   "XXX" "6"   "7"   "8"   "9"   "XXX"

ifelse(x %% 2 == 0, "even", "odd")
#>  [1] "odd"  "even" "odd"  "even" "odd"  "even" "odd"  "even" "odd"  "even"

```

`dplyr::case_when` is another vectorized if

```{r}

dplyr::case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  is.na(x) ~ "???",
  TRUE ~ as.character(x)
)
#>  [1] "1"    "2"    "3"    "4"    "fizz" "6"    "buzz" "8"    "9"    "fizz"

```


`if()` statements can be made more compact with `switch()`

```{r}

x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}

```

```{r}

x_option <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    # The last component of a switch() should always throw 
    # an error, otherwise unmatched inputs will invisibly return NULL
    stop("Invalid `x` value") 
  )
}

```

If multiple inputs have the same output, you can leave the RHS of `=` empty until the last input with the same output

```{r}

legs <- function(x) {
  switch(x,
    cow = ,
    horse = ,
    dog = 4,
    human = ,
    chicken = 2,
    plant = 0,
    stop("Unknown input")
  )
}
legs("cow")
#> [1] 4
legs("dog")
#> [1] 4

```

## 5.3 Loops

Section 5.3 starts off by reminding you of the basic structure of the for loop in R, discusses some common pitfalls, and then talks about the related while and repeat statements.

Basic structure: for (item in vector) perform_action

```{r}

for (i in 1:3) {
  print(i)
}
#> [1] 1
#> [1] 2
#> [1] 3

```

N.B.: for assigns the item to the current environment, overwriting any existing variable with the same name:


```{r}

i <- 100
for (i in 1:3) {}
i
#> [1] 3

```

You can use `next` to exit the current iteration and `break` to exit the entire `for` loop.


```{r}

for (i in 1:10) {
  if (i < 3) 
    next

  print(i)
  
  if (i >= 5)
    break
}
#> [1] 3
#> [1] 4
#> [1] 5

```

**Common Pitfalls** when using `for` loops

1. If you are generating data, pre-allocate the output container. This improves speed.


```{r}

means <- c(1, 50, 20)
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}

```


2. Beware of iterating over `1:length(x)`, which will fail in unhelpful ways if `x` has length 0. 

```{r}

# means <- c()
# out <- vector("list", length(means))
# for (i in 1:length(means)) {
#   out[[i]] <- rnorm(10, means[[i]])
# }
# #> Error in rnorm(10, means[[i]]): invalid arguments

```

Use `seq_along()` instead.


```{r}

seq_along(means)
#> integer(0)

out <- vector("list", length(means))
for (i in seq_along(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}

```

3. Call `[[` yourself when iterating over S3 vectors, as loops typically strip the attributes


```{r}

xs <- as.Date(c("2020-01-01", "2010-01-01"))
for (x in xs) {
  print(x)
}
#> [1] 18262
#> [1] 14610

```

Here's the fix:


```{r}

for (i in seq_along(xs)) {
  print(xs[[i]])
}
#> [1] "2020-01-01"
#> [1] "2010-01-01"

```