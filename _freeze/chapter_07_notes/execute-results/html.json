{
  "hash": "c577036aa9691d3ae62b88db372406e5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Advanced R - Chapter 7 Notes\nformat:\n  html:\n      toc: true\nfreeze: true\n---\n\n# 7 Environments\n\n## 7.2 Environment basics\n\nSection 7.2 introduces you to the basic properties of an environment and shows you how to create your own.\n\nAn environment is similar to a named list, with four exceptions:\n1. every name must be unique\n2. the names in an environment are not ordered.\n3. An enviornment has a parent.\n4. Environments are not copied when modified\n\nTo create an environment, use `rlang::env()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\n\ne1 <- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n```\n:::\n\n\nThe job of an environment is to **bind** a set of names to a set of values. \n\nEnvironments can contain themselves:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne1$d <- e1\n\nenv_print(e1) # note the env in d\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: 0x000002eb1ac5a7e0>\nParent: <environment: global>\nBindings:\n• a: <lgl>\n• b: <chr>\n• c: <dbl>\n• d: <env>\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the names of an environment\nenv_names(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# find out what the current environment is\ncurrent_env()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\n# or use environment()\nenvironment()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\n# compare environments with identical()\nidentical(global_env(), current_env())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nEvery environment has a **parent**. Set the parent by supplying an unnamed argument to `env()`. The parent is what's used to implement lexical scoping.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne2a <- env(d = 4, e = 5)\ne2b <- env(e2a, a = 1, b = 2, c = 3)\n\nenv_parent(e2a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\nenv_parent(e2b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: 0x000002eb17d965f0>\n```\n\n\n:::\n:::\n\n\nOnly the **empty environment** doesn't have a parent\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne2c <- env(empty_env(), d = 4, e = 5)\ne2d <- env(e2c, a = 1, b = 2, c = 3)\n\ne2c <- env(empty_env(), d = 4, e = 5)\ne2d <- env(e2c, a = 1, b = 2, c = 3)\n\nenv_parents(e2b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]   <env: 0x000002eb17d965f0>\n[[2]] $ <env: global>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [[1]]   <env: 0x559735c4a248>\n#> [[2]] $ <env: global>\nenv_parents(e2d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]   <env: 0x000002eb19536660>\n[[2]] $ <env: empty>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [[1]]   <env: 0x5597366d1bf8>\n#> [[2]] $ <env: empty>\n```\n:::\n\n\n`env_parents()` stops when it gets to the global environment.\n\n**Super assignment**\n\n`<<-` never creates a variable in the current environment, but instead modifies an existing variable found in a parent environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nf <- function() {\n  x <<- 1\n}\nf()\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\n```\n:::\n\n\nGetting and setting elements of an environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne3 <- env(x = 1, y = 2)\ne3$x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\ne3$z <- 3\ne3[[\"z\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3\n```\n:::\n\n\nYou can't subset with numeric indices and you can't use `[`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# e3[[1]]\n# #> Error in e3[[1]]: wrong arguments for subsetting an environment\n\n# e3[c(\"x\", \"y\")]\n# #> Error in e3[c(\"x\", \"y\")]: object of type 'environment' is not subsettable\n```\n:::\n\n\nOther ways to add bindings to an environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_poke(e3, \"a\", 100)\ne3$a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 100\n```\n:::\n\n\n`env_bind()` allows binding of multiple values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x\" \"y\" \"z\" \"a\" \"b\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"x\" \"y\" \"z\" \"a\" \"b\"\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_has(e3, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   a \nTRUE \n```\n\n\n:::\n\n```{.r .cell-code}\n#>    a \n#> TRUE\n\n# To unbind:\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    a \nFALSE \n```\n\n\n:::\n:::\n\n\n\n**Advanced bindings**\n\n`env_bind_lazy() creates **delayed bindings**, which are evaluated the first time they are acessed. Delayed bindings create promises. See how the value is computed once, the first time it is accessed, then it is cached and returned immediately upon later calls.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n   0.00    0.00    1.01 \n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#>    user  system elapsed \n#>       0       0       1\nsystem.time(print(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n      0       0       0 \n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#>    user  system elapsed \n#>       0       0       0\n```\n:::\n\n\nThe primary use for delayed bindings is in `autoload()`, which allows R packages to provide datasets that behave like they are loaded in memory, even though they're only loaded from disk when needed.\n\n`env_bind_active()` creates active bindings, which are recomputed every time they're accessed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3944286\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0.0808\nz1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4796495\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0.834\n```\n:::\n\n\n## 7.3 recursing over environments\n\nSection 7.3 provides a function template for computing with environments, illustrating the idea with a useful function.\n\nFor example, you could search for the name of function and start the search at a child environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhere <- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n```\n:::\n\n\nIllustrate the cases where a name can't be found, where it is found, and then where it is recursively searched for:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# where(\"yyy\")\n# #> Error: Can't find yyy\n\nx <- 5\nwhere(\"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> <environment: R_GlobalEnv>\n\nwhere(\"mean\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: base>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> <environment: base>\n```\n:::\n\n\nYou could rewrite `where()` as a for loop instead of a recursive function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf2 <- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # success case\n      return()\n    }\n    # inspect parent\n    env <- env_parent(env)\n  }\n\n  # base case\n}\n```\n:::\n\n\n## 7.4 Special environments\n\nSection 7.4 describes environments used for special purposes: for packages, within functions, for namespaces, and for function execution.\n\nEach package attached by `library()` or `require()` becomes one of the parents of the global environment. Packages loaded (not attached) with `::` do not become parents. The immediate parent of the global environment is the last package you attached., the parent of that package is the second to last package you attached.\n\nFollow all the packages back in the order in which they were attached - this gives the **search path**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# You can see the names of these environments with:\n\nbase::search()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n [4] \"package:graphics\"  \"package:grDevices\" \"package:datasets\" \n [7] \"renv:shims\"        \"package:utils\"     \"package:methods\"  \n[10] \"Autoloads\"         \"package:base\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::search_envs()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [[1]] $ <env: global>\n [[2]] $ <env: package:rlang>\n [[3]] $ <env: package:stats>\n [[4]] $ <env: package:graphics>\n [[5]] $ <env: package:grDevices>\n [[6]] $ <env: package:datasets>\n [[7]] $ <env: renv:shims>\n [[8]] $ <env: package:utils>\n [[9]] $ <env: package:methods>\n[[10]] $ <env: Autoloads>\n[[11]] $ <env: package:base>\n```\n\n\n:::\n:::\n\n\nThe last two environments on the search path are always the same:\n1. The `Autoloads()` environment uses delayed bindings to save memory by only loading package objects (like big datasets) when needed.\n2. The base environment. It is special because it has to be able to bootstrap the loading of all other packages. You can access it directly with `base_env()`.\n\n\n\n**The function environment**\n\nA function binds the current environment. Functions that capture their environments are called closures. Sometimes the word *function* and *closure* are used interchangeably in R documentation.\n\nGet the function environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 1\nf <- function(x) x + y\nfn_env(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> <environment: R_GlobalEnv>\n```\n:::\n\n\n`f()` binds the environment that binds the name `f` to the function. Not always the case. In the code below, `g()` binds the global environment, but `g` is bound in a new environment `e()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- env()\ne$g <- function() 1\n```\n:::\n\n\n**Namespaces** ensure that you don't find different functions based on the order in which pacakges were loaded. Every function is associated with a package enviornment and the **namespace** environment.\n\n- The package environment is the external interface to the package. It's how you, the R user, find a function in ana attached package or with `::`. Its parent is determined by search path, i.e. the order in whic packages have been attached.\n\n- The namespace environment is the internal interface to the package. The package environment controls how we find the function; the namespace controls how the functions finds its variables.\n\nEvery binding in the package environment is also found in the namespace environment; this ensures every function can use every other function in the package. Not all bindings in the namespace are in the package environment - this allows one to hide internals of a package from the user.\n\nEvery namespace environment has the same set of ancestors:\n\nEach namespace has an imports environment that contains bindings to all the functions used by the package. The imports environment is controlled by the package developer with the NAMESPACE file.\n\nExplicitly importing every base function would be tiresome, so the parent of the imports environment is the base namespace. The base namespace contains the same bindings as the base environment, but it has a different parent.\n\nThe parent of the base namespace is the global environment. This means that if a binding isn’t defined in the imports environment the package will look for it in the usual way. This is usually a bad idea (because it makes code depend on other loaded packages), so R CMD check automatically warns about such code. It is needed primarily for historical reasons, particularly due to how S3 method dispatch works.\n\n**Execution Environments**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\n\ng(10)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining a\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Defining a\n#> [1] 1\ng(10)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining a\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Defining a\n#> [1] 1\n```\n:::\n\n\nThis function returns the same value each time because of the fresh start principle. Each time a function is called, a new enrionment is created to host execution. This is called the execution environment, and its parent is the function environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- function(x) {\n  # 1. The function called with x = 1\n  a <- 2 # 2. a is bound to value 2\n  x + a\n}\ny <- h(1) # 3. Functio completes returning value 3. Execution environment goes away.\n```\n:::\n\n\n\nExecution environments are usually ephemeral and garbage collected, but you can make it stay around.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh2 <- function(x) {\n  a <- x * 2\n  current_env()\n}\n\ne <- h2(x = 10)\nenv_print(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: 0x000002eb1df8fbd0>\nParent: <environment: global>\nBindings:\n• a: <dbl>\n• x: <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> <environment: 0x559733944920>\n#> Parent: <environment: global>\n#> Bindings:\n#> • a: <dbl>\n#> • x: <dbl>\nfn_env(h2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> <environment: R_GlobalEnv>\n```\n:::\n\n\nYou can also return an object with a binding to that environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplus <- function(x) {\n  function(y) x + y\n}\n\nplus_one <- plus(1)\nplus_one\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (y) \nx + y\n<environment: 0x000002eb1bc9f850>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> function (y) \n#> x + y\n#> <environment: 0x559737ab06b8>\n```\n:::\n\n\n## 7.5 Call stacks\n\nSection 7.5 explains the last important environment: the caller environment. This requires you to learn about the call stack, that describes how a function was called. You’ll have seen the call stack if you’ve ever called traceback() to aid debugging.\n\n**Caller environment** is accessed with `rlang::caller_env()`. This provides the environment from which the function was called. `parent.frame()` is equivalent to `caller_env()`, but it returns an environment, not a frame.\n\nTo understand the **caller environment**, we need to understand:\n1. the **call stack**\n2. **frames**\n\nExecuting a function creates two types of context: \n1. the execution environment, which is a child of the function environment, which is determined by where the function was created.\n2. the call stack, which is created by where the function is called.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  g(x = 2)\n}\ng <- function(x) {\n  h(x = 3)\n}\nh <- function(x) {\n  stop()\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# f(x = 1)\n# #> Error:\n# traceback()\n# #> 4: stop()\n# #> 3: h(x = 3) \n# #> 2: g(x = 2)\n# #> 1: f(x = 1)\n```\n:::\n\n\nUse `lobstr::cst()` to print out the **c**all **s**tack **t**ree.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    ▆\n 1. └─global f(x = 1)\n 2.   └─global g(x = 2)\n 3.     └─global h(x = 3)\n 4.       └─lobstr::cst()\n```\n\n\n:::\n\n```{.r .cell-code}\n#> █\n#> └─f(x = 1)\n#>   └─g(x = 2)\n#>     └─h(x = 3)\n#>       └─lobstr::cst()\n```\n:::\n\n\nThings get more complicated with lazy evaluation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a <- function(x) b(x)\n# b <- function(x) c(x)\n# c <- function(x) x\n\n# a(f())\n#> █\n#> ├─a(f())\n#> │ └─b(x)\n#> │   └─c(x)\n#> └─f()\n#>   └─g(x = 2)\n#>     └─h(x = 3)\n#>       └─lobstr::cst()\n```\n:::\n\n\n`c()` is evaluated in the global environment, not the function environment. This results in two branches in the call stack tree.\n\nEach element of the call stack is a **frame**, also known as an evaluation context. A frame has three key components:\n1. An expression (labelled with `expr`) giving the function call. This is what `traceback()` prints out.\n2. An environment (labelled with `env`), which is typically the execution environment of a function. There are two main exceptions: the environment of the glbal frame is the global environment, and calling `eval()` also generates frames, where the environment can be anything.\n3. A parent, the previous call in the call stack.\n\n## As data structures\n\nSection 7.6 briefly discusses three places where environments are useful data structures for solving other problems.\n\nEnvironment power scoping, and they are useful because they have reference semantics. Three problems they help solve:\n\n1. Avoiding copies of large data\n2. Managing state within a package\n3. As a hashmap\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}