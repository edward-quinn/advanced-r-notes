{
  "hash": "135b77e96f79f880b0dbff9420f2ecfd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Advanced R - Chapter 6 Notes\nformat:\n  html:\n      toc: true\nfreeze: true\n---\n\n# 6 Functions\n\n## 6.2 Function Fundamentals\n\nSection 6.2 describes the basics of creating a function, the three main components of a function, and the exception to many function rules: primitive functions (which are implemented in C, not R).\n\nFunctions are objects, just like vectors.\n\nParts of a function\n- The `formals()`, the list of arguments that control how you call the function\n- The `body()`, the code inside the function\n- The `environment()`, the data structure that determines how the function finds the values associated with the names.\n\nYou specify the formals and body, but the environment is implicitly specified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf02 <- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n\n\n$y\n```\n\n\n:::\n\n```{.r .cell-code}\n#> $x\n#> \n#> \n#> $y\n\nbody(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{\n    x + y\n}\n```\n\n\n:::\n\n```{.r .cell-code}\n#> {\n#>     x + y\n#> }\n\nenvironment(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> <environment: R_GlobalEnv>\n```\n:::\n\n\nFunctions can posses attributes.\n\nThere is one exception to the rule that a function has three components. Primitive functions like `sum()` and `[` call C code directly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n```\n\n\n:::\n\n```{.r .cell-code}\n#> function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.Primitive(\"[\")\n```\n\n\n:::\n\n```{.r .cell-code}\n#> .Primitive(\"[\")\n\n# they are types 'builtin' or 'special'\n\ntypeof(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"builtin\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"builtin\"\ntypeof(`[`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"special\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"special\"\n\n# because they exist in C, their formals, body, and environment are NULL\n\nformals(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> NULL\nbody(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> NULL\nenvironment(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> NULL\n```\n:::\n\n\n\n**First-class functions** just means R functions are objects. They don't require special syntax to define.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf01 <- function(x) {\n  sin(1 / x ^ 2)\n}\n```\n:::\n\n\n\n\nNaming functions is not strictly necessary. Unnamed functions are called **anonymous functions**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(mtcars, function(x) length(unique(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$mpg\n[1] 25\n\n$cyl\n[1] 3\n\n$disp\n[1] 27\n\n$hp\n[1] 22\n\n$drat\n[1] 22\n\n$wt\n[1] 29\n\n$qsec\n[1] 30\n\n$vs\n[1] 2\n\n$am\n[1] 2\n\n$gear\n[1] 3\n\n$carb\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nFilter(function(x) !is.numeric(x), mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata frame with 0 columns and 32 rows\n```\n\n\n:::\n\n```{.r .cell-code}\nintegrate(function(x) sin(x) ^ 2, 0, pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.570796 with absolute error < 1.7e-14\n```\n\n\n:::\n:::\n\n\nFunctions can be contained in a list\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfuns <- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\n\nfuns$double(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 20\n```\n:::\n\n\nIf you already have the arguments in a data structure, you can use `do.call()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs <- list(1:10, na.rm = TRUE)\n\ndo.call(mean, args)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 5.5\n```\n:::\n\n\n\n\n## Function Composition\n\nSection 6.3 discusses the strengths and weaknesses of the three forms of function composition commonly used in R code.\n\nYou can nest function calls or save intermediate results as variables. You can also pipe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) x^2\ndeviation <- function(x) x - mean(x)\nx <- runif(100)\n\nsqrt(mean(square(deviation(x))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2979194\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0.274\n\nout <- deviation(x)\nout <- square(out)\nout <- mean(out)\nout <- sqrt(out)\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2979194\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0.274\n```\n:::\n\n\n## Lexical scoping\n\nSection 6.4 shows you how R finds the value associated with a given name, i.e. the rules of lexical scoping.\n\n**Scoping** is finding the value associated with a name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ng01 <- function() {\n  x <- 20\n  x\n}\n\ng01()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\nR uses **lexical scoping**: it looks up the values of names based on how a function is defined, not how it is called. \"Lexical\" indicates that the scoping rules use a parse-time, rather than a run-time structure.\n\nR's lexical scoping follows four primary rules:\n1. Name masking\n2. Functions versus variables\n3. A fresh start\n4. Dynmamic lookup\n\nNames defined inside a function mask names defined outside a function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 20\ng02 <- function() {\n  x <- 1\n  y <- 2\n  c(x, y)\n}\ng02()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1 2\n```\n:::\n\n\n\nIf a name isn't defined inside a function, R looks one level up.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\ng03 <- function() {\n  y <- 1\n  c(x, y)\n}\ng03()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2 1\n\n# And this doesn't change the previous value of y\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 20\n```\n:::\n\n\nThe same rules apply for a function defined inside of another function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ng04 <- function() {\n  y <- 2\n  i <- function() {\n    z <- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\nThe same scoping rules apply to functions themselves, not just the arguments or body of a function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng07 <- function(x) x + 1\ng08 <- function() {\n  g07 <- function(x) x + 100\n  g07(10)\n}\ng08()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 110\n```\n:::\n\n\n\nA fresh start\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng11 <- function() {\n  if (!exists(\"a\")) {\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\n\ng11()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\ng11()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n`g11()` always returns the same value because every time a function is called a new environment is created to host its execution.\n\nR looks fo r values when a function is run, not when the function is created.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng12 <- function() x + 1\nx <- 15\ng12()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 16\n\nx <- 20\ng12()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 21\n```\n:::\n\n\n## Lazy evaluation\n\nSection 6.5 is devoted to an important property of function arguments: they are only evaluated when used for the first time. Evaluation only takes place for function arguments when they are accessed.\n\nLazy evaluation powered by promises, which have three components: \n1. An expression, like `x + y` which gives rise to the delayed computation\n2. An environment where the expression should be evaluated\n3. A value, which is computed and cached the first time a promise is accessed when the expression is evaluated in the specified environment.\n\nLazy evaluation allows default values to be defined in terms of other arguments, or in terms of variables defined later in the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh04 <- function(x = 1, y = x * 2, z = a + b) {\n  a <- 10\n  b <- 100\n  \n  c(x, y, z)\n}\n\nh04()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   1   2 110\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1]   1   2 110\n```\n:::\n\n\nThis technique is not recommended. Default and user supplied arguments have slightly different evaluation environments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh05 <- function(x = ls()) {\n  a <- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"x\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"a\" \"x\"\n\n# ls() evaluated in global environment:\nh05(ls())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"args\"      \"deviation\" \"f01\"       \"f02\"       \"funs\"      \"g01\"      \n [7] \"g02\"       \"g03\"       \"g04\"       \"g07\"       \"g08\"       \"g11\"      \n[13] \"g12\"       \"h04\"       \"h05\"       \"out\"       \"square\"    \"x\"        \n[19] \"y\"        \n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"h05\"\n```\n:::\n\n\nTo determine is an argument's value comes from the user or from a default, you can use `missing()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh06 <- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ : logi TRUE\n $ : num 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ : logi TRUE\n#>  $ : num 10\nstr(h06(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ : logi FALSE\n $ : num 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ : logi FALSE\n#>  $ : num 10\n```\n:::\n\n\nI don't get how `missing()` is working here.\n\n## ... (dot-dot-dot)\n\nSection 6.6 discusses the special ... argument, which allows you to pass on extra arguments to another function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni01 <- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 <- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ y: num 2\n $ z: num 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ y: num 2\n#>  $ z: num 3\n```\n:::\n\n\n`list(...)` evaluates the arguments and stores them in a list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni04 <- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ a: num 1\n $ b: num 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ a: num 1\n#>  $ b: num 2\n```\n:::\n\n\nThere are two primary uses of `...`:\n1. When a function takes a function as an argument, you need a way to pass additional arguments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ : num 2\n $ : num 5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ : num 2\n#>  $ : num 5\n```\n:::\n\n\n2. To allow S3 objects to take arbitray extra arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(factor(letters), max.levels = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n26 Levels: a b c ... z\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(y ~ x, showEnv = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ny ~ x\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\nThere are disadvantages of using `...`:\n\n1. Must explain where arguments go\n2. A misspelled argument does not raise an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1, 2, NA, na_rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] NA\n```\n:::\n\n\n## 6.7 Exiting a function\n\nSection 6.7 discusses the two primary ways that a function can exit, and how to define an exit handler, code that is run on exit, regardless of what triggers it.\n\nMost functions exit by returning a value or throwing an error.\n\nReturns can be implicit or explicit. With the implicit method, the last evaluated expression is returned:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj01 <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0\nj01(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 10\n```\n:::\n\n\nUse `return()` to be explicit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj02 <- function(x) {\n  if (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\n\nj02(11)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\nMost functions return visibly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj03 <- function() 1\nj03()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\n```\n:::\n\n\nbut you can turn off automatic printing with `invisible()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj04 <- function() invisible(1)\nj04()\n```\n:::\n\n\nThe most common function that returns invisibly is `<-`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\n(a <- 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2\n```\n:::\n\n\n**Errors**. If a function cannot complete its assigned task, it should throw an error with `stop()`. This immediately terminates the execution of a function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# j05 <- function() {\n#   stop(\"I'm an error\")\n#   return(10)\n# }\n# j05()\n# #> Error in j05(): I'm an error\n```\n:::\n\n\nuse `on.exit()` to restore an environment after altering it inside of a function. Now you can place clean-up code next to the code that requires clean-up:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# cleanup <- function(dir, code) {\n#   old_dir <- setwd(dir)\n#   on.exit(setwd(old_dir), add = TRUE)\n  \n#   old_opt <- options(stringsAsFactors = FALSE)\n#   on.exit(options(old_opt), add = TRUE)\n# }\n```\n:::\n\n\n\n## 6.8 Function forms\n\nSection 6.8 shows you the various ways in which R disguises ordinary function calls, and how you can use the standard prefix form to better understand whatâ€™s going on.\n\nFunction calls come in four varieties:\n\n1. prefix: the function name comes before the arguments\n2. infix: the function name comes in between the arguments, like `x + y`\n3. replacement: functions that replace values by assignment, like `names(df)`\n4. special: functions like `[[`, `if`, and `for`. No consistent structure but important.\n\nAll can be written in prefix form.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# x + y\n# `+`(x, y)\n\n# names(df) <- c(\"x\", \"y\", \"z\")\n# `names<-`(df, c(\"x\", \"y\", \"z\"))\n\n# for(i in 1:10) print(i)\n# `for`(i, 1:10, print(i))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y) x + y\nlapply(list(1:3, 4:5), add, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 4 5 6\n\n[[2]]\n[1] 7 8\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [[1]]\n#> [1] 4 5 6\n#> \n#> [[2]]\n#> [1] 7 8\n```\n:::\n\n\nis the same as...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(list(1:3, 4:5), `+`, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 4 5 6\n\n[[2]]\n[1] 7 8\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [[1]]\n#> [1] 4 5 6\n#> \n#> [[2]]\n#> [1] 7 8\n```\n:::\n\n\n**Prefix form**\n\nYOu can specify arguments in three ways with the prefix form:\n1. by position\n2. partial matching\n3. by name\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk01 <- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\nstr(k01(1, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\nstr(k01(2, 3, abcdef = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\n\n# Can abbreviate long argument names:\nstr(k01(2, 3, a = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ a : num 1\n $ b1: num 2\n $ b2: num 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\n\n# # But this doesn't work because abbreviation is ambiguous\n# str(k01(1, 3, b = 1))\n# #> Error in k01(1, 3, b = 1): argument 3 matches multiple formal arguments\n```\n:::\n\n\n**infix functions** are functions that come in between its arguments, and therefore have two arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`%+%` <- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"new string\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"new string\"\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`% %` <- function(a, b) paste(a, b)\n`%/\\\\%` <- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a b\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"a b\"\n\"a\" %/\\% \"b\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a b\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"a b\"\n```\n:::\n\n\n**Replacement functions** act like they modify their arguments in place, and have the special name `xxx<-`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`second<-` <- function(x, value) {\n  x[2] <- value\n  x\n}\n\nx <- 1:10\nsecond(x) <- 5L\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  5  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1]  1  5  3  4  5  6  7  8  9 10\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ntracemem(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"<000001D9D6934B30>\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> <0x7ffae71bd880>\n\nsecond(x) <- 6L\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntracemem[0x000001d9d6934b30 -> 0x000001d9da116938]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options <Anonymous> process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x000001d9da116938 -> 0x000001d9da1077a8]: second<- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options <Anonymous> process_file <Anonymous> <Anonymous> execute .main \n```\n\n\n:::\n\n```{.r .cell-code}\n#> tracemem[0x7ffae71bd880 -> 0x7ffae61b5480]: \n#> tracemem[0x7ffae61b5480 -> 0x7ffae73f0408]: second<- \n```\n:::\n\n\n**Special forms**\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}