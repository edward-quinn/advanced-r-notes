{
  "hash": "fda0e1b0d6444d917b937bb992f99b06",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Advanced R - Chapter 3 Notes\nfreeze: true\nformat:\n  html:\n      toc: true\n---\n\n# 3 Vectors\n-   atomic vectors. elements are all the same type.\n-   lists (sometimes called generic vectors). elements can vary by type.\n\n**Attributes** - named list of metadata\n-   **dimension** turns vectors into matrices and arrays\n-   **class** powers the S3 object system\n\n## 3.2 Atomic vectors\n\nSection 3.2 introduces you to the atomic vectors: logical, integer, double, and character. These are R’s simplest data structures.\n\nInteger and double are inconsistently referred to as numeric. There are also two rare types: complex and raw.\n\nEach of the four primary types has a special syntax to create an individual value (a scalar).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Logicals\nTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nT\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nF\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Doubles\n0.1234\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1234\n```\n\n\n:::\n\n```{.r .cell-code}\n1.234e-1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1234\n```\n\n\n:::\n\n```{.r .cell-code}\n## special values unique to double\nInf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n-Inf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -Inf\n```\n\n\n:::\n\n```{.r .cell-code}\nNaN\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\n# Integers\n## can be written like a double, but must use L, which represents a long integer in C\n1234L\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1234\n```\n\n\n:::\n\n```{.r .cell-code}\n1e4L\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Strings\n## require single or double quotes. special characters escaped with \\\n\"hi there\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hi there\"\n```\n\n\n:::\n:::\n\n\ncombine vectors with `c()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlgl_var <- c(TRUE, FALSE)\nint_var <- c(1L, 6L, 10L)\ndbl_var <- c(1, 2.5, 4.5)\nchr_var <- c(\"these are\", \"some strings\")\n\nc(c(1, 2), c(3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1 2 3 4\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(lgl_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"logical\"\ntypeof(int_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"integer\"\ntypeof(dbl_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"double\"\ntypeof(chr_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"character\"\n```\n:::\n\n\nmissing values are represented with a sentinal value `NA`, which are infectious unless some identity holds for all possible inputs\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] NA\n10 * NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] NA\n!NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] NA\n\nNA ^ 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\nNA | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\nNA & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# which values are missing? use is.na()\nx <- c(NA, 5, NA, 10)\nx == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] NA NA NA NA\n\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1]  TRUE FALSE  TRUE FALSE\n\n# There are four missing values, one for each atomic vector type\n```\n:::\n\n\nvectors always have one type and will be coerced in a standard order to a single type if you combine multiple vectors of different types: character → double → integer → logical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(c(\"a\", 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n chr [1:2] \"a\" \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  chr [1:2] \"a\" \"1\"\n```\n:::\n\n\nmathematical functions coerce logicals into 0 and 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\n\n# Proportion that are TRUE\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3333333\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0.333\n```\n:::\n\n\nForce coercion with the corresponding `as.*` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(c(\"1\", \"1.5\", \"a\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  1 NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Warning: NAs introduced by coercion\n#> [1]  1  1 NA\n```\n:::\n\n\n### 3.2.5 Exercises\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"a\", 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, 1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1\n```\n\n\n:::\n:::\n\n\n## 3.3 Attributes\n\nSection 3.3 takes a small detour to discuss attributes, R’s flexible metadata specification. The most important attributes are names, dimensions, and class.\n\nHow does the `dim` attribute make matrices and arrays?\n\nAttributes can be though of as name-value pairs. Retrieved with `attr()`, en masse with `attributes()`, and set en masse with `structure()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\nattr(a, \"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abcdef\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"abcdef\"\n\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ x: chr \"abcdef\"\n#>  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na <- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ x: chr \"abcdef\"\n#>  $ y: int [1:3] 4 5 6\n```\n:::\n\n\nAttributes are generally ephemeral.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(a[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> NULL\nattributes(sum(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> NULL\n```\n:::\n\n\nThere are two exceptions:\n-   **names**, a character vector giving each element a name\n-   **dim**, short for dimensions, an integer vector, used to turn vectors into matrices or arrays.\n\nName a vector in three ways:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# When creating it: \nx <- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx <- 1:3\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n```\n:::\n\n\n\nAdding a `dim` attribute allows a vector to behave like a 2-d matrix or a multidimensional array.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Two scalar arguments specify row and column sizes\nx <- matrix(1:6, nrow = 2, ncol = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n\n```{.r .cell-code}\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n\n# One vector argument to describe all dimensions\ny <- array(1:12, c(2, 3, 2))\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n```\n\n\n:::\n\n```{.r .cell-code}\n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz <- 1:6\ndim(z) <- c(3, 2)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n\n```{.r .cell-code}\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(1:3)                   # 1d vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:3] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:3, 1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1, 1:3] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:3(1d)] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  int [1:3(1d)] 1 2 3\n```\n:::\n\n\n### 3.3.4 Exercises\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What are these and how do they differ from 1:5?\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))\n```\n:::\n\n\n## 3.4 S3 atomic vectors\n\nSection 3.4 discusses the important vector types that are built by combining atomic vectors with special attributes. These include factors, dates, date-times, and durations.\n\nAn important vector attribute is `class`. Having a `class` attribute turns an object into an S3 object, which means will behave differently than a normal vector when passed to a generic function.\n\n\nNote that factors are built on Integer vectors, and POSIXct and Date vectors are built on Double vectors.\n\nFactors are vectors with only pre-defined values, defined by the attributes `class` and `levels`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a b b a\nLevels: a b\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] a b b a\n#> Levels: a b\n\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"integer\"\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> $levels\n#> [1] \"a\" \"b\"\n#> \n#> $class\n#> [1] \"factor\"\n```\n:::\n\n\nFactors will give counts of unobserved levels in functions like `table()`, unlike character vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex_char <- c(\"m\", \"m\", \"m\")\nsex_factor <- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsex_char\nm \n3 \n```\n\n\n:::\n\n```{.r .cell-code}\n#> sex_char\n#> m \n#> 3\ntable(sex_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsex_factor\nm f \n3 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n#> sex_factor\n#> m f \n#> 3 0\n```\n:::\n\n\n**Ordered** factors for when order of the levels is meaningful\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrade <- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] b b a c\nLevels: c < b < a\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] b b a c\n#> Levels: c < b < a\n```\n:::\n\n\nFactors are coerced in different ways by different functions - sometimes to strings, and sometimes the underlying integer values are used.\n\n**Dates** are built on top of double vectors and have `class` \"Date\" and no other attributes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday <- Sys.Date()\n\ntypeof(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"double\"\nattributes(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"Date\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> $class\n#> [1] \"Date\"\n```\n:::\n\n\nYou can see the value of the double by stripping the class\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 31\n```\n:::\n\n\n**Date-Times** in base R are built on top of Double vectors. One type is POSIXct.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnow_ct <- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-01 22:00:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"double\"\nattributes(now_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\n```\n:::\n\n\ntime zones change printing, not the instant of time represented\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 07:00:00 JST\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-01 18:00:00 EDT\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 08:30:00 +1030\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 CEST\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"2018-08-02 CEST\"\n```\n:::\n\n\n\n**Durations** are stored in difftimes, which are built on top of doubles and have a `units` attribute that determines how differences should be interpreted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_week_1 <- as.difftime(1, units = \"weeks\")\none_week_1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 1 weeks\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Time difference of 1 weeks\n\ntypeof(one_week_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"double\"\nattributes(one_week_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"difftime\"\n\n$units\n[1] \"weeks\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> $class\n#> [1] \"difftime\"\n#> \n#> $units\n#> [1] \"weeks\"\n\none_week_2 <- as.difftime(7, units = \"days\")\none_week_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 7 days\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Time difference of 7 days\n\ntypeof(one_week_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"double\"\nattributes(one_week_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"difftime\"\n\n$units\n[1] \"days\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> $class\n#> [1] \"difftime\"\n#> \n#> $units\n#> [1] \"days\"\n```\n:::\n\n\n### 3.4.5 Exercises\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nletters\na b c d e f g h i j k l m n o p q r s t u v w x y z \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(table(letters))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes((table(letters)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$dim\n[1] 26\n\n$dimnames\n$dimnames$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n$class\n[1] \"table\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# what happens to a factor when you modify levels?\n\nf1 <- factor(letters)\nlevels(f1) <- rev(levels(f1))\n\n# How do these differ from f1?\n\nf2 <- rev(factor(letters))\n\nf3 <- factor(letters, levels = rev(letters))\n```\n:::\n\n\n\n\n## 3.5 Lists\n\nSection 3.5 dives into lists. Lists are very similar to atomic vectors, but have one key difference: an element of a list can be any data type, including another list. This makes them suitable for representing hierarchical data.\n\n\nConstruct a list with `list()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"list\"\n\nstr(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 4\n#>  $ : int [1:3] 1 2 3\n#>  $ : chr \"a\"\n#>  $ : logi [1:3] TRUE FALSE TRUE\n#>  $ : num [1:2] 2.3 5.9\n```\n:::\n\n\nElements of a list are references and therefore do not take up as much space as you might imagine:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::obj_size(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n7.21 kB\n```\n\n\n:::\n\n```{.r .cell-code}\n#> 7.21 kB\n\nl2 <- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n7.29 kB\n```\n\n\n:::\n\n```{.r .cell-code}\n#> 7.29 kB\n```\n:::\n\n\nLists are sometimes called recursive vectors because they can contain other lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl3 <- list(list(list(1)))\nstr(l3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 1\n#>  $ :List of 1\n#>   ..$ :List of 1\n#>   .. ..$ : num 1\n```\n:::\n\n\n`c()` coerces the vectors to a list, and then flattens everything into one list\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl4 <- list(list(1, 2), c(3, 4))\nl5 <- c(list(1, 2), c(3, 4))\nstr(l4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ :List of 2\n#>   ..$ : num 1\n#>   ..$ : num 2\n#>  $ : num [1:2] 3 4\nstr(l5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 4\n#>  $ : num 1\n#>  $ : num 2\n#>  $ : num 3\n#>  $ : num 4\n```\n:::\n\n\n**Testing and coercion** - test with `is.list()` and coerce with `as.list()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [[1]]\n#> [1] 1 2 3\nas.list(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n#> \n#> [[3]]\n#> [1] 3\n```\n:::\n\n\n\n**Matrices and arrays**\n\nThe dimension attribute can be used to create list-matrices or list-arrays:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(1:3, \"a\", TRUE, 1.0)\ndim(l) <- c(2, 2)\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]      [,2]\n[1,] integer,3 TRUE\n[2,] \"a\"       1   \n```\n\n\n:::\n\n```{.r .cell-code}\n#>      [,1]      [,2]\n#> [1,] integer,3 TRUE\n#> [2,] \"a\"       1\n\nl[[1, 1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1 2 3\n```\n:::\n\n\n## 3.6 Data frames and tibbles\n\nSection 3.6 teaches you about data frames and tibbles, which are used to represent rectangular data. They combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.\n\nData frames and tibbles are built on top of lists.\n\nA data frame is a named list of vectors with attributes for (column) names, row.names, and its class, \"data.frame\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"list\"\n\nattributes(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> $names\n#> [1] \"x\" \"y\"\n#> \n#> $class\n#> [1] \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3\n```\n:::\n\n\nA data frame has rownames() and colnames(). The names() of a data frame are the column names.\n\nA data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns.\n\nTibbles are lazy and the `class` vector is longer, and includes `tbl_df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\n\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"list\"\n\nattributes(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> $class\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3\n#> \n#> $names\n#> [1] \"x\" \"y\"\n```\n:::\n\n\nCreate a data frame with name-vector pairs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  2 variables:\n $ x: int  1 2 3\n $ y: chr  \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ x: int  1 2 3\n#>  $ y: chr  \"a\" \"b\" \"c\"\n```\n:::\n\n\nCreate a tibble in the same way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n $ y: chr [1:3] \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#>  $ x: int [1:3] 1 2 3\n#>  $ y: chr [1:3] \"a\" \"b\" \"c\"\n```\n:::\n\n\nTibbles don't change non-syntactic names. Data frames do.\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(data.frame(`1` = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X1\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"X1\"\n\nnames(tibble(`1` = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"1\"\n```\n:::\n\n\nTibbles will only recycle vectors of length 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x = 1:4, y = 1:2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x y\n#> 1 1 1\n#> 2 2 2\n#> 3 3 1\n#> 4 4 2\n\n#data.frame(x = 1:4, y = 1:3)\n#> Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of\n#> rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n      x     y\n  <int> <dbl>\n1     1     1\n2     2     1\n3     3     1\n4     4     1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 4 × 2\n#>       x     y\n#>   <int> <dbl>\n#> 1     1     1\n#> 2     2     1\n#> 3     3     1\n#> 4     4     1\n\n\n# tibble(x = 1:4, y = 1:2)\n#> Error in tibble(x = 1:4, y = 1:2): Tibble columns must have compatible sizes.\n#> • Size 4: Existing data.\n#> • Size 2: Column `y`.\n#> ℹ Only values of size one are recycled.\n```\n:::\n\n\nA tibble can refer to variables created during construction. Data frames cannot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n      x     y\n  <int> <dbl>\n1     1     2\n2     2     4\n3     3     6\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 3 × 2\n#>       x     y\n#>   <int> <dbl>\n#> 1     1     2\n#> 2     2     4\n#> 3     3     6\n```\n:::\n\n\n\n**Data frames allow row names.** This is a character vector with unique values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n```\n\n\n:::\n\n```{.r .cell-code}\n#>       age  hair\n#> Bob    35 blond\n#> Susan  27 brown\n#> Sam    18 black\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(df3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Bob\"   \"Susan\" \"Sam\"  \n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    age  hair\nBob  35 blond\n```\n\n\n:::\n\n```{.r .cell-code}\n#>     age  hair\n#> Bob  35 blond\n```\n:::\n\n\nTibbles do not support rownames, but can easily convert them to a column in the tibble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(df3, rownames = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name    age hair \n  <chr> <dbl> <chr>\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 3 × 3\n#>   name    age hair \n#>   <chr> <dbl> <chr>\n#> 1 Bob      35 blond\n#> 2 Susan    27 brown\n#> 3 Sam      18 black\n```\n:::\n\n\n**Subsetting** differs by data frames and tibbles. Tibbles always return a tibble when subsetting, and no partial matching is allowed with column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(xyz = \"a\")\ndf2 <- tibble(xyz = \"a\")\n\nstr(df1$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n chr \"a\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  chr \"a\"\nstr(df2$x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Unknown or uninitialised column: `x`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n NULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Warning: Unknown or uninitialised column: `x`.\n#>  NULL\n```\n:::\n\n\nExtract single columns with `df[[\"col\"]]`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.data.frame(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\nis.data.frame(df2) # this is a tibble and it passes this test.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n```\n:::\n\n\nIf you want to distinguish:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_tibble(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\nis_tibble(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n```\n:::\n\n\n**List Columns** - since a data frame or a tibble is a list, it can contain other lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extra work is required to add a list to a data frame - either after creation or using I()\n\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x          y\n#> 1 1       1, 2\n#> 2 2    1, 2, 3\n#> 3 3 1, 2, 3, 4\n```\n:::\n\n\nList columns are easier to use in a tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n      x y        \n  <int> <list>   \n1     1 <int [2]>\n2     2 <int [3]>\n3     3 <int [4]>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 3 × 2\n#>       x y        \n#>   <int> <list>   \n#> 1     1 <int [2]>\n#> 2     2 <int [3]>\n#> 3     3 <int [4]>\n```\n:::\n\n\n**Matrix and data frame columns** are possible, but not advised. The NROW() og the matrix must match the data frame number of rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfm <- data.frame(\n  x = 1:3 * 10\n)\ndfm$y <- matrix(1:9, nrow = 3)\ndfm$z <- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  3 variables:\n $ x: num  10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':\t3 obs. of  2 variables:\n  ..$ a: int  3 2 1\n  ..$ b: chr  \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> 'data.frame':    3 obs. of  3 variables:\n#>  $ x: num  10 20 30\n#>  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#>  $ z:'data.frame':   3 obs. of  2 variables:\n#>   ..$ a: int  3 2 1\n#>   ..$ b: chr  \"a\" \"b\" \"c\"\n```\n:::\n\n\n\n\n## 3.7 NULL\n\nAlways length zero, and cannot have attributes. A unique type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NULL\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"NULL\"\n\nlength(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0\n\nx <- NULL\n# attr(x, \"y\") <- 1\n#> Error in attr(x, \"y\") <- 1: attempt to set an attribute on NULL\n```\n:::\n\n\n`NULL` represents an absent vector, whereas `NA` represents an absent element. `NULL` can be useful in default function arguments.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}