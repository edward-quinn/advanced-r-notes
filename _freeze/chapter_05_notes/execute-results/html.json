{
  "hash": "e21ced62b9b21a19a5be950ab699274a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Advanced R - Chapter 5 Notes\nfreeze: true\nformat:\n  html:\n      toc: true\n---\n\n# 5 Control Flow\n\n-   Choices. Run different code depending on input.\n-   Loops. Repeatedly run code, typically with changing options.\n\n## 5.2 Choices\n\nSection 5.2 dives into the details of if, then discusses the close relatives ifelse() and switch().\n\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrade <- function(x) {\n  if (x > 90) {\n    \"A\"\n  } else if (x > 80) {\n    \"B\"\n  } else if (x > 50) {\n    \"C\"\n  } else {\n    \"F\"\n  }\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- if (TRUE) 1 else 2\nx2 <- if (FALSE) 1 else 2\n\nc(x1, x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1 2\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet <- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi Maria\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi Jaime and HAPPY BIRTHDAY\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n```\n:::\n\n\nThe condition should evaluate to a single TRUE or FALSE\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if (\"x\") 1\n# #> Error in if (\"x\") 1: argument is not interpretable as logical\n# if (logical()) 1\n# #> Error in if (logical()) 1: argument is of length zero\n# if (NA) 1\n# #> Error in if (NA) 1: missing value where TRUE/FALSE needed\n# if (c(TRUE, FALSE)) 1\n# #> Error in if (c(TRUE, FALSE)) 1: the condition has length > 1\n```\n:::\n\n\n\n**Vectorized if**\n\nWhat if you have more than one TRUE or FALSE value?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n```\n:::\n\n\n`dplyr::case_when` is another vectorized if\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n```\n:::\n\n\n\n`if()` statements can be made more compact with `switch()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_option <- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_option <- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    # The last component of a switch() should always throw \n    # an error, otherwise unmatched inputs will invisibly return NULL\n    stop(\"Invalid `x` value\") \n  )\n}\n```\n:::\n\n\nIf multiple inputs have the same output, you can leave the RHS of `=` empty until the last input with the same output\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlegs <- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 4\nlegs(\"dog\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 4\n```\n:::\n\n\n## 5.3 Loops\n\nSection 5.3 starts off by reminding you of the basic structure of the for loop in R, discusses some common pitfalls, and then talks about the related while and repeat statements.\n\nBasic structure: for (item in vector) perform_action\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n```\n:::\n\n\nN.B.: for assigns the item to the current environment, overwriting any existing variable with the same name:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 100\nfor (i in 1:3) {}\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3\n```\n:::\n\n\nYou can use `next` to exit the current iteration and `break` to exit the entire `for` loop.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  if (i < 3) \n    next\n\n  print(i)\n  \n  if (i >= 5)\n    break\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n\n**Common Pitfalls** when using `for` loops\n\n1. If you are generating data, pre-allocate the output container. This improves speed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans <- c(1, 50, 20)\nout <- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] <- rnorm(10, means[[i]])\n}\n```\n:::\n\n\n\n2. Beware of iterating over `1:length(x)`, which will fail in unhelpful ways if `x` has length 0. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# means <- c()\n# out <- vector(\"list\", length(means))\n# for (i in 1:length(means)) {\n#   out[[i]] <- rnorm(10, means[[i]])\n# }\n# #> Error in rnorm(10, means[[i]]): invalid arguments\n```\n:::\n\n\nUse `seq_along()` instead.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(means)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> integer(0)\n\nout <- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] <- rnorm(10, means[[i]])\n}\n```\n:::\n\n\n3. Call `[[` yourself when iterating over S3 vectors, as loops typically strip the attributes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18262\n[1] 14610\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 18262\n#> [1] 14610\n```\n:::\n\n\nHere's the fix:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2020-01-01\"\n[1] \"2010-01-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"2020-01-01\"\n#> [1] \"2010-01-01\"\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}