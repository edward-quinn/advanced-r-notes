{
  "hash": "8ed841fb043a17ca75bd44b7d90a03d3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Advanced R - Chapter 8 Notes\nformat:\n  html:\n      toc: true\nfreeze: true\n---\n\n# 8 Conditions\n\nAuthors of functions can indicate that something unusual is happening, and that the user needs to deal with it. The function author can signal conditions with functions like `stop()` for errors, `warning()` for warnings, and `message()` for messages, then the function user can handle them with functions like `tryCatch()` and `withCallingHandlers()`.\n\n\n## 8.2 Signalling Conditions\n\nSection 8.2 introduces the basic tools for signalling conditions, and discusses when it is appropriate to use each type. You can signal errors, warnings, or messages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\n\n# stop(\"This is what an error looks like\")\n# #> Error: This is what an error looks like\n\nwarning(\"This is what a warning looks like\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: This is what a warning looks like\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Warning: This is what a warning looks like\n\nmessage(\"This is what a message looks like\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis is what a message looks like\n```\n\n\n:::\n\n```{.r .cell-code}\n#> This is what a message looks like\n```\n:::\n\n\n**Errors** are signaled, or thrown, by `stop()`, or by `rlang::abort()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# f <- function() g()\n# g <- function() h()\n# h <- function() stop(\"This is an error!\")\n\n# f()\n# #> Error in h(): This is an error!\n\n# h <- function() abort(\"This is an error!\")\n# f()\n# #> Error in h(): This is an error!\n```\n:::\n\n\n\n\n**Warnings** can be generated (any amount) from a single function call. `warning()` and `rlang::warn()` do the same thing with slightly different defaults.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfw <- function() {\n  cat(\"1\\n\")\n  warning(\"W1\")\n  cat(\"2\\n\")\n  warning(\"W2\")\n  cat(\"3\\n\")\n  warning(\"W3\")\n}\n\nfw()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in fw(): W1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in fw(): W2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in fw(): W3\n```\n\n\n:::\n:::\n\n\n\nWarnings are appropriate to notify users of a deprecated function and when you are reasonably certain you can recover from a problem.\n\n**Messages** are useful when:\n1. When a default argument requires some non-trivial amount of computation and you want to tell the user what value was used.\n2. To provide regular status updates in functions that are called for side-effects, like writing to disk.\n3. When you're about to start a long running process with no intermediate output.\n4. When writing a package, and you want to display a message when your package is loaded.\n\n\n## 8.3 Ignoring conditions\n\nSection 8.3 teaches you about the simplest tools for handling conditions: functions like try() and suppressMessages() that swallow conditions and prevent them from getting to the top level.\n\n-   Ignore errors with `try()`.\n-   Ignore warnings with `suppressWarnings()`.\n-   Ignore messages with `suppressMessages()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# f1 <- function(x) {\n#   log(x)\n#   10\n# }\n# f1(\"x\")\n# #> Error in log(x): non-numeric argument to mathematical function\n\nf2 <- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in log(x) : non-numeric argument to mathematical function\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Error in log(x) : non-numeric argument to mathematical function\n#> [1] 10\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressWarnings({\n  warning(\"Uhoh!\")\n  warning(\"Another warning\")\n  1\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\n\nsuppressMessages({\n  message(\"Hello there\")\n  2\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2\n\nsuppressWarnings({\n  message(\"You can still see me\")\n  3\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nYou can still see me\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> You can still see me\n#> [1] 3\n```\n:::\n\n\n\n## 8.4 Handling conditions\n\nSection 8.4 introduces the condition object, and the two fundamental tools of condition handling: `tryCatch()` for error conditions, and `withCallingHandlers()` for everything else. These are the registration handlers.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tryCatch(\n#   error = function(cnd) {\n#     # code to run when error is thrown\n#   },\n#   code_to_run_while_handlers_are_active\n# )\n\n# withCallingHandlers(\n#   warning = function(cnd) {\n#     # code to run when warning is signalled\n#   },\n#   message = function(cnd) {\n#     # code to run when message is signalled\n#   },\n#   code_to_run_while_handlers_are_active\n# )\n```\n:::\n\n\n`tryCatch()` and `withCallingHandlers()` differ in the type of handlers that they create:\n\n`tryCatch()` defines exiting handlers. `withCallingHandlers()` defines calling handlers. After the condition is captured control returns to the context where the condition was signalled. Suitable for non-error conditions.\n\n**Condition objects** are created implicitly whenever you signal a condition, but become explicit inside the handler. You can catch a condition object using `rlang::catch_cnd()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncnd <- catch_cnd(stop(\"An error\"))\nstr(cnd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ message: chr \"An error\"\n $ call   : language force(expr)\n - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ message: chr \"An error\"\n#>  $ call   : language force(expr)\n#>  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n```\n:::\n\n\nBuilt-in conditions are lists with two elements:\n1. `message`, a length-1 character vector containing the text to display to a user. \n2. `call`, the call which triggered the condition.\n\nThey also have a `class` attribute, which makes them S3 objects. This is a character vector that determines which handlers will match the condition.\n\n**Exiting handlers**\n\n`tryCatch()` registers exiting handlers and is typically used to handle error conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf3 <- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] NA\n```\n:::\n\n\nThe handlers set up by `tryCatch()` are called **exiting handlers** because after the condition is signalled, control passes to the handler and never returns tothe original code, effectively meaning that the code exits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n  message = function(cnd) \"There\",\n  {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"There\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"There\"\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n  error = function(cnd) {\n    paste0(\"--\", conditionMessage(cnd), \"--\")\n  },\n  stop(\"This is an error\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"--This is an error--\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"--This is an error--\"\n```\n:::\n\n\nUse the `finally` argument in `tryCatch()` to always end a block of code with another block of code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- tempfile()\ntryCatch(\n  {\n    writeLines(\"Hi!\", path)\n    # ...\n  },\n  finally = {\n    # always run\n    unlink(path)\n  }\n)\n```\n:::\n\n\n**Calling handlers**. Use `withCallingHandlers()` to set up **calling** handlers; code execution continues normally once the handler returns.\n\nNB: there is a difference between exiting handlers handle problems by making them go away. A calling handler handles a problem like you handle a car.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCaught a message!\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Caught a message!\n\nwithCallingHandlers(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCaught a message!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSomeone there?\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCaught a message!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWhy, yes!\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Caught a message!\n#> Someone there?\n#> Caught a message!\n#> Why, yes!\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bubbles all the way up to default handler which generates the message\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLevel 1\nLevel 2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Level 1\n#> Level 2\n#> Hello\n\n# Bubbles up to tryCatch\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLevel 1\nLevel 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Level 1\n#> Level 2\n```\n:::\n\n\nYou can **muffle** conditions to prevent them from \"bubbling up\" to parent handlers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Muffles the default handler which prints the messages\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Level 2\\n\")\n    cnd_muffle(cnd)\n  },\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLevel 1\nLevel 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Level 1\n#> Level 2\n\n# Muffles level 2 handler and the default handler\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLevel 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Level 1\n```\n:::\n\n\n**Call stacks** are different between exiting and calling handlers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function() g()\ng <- function() h()\nh <- function() message(\"!\")\n\nwithCallingHandlers(f(), message = function(cnd) {\n  lobstr::cst()\n  cnd_muffle(cnd)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     ▆\n  1. ├─base::withCallingHandlers(...)\n  2. ├─global f()\n  3. │ └─global g()\n  4. │   └─global h()\n  5. │     └─base::message(\"!\")\n  6. │       ├─base::withRestarts(...)\n  7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n  8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n  9. │       └─base::signalCondition(cond)\n 10. └─global `<fn>`(`<smplMssg>`)\n 11.   └─lobstr::cst()\n```\n\n\n:::\n\n```{.r .cell-code}\n#>      ▆\n#>   1. ├─base::withCallingHandlers(...)\n#>   2. ├─global f()\n#>   3. │ └─global g()\n#>   4. │   └─global h()\n#>   5. │     └─base::message(\"!\")\n#>   6. │       ├─base::withRestarts(...)\n#>   7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n#>   8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n#>   9. │       └─base::signalCondition(cond)\n#>  10. └─global `<fn>`(`<smplMssg>`)\n#>  11.   └─lobstr::cst()\n\ntryCatch(f(), message = function(cnd) lobstr::cst())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    ▆\n 1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n 2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n 3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n 4.       └─value[[3L]](cond)\n 5.         └─lobstr::cst()\n```\n\n\n:::\n\n```{.r .cell-code}\n#>     ▆\n#>  1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n#>  2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n#>  3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#>  4.       └─value[[3L]](cond)\n#>  5.         └─lobstr::cst()\n```\n:::\n\n\n## 8.5 Custom conditions\n\nSection 8.5 shows you how to extend the built-in condition objects to store useful data that condition handlers can use to make more informed decisions.\n\nHere is the basic pattern:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# abort(\n#   \"error_not_found\",\n#   message = \"Path `blah.csv` not found\", \n#   path = \"blah.csv\"\n# )\n# #> Error: Path `blah.csv` not found\n```\n:::\n\n\n**Motivation**. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# log(letters)\n# #> Error in log(letters): non-numeric argument to mathematical function\n# log(1:10, base = letters)\n# #> Error in log(1:10, base = letters): non-numeric argument to mathematical\n# #> function\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log <- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort(paste0(\n      \"`x` must be a numeric vector; not \", typeof(x), \".\"\n    ))\n  }\n  if (!is.numeric(base)) {\n    abort(paste0(\n      \"`base` must be a numeric vector; not \", typeof(base), \".\"\n    ))\n  }\n\n  base::log(x, base = base)\n}\n```\n:::\n\n\nAnd now we have more useful error messages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# my_log(letters)\n# #> Error in my_log(letters): `x` must be a numeric vector; not character.\n# my_log(1:10, base = letters)\n# #> Error in my_log(1:10, base = letters): `base` must be a numeric vector; not\n# #> character.\n```\n:::\n\n\n**Signalling**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabort_bad_argument <- function(arg, must, not = NULL) {\n  msg <- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not <- typeof(not)\n    msg <- glue::glue(\"{msg}; not {not}.\")\n  }\n  \n  abort(\"error_bad_argument\", \n    message = msg, \n    arg = arg, \n    must = must, \n    not = not\n  )\n}\n\n# OR if you don't want a dependency on rlang\n\nstop_custom <- function(.subclass, message, call = NULL, ...) {\n  err <- structure(\n    list(\n      message = message,\n      call = call,\n      ...\n    ),\n    class = c(.subclass, \"error\", \"condition\")\n  )\n  stop(err)\n}\n\nerr <- catch_cnd(\n  stop_custom(\"error_new\", \"This is a custom error\", x = 10)\n)\nclass(err)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"error_new\" \"error\"     \"condition\"\n```\n\n\n:::\n\n```{.r .cell-code}\nerr$x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log <- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# my_log(letters)\n# #> Error in abort_bad_argument(\"x\", must = \"be numeric\", not = x): `x` must be\n# #> numeric; not character.\n# my_log(1:10, base = letters)\n# #> Error in abort_bad_argument(\"base\", must = \"be numeric\", not = base): `base`\n# #> must be numeric; not character.\n```\n:::\n\n\n**Handling**. Structured condition objects are much easier to program with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(testthat)\n\nerr <- catch_cnd(my_log(\"a\"))\nexpect_s3_class(err, \"error_bad_argument\")\nexpect_equal(err$arg, \"x\")\nexpect_equal(err$not, \"character\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bad_argument\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"bad_argument\"\n```\n:::\n\n\n## 8.6 Applications\n\nSection 8.6 closes out the chapter with a grab bag of practical applications based on the low-level tools found in earlier sections.\n\n**Failure values** can be useful with `tryCatch()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfail_with <- function(expr, value = NULL) {\n  tryCatch(\n    error = function(cnd) value,\n    expr\n  )\n}\n\nfail_with(log(10), NA_real_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.302585\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2.3\nfail_with(log(\"x\"), NA_real_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] NA\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry2 <- function(expr, silent = FALSE) {\n  tryCatch(\n    error = function(cnd) {\n      msg <- conditionMessage(cnd)\n      if (!silent) {\n        message(\"Error: \", msg)\n      }\n      structure(msg, class = \"try-error\")\n    },\n    expr\n  )\n}\n\ntry2(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\ntry2(stop(\"Hi\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nError: Hi\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi\"\nattr(,\"class\")\n[1] \"try-error\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Error: Hi\n#> [1] \"Hi\"\n#> attr(,\"class\")\n#> [1] \"try-error\"\ntry2(stop(\"Hi\"), silent = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi\"\nattr(,\"class\")\n[1] \"try-error\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"Hi\"\n#> attr(,\"class\")\n#> [1] \"try-error\"\n```\n:::\n\n\n**Success and failure values** are another use case. Return one success when the code works, and fail when it doesn't.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- function(expr) {\n  tryCatch(\n    error = function(cnd) error_val,\n    {\n      expr\n      success_val\n    }\n  )\n}\n\ndoes_error <- function(expr) {\n  tryCatch(\n    error = function(cnd) TRUE,\n    {\n      expr\n      FALSE\n    }\n  )\n}\n```\n:::\n\n\nYou can also use this sort of pattern to create a `try()` variant:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsafety <- function(expr) {\n  tryCatch(\n    error = function(cnd) {\n      list(result = NULL, error = cnd)\n    },\n    list(result = expr, error = NULL)\n  )\n}\n\nstr(safety(1 + 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ result: num 11\n $ error : NULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ result: num 11\n#>  $ error : NULL\nstr(safety(stop(\"Error!\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ result: NULL\n $ error :List of 2\n  ..$ message: chr \"Error!\"\n  ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n  ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ result: NULL\n#>  $ error :List of 2\n#>   ..$ message: chr \"Error!\"\n#>   ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n#>   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n```\n:::\n\n\n**Resignal** meaning turn warnings into errors, for example.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwarning2error <- function(expr) {\n  withCallingHandlers(\n    warning = function(cnd) abort(conditionMessage(cnd)),\n    expr\n  )\n}\n\n# warning2error({\n#   x <- 2 ^ 4\n#   warn(\"Hello\")\n# })\n# #> Error in (function (cnd) : Hello\n```\n:::\n\n\n**Record**. The problem is that calling handlers have side-effects, not return values. Need to modify objects in place.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncatch_cnds <- function(expr) {\n  conds <- list()\n  add_cond <- function(cnd) {\n    conds <<- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n  \n  withCallingHandlers(\n    message = add_cond,\n    warning = add_cond,\n    expr\n  )\n  \n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  inform(\"c\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n<message/rlang_message>\nMessage:\na\n\n[[2]]\n<warning/rlang_warning>\nWarning:\nb\n\n[[3]]\n<message/rlang_message>\nMessage:\nc\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [[1]]\n#> <message/rlang_message>\n#> Message:\n#> a\n#> \n#> [[2]]\n#> <warning/rlang_warning>\n#> Warning:\n#> b\n#> \n#> [[3]]\n#> <message/rlang_message>\n#> Message:\n#> c\n```\n:::\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}