{
  "hash": "4ca3d6d25c797b26281a48b8262f253c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Advanced R - Chapter 4 Notes\nfreeze: true\nformat:\n  html:\n      toc: true\n---\n\n# 4 Subsetting\n-   Six ways to subset atomic vectors\n-   Three subsetting operators\n-   Subsetting operators interact differently with different vector types (e.g., atomic vectors, lists, factors, matrices, and data frames).\n-   Subsetting can be combined with assignment.\n\n## 4.2 Selecting multiple elements\n\nSection 4.2 starts by teaching you about `[`. You’ll learn the six ways to subset atomic vectors. You’ll then learn how those six ways act when used to subset lists, matrices, and data frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2.1, 4.2, 3.3, 5.4)\n```\n:::\n\n\nSubset with positive integers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(3, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.3 2.1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3.3 2.1\nx[order(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.1 3.3 4.2 5.4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.1 2.1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2.1 2.1\n\n# Real numbers are silently truncated to integers - \n# rounding down and then giving the second integer\nx[c(2.1, 2.9)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2 4.2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 4.2 4.2\n```\n:::\n\n\nNegative integers exclude elements at specific positions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-c(3, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2 5.4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 4.2 5.4\n\n# removes elements 3 and 1\n```\n:::\n\n\nYou cannot mix positive and negative integers in a single subset.\n\nLogical vectors subset where the condition is met\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(TRUE, TRUE, FALSE, FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.1 4.2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2.1 4.2\nx[x > 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2 3.3 5.4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 4.2 3.3 5.4\n```\n:::\n\n\nNothing returns the original vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.1 4.2 3.3 5.4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2.1 4.2 3.3 5.4\n```\n:::\n\n\nNamed vectors can be subset with character vectors that match the names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(y <- setNames(x, letters[1:4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a   b   c   d \n2.1 4.2 3.3 5.4 \n```\n\n\n:::\n\n```{.r .cell-code}\n#>   a   b   c   d \n#> 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  d   c   a \n5.4 3.3 2.1 \n```\n\n\n:::\n\n```{.r .cell-code}\n#>   d   c   a \n#> 5.4 3.3 2.1\n\n# Like integer indices, you can repeat indices\ny[c(\"a\", \"a\", \"a\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a   a   a \n2.1 2.1 2.1 \n```\n\n\n:::\n\n```{.r .cell-code}\n#>   a   a   a \n#> 2.1 2.1 2.1\n\n# When subsetting with [, names are always matched exactly\nz <- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<NA> <NA> \n  NA   NA \n```\n\n\n:::\n\n```{.r .cell-code}\n#> <NA> <NA> \n#>   NA   NA\n```\n:::\n\n\nAvoid subsetting with factors, as they use the underlying integer vector, not the character levels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[factor(\"b\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a \n2.1 \n```\n\n\n:::\n\n```{.r .cell-code}\n#>   a \n#> 2.1\n\n# Here the `factor(b)` call is return an integer of value 1, so it's returning the first element in the vector being subset, not the element with a name equivalent to \"b\".\n```\n:::\n\n\n\n**Lists**  - Using `[` always returns a list; `[[` and `$` let you pull out elements of a list.\n\n\n::: {.cell}\n\n:::\n\n\n**Matrices and arrays**\n\nSubset higher dimensional structures in three ways\n1. multiple vectors\n2. single vector\n3. a matrix\n\nblank subsetting retains all rows or columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- matrix(1:9, nrow = 3)\ncolnames(a) <- c(\"A\", \"B\", \"C\")\na[1:2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n```\n\n\n:::\n\n```{.r .cell-code}\n#>      A B C\n#> [1,] 1 4 7\n#> [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     B A\n[1,] 4 1\n[2,] 6 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>      B A\n#> [1,] 4 1\n#> [2,] 6 3\na[0, -2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     A C\n```\n\n\n:::\n\n```{.r .cell-code}\n#>      A C\n```\n:::\n\n\nBy default, `[` simplifies to the lowest possible dimensionality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA B C \n1 4 7 \n```\n\n\n:::\n\n```{.r .cell-code}\n#> A B C \n#> 1 4 7\na[1, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA \n1 \n```\n\n\n:::\n\n```{.r .cell-code}\n#> A \n#> 1\n```\n:::\n\n\nmatrices are just vectors with special attributes, and so can be subset with a single vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvals <- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]  [,2]  [,3]  [,4]  [,5] \n[1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n[2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n[3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n[4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n[5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#>      [,1]  [,2]  [,3]  [,4]  [,5] \n#> [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#> [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#> [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#> [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#> [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"4,1\" \"5,3\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"4,1\" \"5,3\"\n```\n:::\n\n\nYou can also subset higher dimensional structures with an integer matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect <- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nvals[select]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1,1\" \"3,1\" \"2,4\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"1,1\" \"3,1\" \"2,4\"\n```\n:::\n\n\n**Data frames and tibbles**\n\nSubsetting with one index indexes the columns; with two you are indexing rows and then columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n2 2 2 b\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x y z\n#> 2 2 2 b\ndf[c(1, 3), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n1 1 3 a\n3 3 1 c\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x y z\n#> 1 1 3 a\n#> 3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x z\n1 1 a\n2 2 b\n3 3 c\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x z\n#> 1 1 a\n#> 2 2 b\n#> 3 3 c\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x z\n1 1 a\n2 2 b\n3 3 c\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x z\n#> 1 1 a\n#> 2 2 b\n#> 3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  1 variable:\n $ x: int  1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> 'data.frame':    3 obs. of  1 variable:\n#>  $ x: int  1 2 3\nstr(df[, \"x\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:3] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  int [1:3] 1 2 3\n```\n:::\n\n\nSubsetting a tibble with `[` always returns a tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(df[\"x\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#>  $ x: int [1:3] 1 2 3\nstr(df[, \"x\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n $ x: int [1:3] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#>  $ x: int [1:3] 1 2 3\n```\n:::\n\n\nYou can use the `drop` argument when subsetting to preserve dimensionality\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- matrix(1:4, nrow = 2)\nstr(a[1, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:2] 1 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1, 1:2] 1 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  int [1, 1:2] 1 3\n```\n:::\n\n\nPreserving dimensionality for data frames\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(a = 1:2, b = 1:2)\nstr(df[, \"a\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:2] 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  int [1:2] 1 2\n\nstr(df[, \"a\", drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t2 obs. of  1 variable:\n $ a: int  1 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> 'data.frame':    2 obs. of  1 variable:\n#>  $ a: int  1 2\n```\n:::\n\n\nTibbles default to `drop = FALSE`.\n\nFactors also have `drop = FALSE` as a default.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- factor(c(\"a\", \"b\"))\nz[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a\nLevels: a b\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] a\n#> Levels: a b\nz[1, drop = TRUE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a\nLevels: a\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] a\n#> Levels: a\n```\n:::\n\n\n## 4.2.6 Exercises\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[mtcars$cyl == 4, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[-c(1:4), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[mtcars$cyl <= 5,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n:::\n\n\n## 4.3 Selecting a single element\n\nSection 4.3 expands your knowledge of subsetting operators to include `[[` and `$` and focuses on the important principles of simplifying versus preserving.\n\n`[[` is for extracting single items, while `x$y` is useful shorthand for `x[[\"y\"]]`.\n\nNote that `[` on a list always returns a list. Using `[[` to return an item within a list. Note that `[[` cannot be used with more than two items, unless you are subsetting within a single item within a list. This is best avoided in favor of `purrr:pluck()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1:3, \"a\", 4:6)\n```\n:::\n\n\nNote the main difference between `$` and `[[` is that `$` does partial matching.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(abc = 1)\nx$a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\nx[[\"a\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> NULL\n```\n:::\n\n\n**Missing and out-of-bounds** indices. These are well handled by `pluck` and `chuck` from `purrr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1\n\npurrr::pluck(x, \"c\", 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] NA\n```\n:::\n\n\n\n## 4.4 Subsetting and assignment\n\nIn Section 4.4 you’ll learn the art of subassignment, which combines subsetting and assignment to modify parts of an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\nx[c(1, 2)] <- c(101, 102)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 101 102   3   4   5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 101 102   3   4   5\n```\n:::\n\n\nYou can use `NULL` to remove a component from a list or set the value to `NULL`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1, b = 2)\nx[[\"b\"]] <- NULL\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ a: num 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 1\n#>  $ a: num 1\n\ny <- list(a = 1, b = 2)\ny[\"b\"] <- list(NULL)\nstr(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ a: num 1\n $ b: NULL\n```\n\n\n:::\n\n```{.r .cell-code}\n#> List of 2\n#>  $ a: num 1\n#>  $ b: NULL\n```\n:::\n\n\nChanging contents vs changing bound objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mtcars[] <- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n# #> [1] TRUE\n\n# mtcars <- lapply(mtcars, as.integer)\n# is.data.frame(mtcars)\n#> [1] FALSE\n```\n:::\n\n\n\n## 4.5 Applications\n\nSection 4.5 leads you through eight important, but not obvious, applications of subsetting to solve problems that you often encounter in data analysis.\n\n### 4.5.1 Lookup tables (character subsetting)\n\nConvert abbreviations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup <- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       m        f        u        f        f        m        m \n  \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\" \n```\n\n\n:::\n\n```{.r .cell-code}\n#>        m        f        u        f        f        m        m \n#>   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\n\nunname(lookup[x])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\"  \n```\n\n\n:::\n:::\n\n\n### 4.5.2 Matching and merging by hand (integer subsetting)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrades <- c(1, 2, 2, 3, 1)\n\ninfo <- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\n\nid <- match(grades, info$grade)\nid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 2 2 1 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3 2 2 1 3\ninfo[id, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    grade      desc  fail\n3       1      Poor  TRUE\n2       2      Good FALSE\n2.1     2      Good FALSE\n1       3 Excellent FALSE\n3.1     1      Poor  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#>     grade      desc  fail\n#> 3       1      Poor  TRUE\n#> 2       2      Good FALSE\n#> 2.1     2      Good FALSE\n#> 1       3 Excellent FALSE\n#> 3.1     1      Poor  TRUE\n```\n:::\n\n\n### 4.5.3 Random samples and bootstraps (integer subsetting)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Randomly reorder\ndf[sample(nrow(df)), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n4 1 2 d\n1 1 5 a\n3 3 3 c\n5 2 1 e\n2 2 4 b\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x y z\n#> 5 2 1 e\n#> 3 3 3 c\n#> 4 1 2 d\n#> 1 1 5 a\n#> 2 2 4 b\n\n# Select 3 random rows\ndf[sample(nrow(df), 3), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n5 2 1 e\n1 1 5 a\n3 3 3 c\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x y z\n#> 4 1 2 d\n#> 2 2 4 b\n#> 1 1 5 a\n\n# Select 6 bootstrap replicates\ndf[sample(nrow(df), 6, replace = TRUE), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    x y z\n3   3 3 c\n5   2 1 e\n5.1 2 1 e\n2   2 4 b\n5.2 2 1 e\n1   1 5 a\n```\n\n\n:::\n\n```{.r .cell-code}\n#>     x y z\n#> 5   2 1 e\n#> 5.1 2 1 e\n#> 5.2 2 1 e\n#> 2   2 4 b\n#> 3   3 3 c\n#> 3.1 3 3 c\n```\n:::\n\n\n\n### 4.5.4 Ordering (integer subsetting)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"b\", \"c\", \"a\")\norder(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3 1 2\nx[order(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"a\" \"b\" \"c\"\n```\n:::\n\n\nUsing `order` with two dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Randomly reorder df\ndf2 <- df[sample(nrow(df)), 3:1]\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  z y x\n4 d 2 1\n5 e 1 2\n2 b 4 2\n3 c 3 3\n1 a 5 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   z y x\n#> 5 e 1 2\n#> 1 a 5 1\n#> 4 d 2 1\n#> 2 b 4 2\n#> 3 c 3 3\n\ndf2[order(df2$x), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  z y x\n4 d 2 1\n1 a 5 1\n5 e 1 2\n2 b 4 2\n3 c 3 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   z y x\n#> 1 a 5 1\n#> 4 d 2 1\n#> 5 e 1 2\n#> 2 b 4 2\n#> 3 c 3 3\ndf2[, order(names(df2))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n4 1 2 d\n5 2 1 e\n2 2 4 b\n3 3 3 c\n1 1 5 a\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x y z\n#> 5 2 1 e\n#> 1 1 5 a\n#> 4 1 2 d\n#> 2 2 4 b\n#> 3 3 3 c\n```\n:::\n\n\n### 4.5.5 Expanding aggregated counts (integer subsetting)\n\nwhen you get identical rows collapsed into one, with a column for count `n`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 1 2 2 2 2 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    x  y n\n1   2  9 3\n1.1 2  9 3\n1.2 2  9 3\n2   4 11 5\n2.1 4 11 5\n2.2 4 11 5\n2.3 4 11 5\n2.4 4 11 5\n3   1  6 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#>     x  y n\n#> 1   2  9 3\n#> 1.1 2  9 3\n#> 1.2 2  9 3\n#> 2   4 11 5\n#> 2.1 4 11 5\n#> 2.2 4 11 5\n#> 2.3 4 11 5\n#> 2.4 4 11 5\n#> 3   1  6 1\n```\n:::\n\n\n### 4.5.6 Removing columns from data frames (character)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z <- NULL\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 3\n2 2 2\n3 3 1\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 3\n2 2 2\n3 3 1\n```\n\n\n:::\n\n```{.r .cell-code}\n#>   x y\n#> 1 1 3\n#> 2 2 2\n#> 3 3 1\n```\n:::\n\n\n### 4.5.7 Selecting rows based on a condition (logical subsetting)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[mtcars$gear == 5, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\nMaserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\n```\n\n\n:::\n\n```{.r .cell-code}\n#>                 mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#> Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#> Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n#> Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4\n#> Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6\n#> Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa  30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n```\n\n\n:::\n\n```{.r .cell-code}\n#>                mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#> Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#> Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n```\n:::\n\n\n### 4.5.8 Boolean algebra versus sets (logical and integer)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- sample(10) < 4\nwhich(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2 3 4\n\nunwhich <- function(x, n) {\n  out <- rep_len(FALSE, n)\n  out[x] <- TRUE\n  out\n}\nunwhich(which(x), 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x1 <- 1:10 %% 2 == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 <- which(x1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1]  2  4  6  8 10\n(y1 <- 1:10 %% 5 == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 <- which(y1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1]  5 10\n\n# X & Y <-> intersect(x, y)\nx1 & y1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 10\n\n# X | Y <-> union(x, y)\nx1 | y1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10  5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1]  2  4  6  8 10  5\n\n# X & !Y <-> setdiff(x, y)\nx1 & !y1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 8\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2 4 6 8\n\n# xor(X, Y) <-> setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 8 5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 2 4 6 8 5\n```\n:::\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}